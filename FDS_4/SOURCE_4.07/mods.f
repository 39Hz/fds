      MODULE PREC
C
C Set the parameters for ``single'' and ``double'' precision
C
      IMPLICIT NONE
C
      INTEGER, PARAMETER :: FB = SELECTED_REAL_KIND(6)
      INTEGER, PARAMETER :: EB = SELECTED_REAL_KIND(12)
C
      END MODULE PREC
C
C
C
      MODULE TYPES
C
      USE PREC
      IMPLICIT NONE
C
      TYPE WALL_TYPE
      REAL(EB), POINTER, DIMENSION(:) :: TMP_S
      REAL(EB), POINTER, DIMENSION(:,:) :: ILW
      END TYPE WALL_TYPE
C
      TYPE DROPLET_TYPE
      REAL(EB) :: X,Y,Z,TMP,U,V,W,R,PWT,A_X,A_Y,A_Z,T
      LOGICAL  :: SHOW
      INTEGER  :: IOR,CLASS
      END TYPE DROPLET_TYPE
C
      TYPE HUMAN_TYPE
      REAL(EB) :: X,Y,Z,U,V,W,F_X,F_Y,X_old,Y_old
      REAL(EB) :: Speed, Radius, Mass, Tpre, Tau, Eta, Ksi
      REAL(EB) :: A, B, C_Young, Gamma, Kappa, Lambda
      REAL(EB) :: SumForces, IntDose, DoseCrit1, DoseCrit2
      REAL(EB) :: TempMax1, FluxMax1, TempMax2, FluxMax2
      LOGICAL  :: SHOW, NewRnd
      INTEGER  :: IOR, ILABEL, COLOR_INDEX, INODE, IMESH, IPC
      CHARACTER(26) :: FFIELD_NAME
      CHARACTER(60) :: LINE_NAME, NODE_NAME
      END TYPE HUMAN_TYPE
C
      TYPE OMESH_TYPE
      REAL(EB), POINTER, DIMENSION(:,:,:) :: TMP,U,V,W,H
      REAL(EB), POINTER, DIMENSION(:,:,:,:) :: YY,YYS
      REAL(EB), POINTER, DIMENSION(:) :: RPKG1,RPKG2,SPKG1,SPKG2,
     .                   WSPKG,WRPKG
      INTEGER, POINTER, DIMENSION(:,:) :: IJKW
      INTEGER, POINTER, DIMENSION(:) :: IV
      TYPE(WALL_TYPE), POINTER, DIMENSION(:) :: WALL
      TYPE(DROPLET_TYPE), POINTER, DIMENSION(:) :: DROPLET
      INTEGER :: N_DROP_ORPHANS,N_DROP_ORPHANS_DIM,N_DROP_ADOPT
      REAL(EB), POINTER, DIMENSION(:) :: R_RDBUF,S_RDBUF
      INTEGER , POINTER, DIMENSION(:) :: R_IDBUF,S_IDBUF
      LOGICAL , POINTER, DIMENSION(:) :: R_LDBUF,S_LDBUF
      END TYPE OMESH_TYPE
C
      TYPE OBSTRUCTION_TYPE
      INTEGER :: I1,I2,J1,J2,K1,K2,
     .           HEAT_INDEX_REMOVE,HEAT_INDEX_CREATE,BCI,BTI,ORDINAL
      CHARACTER(26) :: HEAT_REMOVE,HEAT_CREATE
      CHARACTER(60) :: MESH_ID
      REAL(EB), DIMENSION(4) :: RGB
      REAL(EB), DIMENSION(3) :: TEXTURE
      INTEGER, DIMENSION(-3:3) :: IBC
      INTEGER, DIMENSION(3) :: DIMENSIONS
      REAL(EB) :: X1,X2,Y1,Y2,Z1,Z2,T_CREATE,T_REMOVE
      REAL(EB), DIMENSION(3) :: AREA,AREA_0
      LOGICAL, DIMENSION(-3:3) :: SHOW_BNDF
      LOGICAL :: SAWTOOTH,HIDDEN,PERMIT_HOLE
      END TYPE OBSTRUCTION_TYPE
C
      TYPE VENTS_TYPE
      INTEGER :: I1,I2,J1,J2,K1,K2,INDEX,IOR,IBC,
     .           HEAT_INDEX_ACTIVATE,HEAT_INDEX_DEACTIVATE,
     .           VCI,VTI,ORDINAL
      REAL(EB), DIMENSION(4) :: RGB
      REAL(EB), DIMENSION(3) :: TEXTURE
      REAL(EB) :: X1,X2,Y1,Y2,Z1,Z2,AREA,AREA_0,T_OPEN,T_CLOSE,
     .            X0,Y0,Z0,FIRE_SPREAD_RATE,TMP_OUTSIDE
      LOGICAL :: CLOSED
      CHARACTER(26) :: HEAT_ACTIVATE,HEAT_DEACTIVATE
      CHARACTER(60) :: MESH_ID
      END TYPE VENTS_TYPE
C
      TYPE LAGRANGIAN_TYPE
      REAL(EB) :: DENSITY,H_V_0,C_P,TMP_V,TMP_MELT,FTPR,MASS_PER_VOLUME,
     .            DELTAH,ADJUST_EVAPORATION,LIFETIME,DIAMETER,GAMMA,
     .            TMP_INITIAL,SIGMA,X1,X2,Y1,Y2,Z1,Z2
      CHARACTER(60) :: CLASS_NAME,SPECIES
      LOGICAL :: STATIC,WATER,FUEL,MASSLESS,TREE
      INTEGER :: N_INITIAL,SAMPLING,N_INSERT,COLOR_INDEX,SPECIES_INDEX
      REAL(EB), POINTER, DIMENSION(:) :: R_CDF,CDF,W_CDF
      INTEGER,  POINTER, DIMENSION(:) :: IL_CDF,IU_CDF
      END TYPE LAGRANGIAN_TYPE
C
      TYPE SPRINKLER_TYPE
      REAL(EB) :: RTI,TMP_ACT,K_FACTOR,C_FACTOR,
     .          OPERATING_PRESSURE,OFFSET,P_FACTOR,
     .          GAMMA,SIGMA,DPHI,DTHETA,WATER_TEMPERATURE
      REAL(EB), POINTER, DIMENSION(:,:) ::
     .          WATER_FLUX,DROPLET_VELOCITY,DROPLET_DIAMETER
      REAL(EB), POINTER, DIMENSION(:,:,:) :: RDROP,CDF_DROP,W_DROP
      INTEGER,  POINTER, DIMENSION(:,:,:) :: IL_DROP,IU_DROP
      REAL(EB), POINTER, DIMENSION(:) :: THETA,PHI
      INTEGER, POINTER, DIMENSION(:) :: NPHI,NTHETA,I_TABLE,J_TABLE
      END TYPE SPRINKLER_TYPE
C
      TYPE SPRINKLER_HEAD_TYPE
      REAL(EB) :: X,Y,Z,T,T_ACT,T_DEACT,TMP_L,TMP_L_S,DELAY
      REAL(EB), DIMENSION(4) :: DIR
      INTEGER :: ACT_CODE,INDEX,MESH,DROPLET_CLASS,I,J,K,HEAT_INDEX
      CHARACTER(30) :: LABEL,HEAT_ACTIVATE
      END TYPE SPRINKLER_HEAD_TYPE
C
      TYPE HEAT_DETECTOR_TYPE
      REAL(EB) :: X,Y,Z,RTI,TMP_ACT,TMP_L,TMP_L_S
      INTEGER :: MESH,I,J,K
      CHARACTER(30) :: LABEL
      END TYPE HEAT_DETECTOR_TYPE
C
      TYPE SMOKE_DETECTOR_TYPE
      REAL(EB):: X,Y,Z,YSMOKE,YSMOKE_IN,YSMOKE_OUT,YSMOKE_ACT
      INTEGER :: MESH,I,J,K,N_IERT_OLD
      REAL(EB):: ALPHA_E,ALPHA_C,BETA_E,BETA_C  
      REAL(EB),  POINTER,DIMENSION(:) :: YSMOK_E,TAR_CURVE
      CHARACTER(30) :: LABEL
      END TYPE SMOKE_DETECTOR_TYPE
C
      TYPE THERMOCOUPLE_TYPE
      REAL(EB) :: X,Y,Z,VALUE,DEPTH,DIAMETER,EMISSIVITY
      INTEGER  :: INDEX,IOR,IW,COUNT,K_LOW,K_HIGH,
     .            ORDINAL,MESH,I1,I2,J1,J2,K1,K2,I_DEPTH
      CHARACTER(30) :: LABEL
      END TYPE THERMOCOUPLE_TYPE
C
      END MODULE TYPES
C
C
      MODULE VARS
C
C Data structure for mesh-dependent variables
C
      USE PREC
      USE TYPES
      IMPLICIT NONE
C
      TYPE MESH_TYPE
C
      REAL(EB), POINTER, DIMENSION(:,:,:) :: 
     .         U,V,W,US,VS,WS,DDDT,D,DS,H,FVX,FVY,FVZ,RHO,RHOS,
     .         MU,TMP,Q,FRHO,KAPPA,QR,QR_W,UII,RSUM,D_VAP,
     .         AVG_DROP_DEN,AVG_DROP_TMP,AVG_DROP_RAD
      REAL(EB), POINTER, DIMENSION(:,:,:,:) :: YY,YYS,FYY
C
      REAL(EB) :: POIS_PTB,POIS_ERR
      REAL(EB), POINTER, DIMENSION(:) :: SAVE,WORK
      REAL(EB), POINTER, DIMENSION(:,:,:) :: PRHS
      REAL(EB), POINTER, DIMENSION(:,:) :: BXS,BXF,BYS,BYF,BZS,BZF,
     .         BXST,BXFT,BYST,BYFT,BZST,BZFT
      INTEGER :: LSAVE,LWORK,LBC,MBC,NBC,ITRN,JTRN,KTRN,IPS
      REAL(EB) :: P0,P0S,DP0DT,DP0DTS
C
      REAL(EB), POINTER, DIMENSION(:,:,:) :: 
     .         WORK1,WORK2,WORK3,WORK4,WORK5,WORK6,WORK7
      REAL(EB), POINTER, DIMENSION(:) :: WALL_WORK1,WALL_WORK2
      REAL(FB), POINTER, DIMENSION(:,:,:,:) :: QQ
      REAL(FB), POINTER, DIMENSION(:,:) :: PP,PPN
      INTEGER, POINTER, DIMENSION(:,:) :: IBK
      INTEGER, POINTER, DIMENSION(:,:,:) :: IBLK
C
      REAL(EB) :: DT,DTOLD,DTNEXT,DTINT
      REAL(EB) :: CFL,DIVMX,DIVMN,VN,RESMAX
      INTEGER  :: ICFL,JCFL,KCFL,IMX,JMX,KMX,IMN,JMN,KMN,
     .  I_VN,J_VN,K_VN,IRM,JRM,KRM
      LOGICAL :: NEW_TIME_STEP
C
      INTEGER :: NEDGES
      INTEGER, POINTER, DIMENSION(:,:) :: IJKE,IEA
      REAL(EB), POINTER, DIMENSION(:) :: TAU_E,OME_E
C
      INTEGER :: IBAR,JBAR,KBAR,
     .  IBM1,JBM1,KBM1,IBP1,JBP1,KBP1
      REAL(EB) :: DXI,DETA,DZETA,RDXI,RDETA,RDZETA,
     .  DXMIN,DXMAX,DYMIN,DYMAX,DZMIN,DZMAX,
     .  XS,XF,YS,YF,ZS,ZF,
     .  RDXINT,RDYINT,RDZINT,
     .  XSIP,XFIP,YSIP,YFIP,ZSIP,ZFIP,VOL
      REAL(EB), POINTER, DIMENSION(:) :: R,RC,X,Y,Z,XC,YC,ZC,HX,HY,HZ,
     .          DX,RDX,DXN,RDXN,DY,RDY,DYN,RDYN,DZ,RDZ,DZN,RDZN,
     .          CELLSI,CELLSJ,CELLSK,RREDX,RREDY,RREDZ,RRN
      REAL(FB), POINTER, DIMENSION(:) :: XPLT,YPLT,ZPLT
C
      INTEGER :: NB
      TYPE(OBSTRUCTION_TYPE), POINTER, DIMENSION(:) :: OBSTRUCTION
C
      INTEGER :: NV
      TYPE(VENTS_TYPE), POINTER, DIMENSION(:) :: VENTS
C
      INTEGER, POINTER, DIMENSION(:,:,:) :: ICA
      INTEGER, POINTER, DIMENSION(:) :: I_CELL,J_CELL,K_CELL
      INTEGER, POINTER, DIMENSION(:,:) :: IWA
      REAL(EB), POINTER, DIMENSION(:) :: CELL_MASS
      LOGICAL, POINTER, DIMENSION(:) :: SOLID
C
      INTEGER :: NWC,NEWC,NDWC,NDBC,WALL_COUNTER
      REAL(EB) :: WALLCLK
      REAL(EB), POINTER, DIMENSION(:,:) :: MASSFLUX
      REAL(EB), POINTER, DIMENSION(:,:) :: RHODW,YY_W
      REAL(EB), POINTER, DIMENSION(:)   :: XW,YW,ZW,TW,AWMPUA,
     .          AW,WMPUA,WCPUA,RAW,UW0,DUWDT,RDN,QPYR,MASS_LOSS,
     .          QRAD,EW,KW,QCONB,QCONF,AREA_ADJUST,RHO_W,TMP_W,RSUM_W,
     .          TMP_F,TMP_B,HEAT_TRANS_COEF
      REAL(EB), POINTER, DIMENSION(:) :: E_WALL, PFRONT_I, MFRONT_I
      REAL(EB), POINTER, DIMENSION(:) :: UW,UWS,CELL_VOLUME_RATIO
      INTEGER, POINTER, DIMENSION(:,:) :: IJKW,ITAUMF,
     .          INTERPOLATION_FACTOR
      INTEGER, POINTER, DIMENSION(:) :: IV,ITAUV,ITAUQ,NPPCW,
     .          CELL_PARTICLE_CLASS,OBST_INDEX
C
      TYPE(WALL_TYPE), POINTER, DIMENSION(:) :: WALL
      TYPE(OMESH_TYPE), POINTER, DIMENSION(:) :: OMESH
C
      TYPE(DROPLET_TYPE), POINTER, DIMENSION(:) :: DROPLET
      INTEGER :: NLP,NLPDIM
C
      TYPE(HUMAN_TYPE), POINTER, DIMENSION(:) :: HUMAN
      INTEGER :: N_HUMANS,N_HUMANS_DIM
C
      INTEGER :: NSF,K_LAYER_CALC_LO,K_LAYER_CALC_HI
      INTEGER, POINTER, DIMENSION(:) :: ISP1,ISP2,JSP1,JSP2,KSP1,
     .         KSP2,INDSP
      REAL(FB), POINTER, DIMENSION(:,:) :: KAP_UP,TMP_UP,TMP_LOW,Z_INT,
     .                                     RAD_UP
      LOGICAL :: LAYER_HEIGHT
C
      INTEGER, POINTER, DIMENSION(:,:) :: INC
      INTEGER :: NPATCH
C
      REAL(EB), POINTER, DIMENSION(:,:,:,:) :: UIID
      INTEGER :: RAD_CALL_COUNTER,ANGLE_INC_COUNTER
C
      REAL(EB) :: RHO_AVG,Q_UPPER,Z_F_EFF
C
      INTEGER, POINTER, DIMENSION(:,:,:) :: INTERPOLATED_MESH
C
      CHARACTER(50), POINTER, DIMENSION(:) :: STRING
      INTEGER :: N_STRINGS,N_STRINGS_MAX
C
      END TYPE MESH_TYPE
C
      TYPE (MESH_TYPE), SAVE, DIMENSION(:), ALLOCATABLE, TARGET :: MESH
C
      CHARACTER(26), DIMENSION(:), ALLOCATABLE :: MESH_NAME
      REAL(EB),DIMENSION(:,:), ALLOCATABLE :: TUSED
      INTEGER, DIMENSION(:,:), ALLOCATABLE :: 
     .      I_MIN,I_MAX,J_MIN,J_MAX,K_MIN,K_MAX,NIC
C
C
      CONTAINS
C
C
C Indicate which cells are blocked off
C
      SUBROUTINE BLKCLL(NM,I1,I2,J1,J2,K1,K2,IVAL)
C
      INTEGER NM,I1,I2,J1,J2,K1,K2,IVAL,I,J,K
      TYPE (MESH_TYPE), POINTER :: M
C
      M => MESH(NM)
C
      DO K=K1,K2
      DO J=J1,J2
      DO I=I1,I2
      SELECT CASE(IVAL)
      CASE(0) ; M%SOLID(M%ICA(I,J,K)) = .FALSE.
      CASE(1) ; M%SOLID(M%ICA(I,J,K)) = .TRUE.
      END SELECT
      ENDDO
      ENDDO
      ENDDO
C
      END SUBROUTINE BLKCLL
C
C
C Get obstacle index based on grid cell indices
C
      SUBROUTINE GET_OBST(NM,II,JJ,KK,IOR,SOLID_ONLY,N)
C
      INTEGER NN,IBX,JBX,KBX
      INTEGER, INTENT(IN)  :: NM,II,JJ,KK,IOR
      INTEGER, INTENT(OUT) :: N
      LOGICAL, INTENT(IN) :: SOLID_ONLY
      TYPE (MESH_TYPE), POINTER :: M
      TYPE (OBSTRUCTION_TYPE), POINTER :: OB
C
      M => MESH(NM)
C
      N = 0
C
      DO NN=1,M%NB
      OB=>M%OBSTRUCTION(NN)
C
      SELECT CASE(ABS(IOR))
      CASE(1)
      IBX = OB%I1
      IF (SOLID_ONLY) IBX = OB%I1+1
      IF ( II.GE.  IBX .AND. II.LE.OB%I2 .AND.
     .     JJ.GT.OB%J1 .AND. JJ.LE.OB%J2 .AND.
     .     KK.GT.OB%K1 .AND. KK.LE.OB%K2 ) THEN
         N = NN
         RETURN
         ENDIF
      CASE(2)
      JBX = OB%J1
      IF (SOLID_ONLY) JBX = OB%J1+1
      IF ( II.GT.OB%I1 .AND. II.LE.OB%I2 .AND.
     .     JJ.GE.  JBX .AND. JJ.LE.OB%J2 .AND.
     .     KK.GT.OB%K1 .AND. KK.LE.OB%K2 ) THEN
         N = NN
         RETURN
         ENDIF
      CASE(3)
      KBX = OB%K1
      IF (SOLID_ONLY) KBX = OB%K1+1
      IF ( II.GT.OB%I1 .AND. II.LE.OB%I2 .AND.
     .     JJ.GT.OB%J1 .AND. JJ.LE.OB%J2 .AND.
     .     KK.GE.  KBX .AND. KK.LE.OB%K2 ) THEN
         N = NN
         RETURN
         ENDIF
      END SELECT
C
      ENDDO
C
      END SUBROUTINE GET_OBST
C
C
      SUBROUTINE RE_ALLOCATE_DROPLETS(CODE,NM,NOM)
C
      TYPE (DROPLET_TYPE), ALLOCATABLE, DIMENSION(:) :: DUMMY
      INTEGER IZERO
      INTEGER, INTENT(IN) :: CODE,NM,NOM
      TYPE (MESH_TYPE), POINTER :: M
      TYPE(OMESH_TYPE), POINTER :: M2
C
      SELECT CASE(CODE)
C
      CASE(1)
C
      M=>MESH(NM)
      ALLOCATE(DUMMY(1:M%NLPDIM),STAT=IZERO)
      DUMMY = M%DROPLET
C
      DEALLOCATE(M%DROPLET)
      ALLOCATE(M%DROPLET(M%NLPDIM+1000),STAT=IZERO)
      M%DROPLET(1:M%NLPDIM) = DUMMY(1:M%NLPDIM)
      M%NLPDIM = M%NLPDIM+1000
C
      CASE(2)
C
      M2=>MESH(NM)%OMESH(NOM)
      ALLOCATE(DUMMY(1:M2%N_DROP_ORPHANS_DIM),STAT=IZERO)
      DUMMY = M2%DROPLET
C
      DEALLOCATE(M2%DROPLET)
      ALLOCATE(M2%DROPLET(M2%N_DROP_ORPHANS_DIM+1000),STAT=IZERO)
      M2%DROPLET(1:M2%N_DROP_ORPHANS_DIM) =
     .     DUMMY(1:M2%N_DROP_ORPHANS_DIM)
      M2%N_DROP_ORPHANS_DIM = M2%N_DROP_ORPHANS_DIM+1000
C
      END SELECT
C
      DEALLOCATE(DUMMY)
C
      END SUBROUTINE RE_ALLOCATE_DROPLETS
C
C
      SUBROUTINE RE_ALLOCATE_STRINGS(NM)
C
      CHARACTER(50), ALLOCATABLE, DIMENSION(:) :: DUMMY
      INTEGER IZERO
      INTEGER, INTENT(IN) :: NM
      TYPE (MESH_TYPE), POINTER :: M
C
      M=>MESH(NM)
      ALLOCATE(DUMMY(1:M%N_STRINGS),STAT=IZERO)
      DUMMY = M%STRING
C
      DEALLOCATE(M%STRING)
      ALLOCATE(M%STRING(M%N_STRINGS_MAX+100),STAT=IZERO)
      M%STRING(1:M%N_STRINGS) = DUMMY(1:M%N_STRINGS)
      M%N_STRINGS_MAX = M%N_STRINGS_MAX+100
C
      DEALLOCATE(DUMMY)
C
      END SUBROUTINE RE_ALLOCATE_STRINGS
C
C
      END MODULE VARS
C
C
C
      MODULE PACKER
C
      USE PREC
      USE VARS
      IMPLICIT NONE
C
      REAL(EB), POINTER, DIMENSION(:,:,:) :: 
     .         U,V,W,US,VS,WS,DDDT,D,DS,H,FVX,FVY,FVZ,RHO,RHOS,
     .         MU,TMP,Q,FRHO,KAPPA,QR,QR_W,UII,RSUM,D_VAP,
     .         AVG_DROP_DEN,AVG_DROP_TMP,AVG_DROP_RAD
      REAL(EB), POINTER, DIMENSION(:,:,:,:) :: YY,YYS,FYY
C
      REAL(EB), POINTER :: POIS_PTB,POIS_ERR
      REAL(EB), POINTER, DIMENSION(:) :: SAVE,WORK
      REAL(EB), POINTER, DIMENSION(:,:,:) :: PRHS
      REAL(EB), POINTER, DIMENSION(:,:) :: BXS,BXF,BYS,BYF,BZS,BZF,
     .         BXST,BXFT,BYST,BYFT,BZST,BZFT
      INTEGER, POINTER :: LSAVE,LWORK,LBC,MBC,NBC,ITRN,JTRN,KTRN,IPS
      REAL(EB), POINTER :: P0,P0S,DP0DT,DP0DTS
C
      REAL(EB), POINTER, DIMENSION(:,:,:) :: 
     .         WORK1,WORK2,WORK3,WORK4,WORK5,WORK6,WORK7
      REAL(EB), POINTER, DIMENSION(:) :: WALL_WORK1,WALL_WORK2
      REAL(FB), POINTER, DIMENSION(:,:,:,:) :: QQ
      REAL(FB), POINTER, DIMENSION(:,:) :: PP,PPN
      INTEGER, POINTER, DIMENSION(:,:) :: IBK
      INTEGER, POINTER, DIMENSION(:,:,:) :: IBLK
C
      REAL(EB), POINTER :: DT,DTOLD,DTNEXT,DTINT
      REAL(EB), POINTER :: CFL,DIVMX,DIVMN,VN,RESMAX
      INTEGER, POINTER :: ICFL,JCFL,KCFL,IMX,JMX,KMX,IMN,JMN,KMN,
     .  I_VN,J_VN,K_VN,IRM,JRM,KRM
      LOGICAL, POINTER :: NEW_TIME_STEP
C
      INTEGER, POINTER :: NEDGES
      INTEGER, POINTER, DIMENSION(:,:) :: IJKE,IEA
      REAL(EB), POINTER, DIMENSION(:) :: TAU_E,OME_E
C
      INTEGER, POINTER :: IBAR,JBAR,KBAR,
     .  IBM1,JBM1,KBM1,IBP1,JBP1,KBP1
      REAL(EB), POINTER :: DXI,DETA,DZETA,RDXI,RDETA,RDZETA,
     .  DXMIN,DXMAX,DYMIN,DYMAX,DZMIN,DZMAX,
     .  XS,XF,YS,YF,ZS,ZF,
     .  RDXINT,RDYINT,RDZINT,
     .  XSIP,XFIP,YSIP,YFIP,ZSIP,ZFIP,VOL
      REAL(EB), POINTER, DIMENSION(:) :: R,RC,X,Y,Z,XC,YC,ZC,HX,HY,HZ,
     .          DX,RDX,DXN,RDXN,DY,RDY,DYN,RDYN,DZ,RDZ,DZN,RDZN,
     .          CELLSI,CELLSJ,CELLSK,RREDX,RREDY,RREDZ,RRN
      REAL(FB), POINTER, DIMENSION(:) :: XPLT,YPLT,ZPLT
C
      INTEGER, POINTER :: NB
      TYPE(OBSTRUCTION_TYPE), POINTER, DIMENSION(:) :: OBSTRUCTION
C
      INTEGER, POINTER :: NV
      TYPE(VENTS_TYPE), POINTER, DIMENSION(:) :: VENTS
C
      INTEGER, POINTER, DIMENSION(:,:,:) :: ICA
      INTEGER, POINTER, DIMENSION(:) :: I_CELL,J_CELL,K_CELL
      INTEGER, POINTER, DIMENSION(:,:) :: IWA
      REAL(EB), POINTER, DIMENSION(:) :: CELL_MASS
      LOGICAL, POINTER, DIMENSION(:) :: SOLID
C
      INTEGER, POINTER :: NWC,NEWC,NDWC,NDBC,WALL_COUNTER
      REAL(EB),POINTER :: WALLCLK
      REAL(EB), POINTER, DIMENSION(:,:) :: MASSFLUX
      REAL(EB), POINTER, DIMENSION(:,:) :: RHODW,YY_W
      REAL(EB), POINTER, DIMENSION(:)   :: XW,YW,ZW,TW,AWMPUA,
     .          AW,WMPUA,WCPUA,RAW,UW0,DUWDT,RDN,QPYR,MASS_LOSS,
     .          QRAD,EW,KW,QCONB,QCONF,AREA_ADJUST,RHO_W,TMP_W,RSUM_W,
     .          TMP_F,TMP_B,HEAT_TRANS_COEF,TMP_O
      REAL(EB), POINTER, DIMENSION(:) :: E_WALL, PFRONT_I, MFRONT_I
      REAL(EB), POINTER, DIMENSION(:) :: UW,UWS,CELL_VOLUME_RATIO
      INTEGER, POINTER, DIMENSION(:,:) :: IJKW,ITAUMF,
     .         INTERPOLATION_FACTOR
      INTEGER, POINTER, DIMENSION(:) :: IV,ITAUV,ITAUQ,NPPCW,
     .         CELL_PARTICLE_CLASS,OBST_INDEX
C
      TYPE(WALL_TYPE), POINTER, DIMENSION(:) :: WALL
      TYPE(OMESH_TYPE), POINTER, DIMENSION(:) :: OMESH
C
      TYPE(DROPLET_TYPE), POINTER, DIMENSION(:) :: DROPLET
      INTEGER, POINTER :: NLP,NLPDIM
C
      TYPE(HUMAN_TYPE), POINTER, DIMENSION(:) :: HUMAN
      INTEGER, POINTER :: N_HUMANS,N_HUMANS_DIM
C
      INTEGER, POINTER :: NSF,K_LAYER_CALC_LO,K_LAYER_CALC_HI
      INTEGER, POINTER, DIMENSION(:) :: ISP1,ISP2,JSP1,JSP2,KSP1,
     .         KSP2,INDSP
      REAL(FB), POINTER, DIMENSION(:,:) :: KAP_UP,TMP_UP,TMP_LOW,Z_INT,
     .                                     RAD_UP
      LOGICAL, POINTER :: LAYER_HEIGHT
C
      INTEGER, POINTER, DIMENSION(:,:) :: INC
      INTEGER, POINTER :: NPATCH
C
      REAL(EB), POINTER, DIMENSION(:,:,:,:) :: UIID
      INTEGER,  POINTER :: RAD_CALL_COUNTER,ANGLE_INC_COUNTER
C
      REAL(EB), POINTER :: RHO_AVG,Q_UPPER,Z_F_EFF
C
      INTEGER, POINTER, DIMENSION(:,:,:) :: INTERPOLATED_MESH
C
      CHARACTER(50), POINTER, DIMENSION(:) :: STRING
      INTEGER, POINTER :: N_STRINGS,N_STRINGS_MAX
C
      CONTAINS
C
C
      SUBROUTINE UNPACK_VAR(NM)
C
      INTEGER, INTENT(IN) ::  NM
C
      TYPE (MESH_TYPE), POINTER :: M
C
      M  => MESH(NM)
C
      U=>M%U ; V=>M%V ; W=>M%W ; US=>M%US ; VS=>M%VS ; WS=>M%WS
      DDDT=>M%DDDT ; D=>M%D ; DS=>M%DS ; H=>M%H 
      FVX=>M%FVX ; FVY=>M%FVY ; FVZ=>M%FVZ  
      RHO=>M%RHO ; RHOS=>M%RHOS ; TMP=>M%TMP
      MU=>M%MU ; Q=>M%Q ; FRHO=>M%FRHO ; KAPPA=>M%KAPPA 
      QR=>M%QR ; QR_W=>M%QR_W ; UII=>M%UII 
      AVG_DROP_DEN=>M%AVG_DROP_DEN
      AVG_DROP_TMP=>M%AVG_DROP_TMP
      AVG_DROP_RAD=>M%AVG_DROP_RAD
      RSUM=>M%RSUM ; D_VAP=>M%D_VAP
      YY=>M%YY ; YYS=>M%YYS ; FYY=>M%FYY
C
      POIS_PTB=>M%POIS_PTB ; POIS_ERR=>M%POIS_ERR
      SAVE=>M%SAVE ; WORK=>M%WORK
      LSAVE=>M%LSAVE ; LWORK=>M%LWORK
      PRHS=>M%PRHS
      BXS=>M%BXS ; BXF=>M%BXF 
      BYS=>M%BYS ; BYF=>M%BYF 
      BZS=>M%BZS ; BZF=>M%BZF 
      BXST=>M%BXST ; BXFT=>M%BXFT 
      BYST=>M%BYST ; BYFT=>M%BYFT 
      BZST=>M%BZST ; BZFT=>M%BZFT 
      LBC=>M%LBC ; MBC=>M%MBC ; NBC=>M%NBC 
      ITRN=>M%ITRN ; JTRN=>M%JTRN ; KTRN=>M%KTRN ; IPS=>M%IPS
      P0=>M%P0 ; P0S=>M%P0S ; DP0DT=>M%DP0DT ; DP0DTS=>M%DP0DTS
C
      WORK1=>M%WORK1 ; WORK2=>M%WORK2 ; WORK3=>M%WORK3 
      WORK4=>M%WORK4 ; WORK5=>M%WORK5 ; WORK6=>M%WORK6 
      WORK7=>M%WORK7
      WALL_WORK1=>M%WALL_WORK1 ; WALL_WORK2=>M%WALL_WORK2
      QQ=>M%QQ
      PP=>M%PP ; PPN=>M%PPN
      IBK=>M%IBK
      IBLK=>M%IBLK
C
      DT=>M%DT ; DTOLD=>M%DTOLD ; DTNEXT=>M%DTNEXT ; DTINT=>M%DTINT
      CFL=>M%CFL ; DIVMX=>M%DIVMX ; VN=>M%VN ; RESMAX=>M%RESMAX
      DIVMN=>M%DIVMN
      ICFL=>M%ICFL ; JCFL=>M%JCFL ; KCFL=>M%KCFL 
      IMX=>M%IMX ; JMX=>M%JMX ; KMX=>M%KMX
      IMN=>M%IMN ; JMN=>M%JMN ; KMN=>M%KMN
      IRM=>M%IRM ; JRM=>M%JRM ; KRM=>M%KRM
      I_VN=>M%I_VN ; J_VN=>M%J_VN ; K_VN=>M%K_VN
      NEW_TIME_STEP=>M%NEW_TIME_STEP
C
      NEDGES=>M%NEDGES
      IJKE=>M%IJKE ; IEA=>M%IEA
      TAU_E=>M%TAU_E ; OME_E=>M%OME_E
C
      IBAR=>M%IBAR ; JBAR=>M%JBAR ; KBAR=>M%KBAR 
      IBM1=>M%IBM1 ; JBM1=>M%JBM1 ; KBM1=>M%KBM1 
      IBP1=>M%IBP1 ; JBP1=>M%JBP1 ; KBP1=>M%KBP1 
      DXI=>M%DXI ; DETA=>M%DETA ; DZETA=>M%DZETA 
      RDXI=>M%RDXI ; RDETA=>M%RDETA ; RDZETA=>M%RDZETA 
      DXMIN=>M%DXMIN ; DXMAX=>M%DXMAX 
      DYMIN=>M%DYMIN ; DYMAX=>M%DYMAX 
      DZMIN=>M%DZMIN ; DZMAX=>M%DZMAX 
      XS=>M%XS ; XF=>M%XF 
      YS=>M%YS ; YF=>M%YF 
      ZS=>M%ZS ; ZF=>M%ZF 
      RDXINT=>M%RDXINT ; RDYINT=>M%RDYINT ; RDZINT=>M%RDZINT 
      XSIP=>M%XSIP ; XFIP=>M%XFIP
      YSIP=>M%YSIP ; YFIP=>M%YFIP
      ZSIP=>M%ZSIP ; ZFIP=>M%ZFIP ; VOL=>M%VOL
      R=>M%R ; RC=>M%RC ; X=>M%X ; Y=>M%Y ; Z=>M%Z 
      XC=>M%XC ; YC=>M%YC ; ZC=>M%ZC
      HX=>M%HX ; HY=>M%HY ; HZ=>M%HZ
      DX=>M%DX ; DY=>M%DY ; DZ=>M%DZ 
      DXN=>M%DXN ; DYN=>M%DYN ; DZN=>M%DZN
      RDX=>M%RDX ; RDY=>M%RDY ; RDZ=>M%RDZ 
      RDXN=>M%RDXN ; RDYN=>M%RDYN ; RDZN=>M%RDZN
      CELLSI=>M%CELLSI ; CELLSJ=>M%CELLSJ ; CELLSK=>M%CELLSK 
      RREDX=>M%RREDX ; RREDY=>M%RREDY ; RREDZ=>M%RREDZ 
      RRN=>M%RRN
      XPLT=>M%XPLT ; YPLT=>M%YPLT ; ZPLT=>M%ZPLT 
C
      NB=>M%NB 
      OBSTRUCTION=>M%OBSTRUCTION
      NV=>M%NV 
      VENTS=>M%VENTS
C
      ICA=>M%ICA 
      I_CELL=>M%I_CELL ; J_CELL=>M%J_CELL; K_CELL=>M%K_CELL
      IWA=>M%IWA 
      CELL_MASS=>M%CELL_MASS
      SOLID=>M%SOLID 
C
      NWC=>M%NWC ; NEWC=>M%NEWC ; NDWC=>M%NDWC
      NDBC=>M%NDBC ; WALL_COUNTER=>M%WALL_COUNTER ; WALLCLK=>M%WALLCLK
      MASSFLUX=>M%MASSFLUX
      RHODW=>M%RHODW ; YY_W=>M%YY_W
      TMP_F=>M%TMP_F ; TMP_B=>M%TMP_B 
      HEAT_TRANS_COEF=>M%HEAT_TRANS_COEF
      XW=>M%XW ; YW=>M%YW ; ZW=>M%ZW ; TW=>M%TW ; AWMPUA=>M%AWMPUA 
      AW=>M%AW ; WMPUA=>M%WMPUA ; WCPUA=>M%WCPUA ; RAW=>M%RAW
      UW0=>M%UW0 ; DUWDT=>M%DUWDT ; RDN=>M%RDN ; QPYR=>M%QPYR
      TMP_O=>M%QPYR
      MASS_LOSS=>M%MASS_LOSS 
      QRAD=>M%QRAD ; EW=>M%EW ; KW=>M%KW 
      QCONB=>M%QCONB ; QCONF=>M%QCONF ; AREA_ADJUST=>M%AREA_ADJUST
      RHO_W=>M%RHO_W ; TMP_W=>M%TMP_W ; RSUM_W=>M%RSUM_W
      E_WALL=>M%E_WALL
      PFRONT_I=>M%PFRONT_I ; MFRONT_I=>M%MFRONT_I
      UW=>M%UW ; UWS=>M%UWS ; CELL_PARTICLE_CLASS=>M%CELL_PARTICLE_CLASS
      OBST_INDEX=>M%OBST_INDEX
      IJKW=>M%IJKW ; ITAUMF=>M%ITAUMF 
      INTERPOLATION_FACTOR=>M%INTERPOLATION_FACTOR
      CELL_VOLUME_RATIO=>M%CELL_VOLUME_RATIO
      IV=>M%IV ; ITAUV=>M%ITAUV ; ITAUQ=>M%ITAUQ ; NPPCW=>M%NPPCW
C
      WALL=>M%WALL
C
      OMESH=>M%OMESH
C
      DROPLET =>M%DROPLET  ; NLP=>M%NLP ; NLPDIM=>M%NLPDIM
      HUMAN =>M%HUMAN  ; N_HUMANS=>M%N_HUMANS  
      N_HUMANS_DIM=>M%N_HUMANS_DIM
C
      NSF=>M%NSF ; K_LAYER_CALC_LO=>M%K_LAYER_CALC_LO  
                   K_LAYER_CALC_HI=>M%K_LAYER_CALC_HI
      ISP1=>M%ISP1 ; ISP2=>M%ISP2  
      JSP1=>M%JSP1 ; JSP2=>M%JSP2  
      KSP1=>M%KSP1 ; KSP2=>M%KSP2
      INDSP=>M%INDSP 
      KAP_UP=>M%KAP_UP ; TMP_UP=>M%TMP_UP ; TMP_LOW=>M%TMP_LOW
      Z_INT=>M%Z_INT ; LAYER_HEIGHT=>M%LAYER_HEIGHT ; RAD_UP=>M%RAD_UP
C
      INC=>M%INC ; NPATCH=>M%NPATCH
C
      UIID=>M%UIID 
      RAD_CALL_COUNTER=>M%RAD_CALL_COUNTER
      ANGLE_INC_COUNTER=>M%ANGLE_INC_COUNTER
C 
      RHO_AVG=>M%RHO_AVG ; Q_UPPER=>M%Q_UPPER ; Z_F_EFF=>M%Z_F_EFF
C
      INTERPOLATED_MESH => M%INTERPOLATED_MESH
C
      STRING=>M%STRING ; N_STRINGS=>M%N_STRINGS 
      N_STRINGS_MAX=>M%N_STRINGS_MAX
C
      END SUBROUTINE UNPACK_VAR
C
C
      END MODULE PACKER
C
C
C
      MODULE CONS
C
C Module containing global parameters and routines
C
      USE PREC
      USE TYPES
      IMPLICIT NONE
C
      INTEGER :: NMESHES=1
      INTEGER, PARAMETER :: N_TIMERS=15
C     TIMO_EVAC      INTEGER, PARAMETER :: N_TIMERS=11
C
      CHARACTER(60) :: TITLE,DATABASE,DATABASE_DIRECTORY,RENDER_FILE,
     .                 INPUT_FILE='null',TEXTURE_DIRECTORY
      CHARACTER(26) :: SURFNAME(0:1000),RAMPID(1000),RAMPTYPE(1000)
      REAL(EB), ALLOCATABLE, DIMENSION(:,:) :: TT,FF,FF3
      INTEGER, ALLOCATABLE, DIMENSION(:)   :: NTT
C
C Species Arrays
C
      REAL(EB) :: CHI_R,MASS_EXTINCTION_COEFFICIENT,VISIBILITY_FACTOR,
     .            EC_LL
      REAL(EB), ALLOCATABLE, DIMENSION(:,:) :: MU_SPEC,K_SPEC,D_SPEC,
     .          CP,HH,RCP
      REAL(EB), ALLOCATABLE, DIMENSION(:) :: MWN,YY0,
     .          NUN,RCON,MPUE,EPUM,RCON_STATE
      CHARACTER(26), ALLOCATABLE, DIMENSION(:) :: SPECIES_ID
C
C Miscellaneous logical constants
C
      LOGICAL :: LES,DNS,ISOTHERMAL,SEALED,PAPERMODEL,RADIATION,
     .        INCOMPRESSIBLE,CYLINDRICAL,NOISE,MIXTURE_FRACTION,
     .        BAROCLINIC,PREDICTOR,CORRECTOR,
     .        APPEND,AUTOMATIC_Z,DROPLET_FILE,RESTART,
     .        SUPPRESSION,ACCUMULATE_WATER,WRITE_XYZ,
     .        CHECK_POISSON,TWO_D,SET_UP,SMOKE3D,
     .        WATER_EVAPORATION,FUEL_EVAPORATION,
     .        EVAPORATION,DEBUG,SYNCHRONIZE,TIMING,
     .        FLUSH_FILE_BUFFERS
      LOGICAL, ALLOCATABLE, DIMENSION(:) :: SYNC_TIME_STEP
C
C Global EVACuation parameters
C
      LOGICAL, ALLOCATABLE, DIMENSION(:) :: EVACUATION_ONLY, 
     .                                      EVACUATION_GRID
      REAL(EB) :: EVAC_DT_FLOWFIELD,EVAC_DT_STEADY_STATE
      INTEGER :: EVAC_PRESSURE_ITERATIONS,EVAC_TIME_ITERATIONS
C
C Background pressure values
C
      REAL(EB) :: P0_MAX
C
C Miscellaneous real constants
C
      REAL(EB) :: TWFIN,RF,
     .  CPOPR,RSC,RPR,TMPA,TMPA4,TMPM,TMPO,RHOA,PINF,GRAV,R0,R1,
     .  CP_GAMMA,GAMMA,U0,V0,W0,H0,GVEC(3),CSMAG,
     .  DT0DZ,ONTH,THFO,ONSI,HCH,HCV,TEX_ORI(3),
     .  SIGMA,TWTH,FOTH,KAPPA0,C_FORCED,
     .  CHARACTERISTIC_VELOCITY,TMP_GAUGE,
     .  PI,RPI,RFPI,TWOPI,PIO2,LEAK_AREA,HRRPUA_SHEET,PR,SC
C
C Ramping parameters
C
      INTEGER :: IRAMPG,IRAMPD,NRAMP
      REAL(EB) :: DTRAMP,RDTRAMP
C
C Miscellaneous integer constants
C
      INTEGER :: ICYC,COMBUSTION_MODEL,WALL_INCREMENT,
     .           NFRAMES,MAXIMUM_DROPLETS
C
C Clocks
C
      REAL(EB), ALLOCATABLE, DIMENSION(:) :: PINCLK,SPINCLK,
     .         PARCLK,CORCLK,SFCLK,PLTCLK,BFCLK,ISOCLK
      REAL(EB) :: MINTCLK,TCCLK,SPRKCLK,HEATCLK,HRRCLK,SMOKECLK,
     .         EVACCLK
      REAL(EB) :: DTSF,DTBF,DTTC,WPLT,WPAR,DT_SPRK,DT_HEAT,DT_SMOKE,
     .            DTCORE,DTPAR,DTSPAR,DTIF,DTHRR,DTMINT
C
C Logical units
C
      INTEGER :: LUPF,LUSF,LUBF,LU95
      INTEGER, PARAMETER :: LU0=0,LU2=2,LU4=4,LU5=5,LU6=6,
     .  LU11=11,LU12=12,LU13=13,LU14=14,LU15=15,LU16=16,LU18=18,
     .  LU19=19,LU80=80,LU90=90,LU91=91,LU111=111,LU121_EVAC=121
C
C Miscellaneous character strings
C
      REAL(FB) :: VERSION
      CHARACTER(40) :: CHID
      CHARACTER(20) :: COMPILE_DATE
C
C Particle constants
C
      INTEGER :: IPART,NPPS
C
C Mixture Fraction arrays
C
      INTEGER :: NSPEC,IOXYGEN,IFUEL,IWATER,ICO2
      REAL(EB) :: RSUM0,EPUMO2,DELTAH_FUEL,BOF,XNO,XNF,E_GAS,
     .  TMP_CRIT,TMP_LOWER,NU_H2,Z_CONSTANT,
     .  Z_F,MW_O2,MW_FUEL,MW_H2,NU_O2,NU_FUEL,NU_SOOT,NU_CO,
     .  Y_O2_INFTY,Y_N2_INFTY,Y_F_INLET,MW_CO2,MW_H2O,MW_N2,NU_CO2,
     .  NU_H2O,NU_N2,CO_YIELD,SOOT_YIELD,H2_YIELD,MW_CO,RHO_SOOT,
     .  Y_O2_LL,FUEL_N2,MW_C
      REAL(EB), ALLOCATABLE, DIMENSION(:) :: MW_AVG,RSUM_MF
      REAL(EB), ALLOCATABLE, DIMENSION(:,:) :: Y_STATE
C
C Boundary condition arrays
C
      INTEGER :: NBT,IBCDEF,MIRROR_INDEX,OPEN_INDEX,INTERPOLATED_INDEX,
     .           NWP_MAX
      REAL(EB), ALLOCATABLE, DIMENSION(:) :: BCV,TMP_I,A_SOLID,
     .          TMP_P,TMP_P0,XKS,C_PV,VELS,CDR,IDC,MASSFLUXS_MAX,
     .          DXI_W,PLES,Z0S,HEATFLUX,POROS,DENSITY_S,DENSITY_F,VFLUX,
     .          TAUV,TAUQ,TIGNS,SURFACE_DENSITY_S,E_WALL_S,H_V,ECOEF,
     .          TEX_WIDTH,TEX_HEIGHT, E_SOLID, RHO_CHAR, RHO_MOIS,
     .          C_PC,XKS_C,H_M,WALL_THICKNESS,QEXT,TMP_VOID,TMP_E
C
      REAL(EB), ALLOCATABLE, DIMENSION(:,:) :: MASSFRACS,MASSFLUXS,
     .          TAUMF,VEL_TS,SURF_RGB,ADJUST_BURN_RATE
      INTEGER, ALLOCATABLE, DIMENSION(:) :: MHC,PCI,IPROF,NPPCS,
     .          IBACK,MMT,SURF_TYPE,NWP,SURF_PARTICLE_CLASS
      LOGICAL, ALLOCATABLE, DIMENSION(:) :: LEAKY,BURNAWAY
      CHARACTER(20), ALLOCATABLE, DIMENSION(:) :: PYROLYSIS_MODEL
      CHARACTER(20), ALLOCATABLE, DIMENSION(:) :: SURF_GEOM
      CHARACTER(60), ALLOCATABLE, DIMENSION(:) :: TEX_MAP
      INTEGER, ALLOCATABLE, DIMENSION(:,:) :: PBC
C
C Thermally-thick boundary calculation arrays
C
      REAL(EB), ALLOCATABLE, DIMENSION(:,:) :: RDX_W,RDXN_W,X_S
      REAL(EB), ALLOCATABLE, DIMENSION(:)   :: DXF,DXB,DX_W,
     .                                         AAS,BBS,CCS,DDS
      REAL(EB), ALLOCATABLE, DIMENSION(:)   :: RHO_M, RHO_S,
     .   DRHOMDT, DRHOWDT,K_S, RHOCBAR, C_S, D_S,C_P_V,C_P_C,K_S_C
C
C Particle Class Properties
C
      INTEGER :: NPC
C
      TYPE (LAGRANGIAN_TYPE), DIMENSION(:), ALLOCATABLE, TARGET :: 
     .   LAGRANGIAN
C
C Sprinkler Variables
C
      CHARACTER(40), ALLOCATABLE, DIMENSION(:) :: SPRK_MAKE
      REAL(EB) :: PRESSURE,PIPE_PRESSURE,T_ACT_FIRST,SYSTEM_DELAY,
     .            DROP_VERTICAL_VELOCITY,DROP_HORIZONTAL_VELOCITY
      INTEGER :: NSPR,ISPDIAG,NST,N_TE
      INTEGER, PARAMETER :: NDC=1000
      LOGICAL :: POROUS_FLOOR
      INTEGER :: NSTRATA
C
      TYPE (SPRINKLER_TYPE), DIMENSION(:), ALLOCATABLE, TARGET :: 
     .   SPRINKLER
C
      TYPE (SPRINKLER_HEAD_TYPE), DIMENSION(:), ALLOCATABLE, TARGET :: 
     .   SPRINKLER_HEAD
C
C Tree Arrays
C
      INTEGER :: N_TREES
      REAL(EB), ALLOCATABLE, DIMENSION(:) :: CANOPY_W,CANOPY_B_H,
     .          TREE_H,X_TREE,Y_TREE,Z_TREE
      INTEGER, ALLOCATABLE, DIMENSION(:) :: TREE_PARTICLE_CLASS,
     .          TREE_MESH
C
C Heat Detector arrays and constants
C
      INTEGER NHD
C
      TYPE (HEAT_DETECTOR_TYPE), DIMENSION(:), ALLOCATABLE, TARGET :: 
     .   HEAT_DETECTOR
C
C Smoke Detector arrays and constants
C
      INTEGER NSD 
C
      TYPE (SMOKE_DETECTOR_TYPE), DIMENSION(:), ALLOCATABLE, TARGET ::
     .   SMOKE_DETECTOR
C
C Initial value arrays
C
      INTEGER NIB
      REAL(EB), ALLOCATABLE, DIMENSION(:) :: INIT_VALUE,XB1,XB2,
     .                                       YB1,YB2,ZB1,ZB2
      INTEGER, ALLOCATABLE, DIMENSION(:) :: INIT_INDEX
C
C Output quantity arrays
C
      INTEGER, PARAMETER :: NDATA=200
      CHARACTER(30), ALLOCATABLE, DIMENSION(:) :: CDATA,UDATA,SDATA
      INTEGER :: IPLOT3D(5)
      INTEGER, ALLOCATABLE, DIMENSION(:) :: IDATA
      LOGICAL, ALLOCATABLE, DIMENSION(:,:) :: LDATA
C
      INTEGER :: NBF,NIF
      INTEGER, ALLOCATABLE, DIMENSION(:) :: 
     .         INDBF,INDIF,INDIF2,REDUCETRIANGLES
      REAL(FB), ALLOCATABLE, DIMENSION(:,:) :: ISOLEVEL
      INTEGER, ALLOCATABLE, DIMENSION(:) :: NLEVELS
      REAL(EB),ALLOCATABLE, DIMENSION(:) :: HRR,RHRR,CHRR,FHRR,MLR,
     .  HRR_SUM,RHRR_SUM,CHRR_SUM,FHRR_SUM,MLR_SUM,HRR_COUNT
      REAL(EB),ALLOCATABLE, DIMENSION(:,:) :: MINT,MINT_SUM
      REAL(EB),ALLOCATABLE, DIMENSION(:) :: MINT_COUNT
      CHARACTER(30) QUANTITIES(5)
C
C Thermocouple arrays
C
      INTEGER NTC
C
      TYPE (THERMOCOUPLE_TYPE), DIMENSION(:), ALLOCATABLE, TARGET ::
     .   THERMOCOUPLE
C
C Clipping values
C
      REAL(EB) TMPMIN,TMPMAX,YYMIN(20),YYMAX(20),RHOMIN,RHOMAX
C
C Variable time function for heat release
C
      REAL(EB), ALLOCATABLE, DIMENSION(:,:) :: FF2,FF2G
C
C Timings
C
      REAL(EB) TNOW
      INTEGER, ALLOCATABLE, DIMENSION(:) :: NTCYC,NCYC
      REAL(EB), ALLOCATABLE, DIMENSION(:) :: T_PER_STEP,T_ACCUM
C
C
C
      CONTAINS
C
C
C SECOND returns the CPU time in seconds.
C
      REAL(EB) FUNCTION SECOND()
      REAL(FB) CPUTIME
      CALL CPU_TIME(CPUTIME)
      SECOND = CPUTIME
      END FUNCTION SECOND
C
C
C SHUTDOWN stops the code gracefully
C
      SUBROUTINE SHUTDOWN(MESSAGE)
      CHARACTER(*) MESSAGE
C
      WRITE(LU0,'(/A)') TRIM(MESSAGE)
      STOP
C
      END SUBROUTINE SHUTDOWN
C
C
C FLUSH_BUFFER flushes the buffer for the named logical unit.
C
      SUBROUTINE FLUSH_BUFFER(UNIT)
      INTEGER, INTENT(IN) :: UNIT
      IF (FLUSH_FILE_BUFFERS) CALL FLUSH(UNIT)
      END SUBROUTINE FLUSH_BUFFER
C
C
C Interpolation function
C
      REAL(EB) FUNCTION AFILL(A111,A211,A121,A221,A112,A212,A122,A222,
     .                       P,R,S)
C
      REAL(EB) A111,A211,A121,A221,A112,A212,A122,A222,P,R,S,PP,RR,SS
C
      PP = 1.-P
      RR = 1.-R
      SS = 1.-S
      AFILL = ((PP*A111+P*A211)*RR+(PP*A121+P*A221)*R)*SS+
     .        ((PP*A112+P*A212)*RR+(PP*A122+P*A222)*R)*S
C
      END FUNCTION AFILL
C
C
C Calculate the value of polynomial function.
C
      REAL(EB) FUNCTION POLYVAL(N,TEMP,COEF)
C
      INTEGER N,I
      REAL(EB) TEMP, COEF(N), VAL
C
      VAL = 0.0
      DO I=1,N
         VAL  = VAL  + COEF(I)*TEMP**(I-1)
      ENDDO
      POLYVAL = VAL
      END FUNCTION POLYVAL
C
C
C Variable ramp up time for heat release rate
C
      REAL(EB) FUNCTION FQ(T,ITAU)
C
      REAL(EB) T,TAU
      INTEGER ITAU,NR
C
      IF (T.LT.0.) THEN
         FQ = 0.
         RETURN
         ENDIF
C
      IF (ITAU.EQ.999) THEN
         FQ = 1.
         RETURN
         ENDIF
C
      IF (ITAU.GE.0) THEN
         TAU = TAUQ(ITAU)
         IF (TAU.GT.0.) FQ = TANH(T/TAU)
         IF (TAU.LT.0.) FQ = MIN( (T/TAU)**2 , 1.0_EB )
         ENDIF
C
      IF (ITAU.LT.0) THEN
         NR = ABS(ITAU)
         FQ = FF2(NINT(T*RDTRAMP)+1,NR)
         ENDIF
C
      END FUNCTION FQ
C
C
C Variable ramp up time for vent flows
C
      REAL(EB) FUNCTION FV(T,ITAU)
C
      REAL(EB) T,TAU
      INTEGER ITAU,NR
C
      IF (T.LT.0.) THEN
         FV = 0.
         RETURN
         ENDIF
C
      IF (ITAU.EQ.999) THEN
         FV = 1.
         RETURN
         ENDIF
C
      IF (ITAU.GE.0) THEN
         TAU = TAUV(ITAU)
         IF (TAU.GT.0.) FV = TANH(T/TAU)
         IF (TAU.LT.0.) FV = MIN( (T/TAU)**2 , 1.0_EB )
         ENDIF
C
      IF (ITAU.LT.0) THEN
         NR = ABS(ITAU)
         FV = FF2(NINT(T*RDTRAMP)+1,NR)
         ENDIF
C
      END FUNCTION FV
C
C
C Variable ramp up time for species concentration
C
      REAL(EB) FUNCTION FZ(T,ITAU,N)
C
      IMPLICIT NONE
      REAL(EB) T,TAU
      INTEGER ITAU,NR,N
C
      IF (T.LT.0.) THEN
         FZ = 0.
         RETURN
         ENDIF
C
      IF (ITAU.EQ.999) THEN
         FZ = 1.
         RETURN
         ENDIF
C
      SELECT CASE(ITAU)
      CASE(0:)
         TAU = TAUMF(ITAU,N)
         IF (TAU.GT.0.) FZ = TANH(T/TAU)
         IF (TAU.LT.0.) FZ = MIN( (T/TAU)**2 , 1.0_EB )
      CASE(:-1)
         NR = ABS(ITAU)
         FZ = FF2(NINT(T*RDTRAMP)+1,NR)
      END SELECT
C
      END FUNCTION FZ
C
C
C Variable ramp up for gravity vector
C
      REAL(EB) FUNCTION FGX(T)
      REAL(EB) T
      IF (IRAMPG.EQ.0) FGX = 1.
      IF (IRAMPG.GT.0) FGX = FF2G(NINT(T*RDTRAMP)+1,1)
      END FUNCTION FGX
C
      REAL(EB) FUNCTION FGY(T)
      REAL(EB) T
      IF (IRAMPG.EQ.0) FGY = 1.
      IF (IRAMPG.GT.0) FGY = FF2G(NINT(T*RDTRAMP)+1,2)
      END FUNCTION FGY
C
      REAL(EB) FUNCTION FGZ(T)
      REAL(EB) T
      IF (IRAMPG.EQ.0) FGZ = 1.
      IF (IRAMPG.GT.0) FGZ = FF2G(NINT(T*RDTRAMP)+1,3)
      END FUNCTION FGZ
C
C
C Droplet drag coefficient
C
      REAL(EB) FUNCTION DRAG(RE)
      REAL(EB) RE
C
      IF (RE.LE.1.) THEN
         DRAG = 24./RE
      ELSEIF (RE.GT.1. .AND. RE.LT.1000.) THEN
         DRAG = 24.*(1.+0.15*RE**0.687)/RE
      ELSEIF (RE.GE.1000.) THEN
         DRAG = 0.44
      ENDIF
C
      END FUNCTION DRAG
C
C
C Complimentary ERF function
C
      REAL(EB) FUNCTION ERFC(X)
C
      REAL(EB), INTENT(IN) :: X
      REAL(EB) ERFCS(13), ERFCCS(24), ERC2CS(23),XSML,XMAX,
     .         SQEPS,SQRTPI,Y
      DATA ERFCS( 1) /   -.049046121234691808_EB /
      DATA ERFCS( 2) /   -.14226120510371364_EB /
      DATA ERFCS( 3) /    .010035582187599796_EB /
      DATA ERFCS( 4) /   -.000576876469976748_EB /
      DATA ERFCS( 5) /    .000027419931252196_EB /
      DATA ERFCS( 6) /   -.000001104317550734_EB /
      DATA ERFCS( 7) /    .000000038488755420_EB /
      DATA ERFCS( 8) /   -.000000001180858253_EB /
      DATA ERFCS( 9) /    .000000000032334215_EB /
      DATA ERFCS(10) /   -.000000000000799101_EB /
      DATA ERFCS(11) /    .000000000000017990_EB /
      DATA ERFCS(12) /   -.000000000000000371_EB /
      DATA ERFCS(13) /    .000000000000000007_EB /
      DATA ERC2CS( 1) /   -.069601346602309501_EB /
      DATA ERC2CS( 2) /   -.041101339362620893_EB /
      DATA ERC2CS( 3) /    .003914495866689626_EB /
      DATA ERC2CS( 4) /   -.000490639565054897_EB /
      DATA ERC2CS( 5) /    .000071574790013770_EB /
      DATA ERC2CS( 6) /   -.000011530716341312_EB /
      DATA ERC2CS( 7) /    .000001994670590201_EB /
      DATA ERC2CS( 8) /   -.000000364266647159_EB /
      DATA ERC2CS( 9) /    .000000069443726100_EB /
      DATA ERC2CS(10) /   -.000000013712209021_EB /
      DATA ERC2CS(11) /    .000000002788389661_EB /
      DATA ERC2CS(12) /   -.000000000581416472_EB /
      DATA ERC2CS(13) /    .000000000123892049_EB /
      DATA ERC2CS(14) /   -.000000000026906391_EB /
      DATA ERC2CS(15) /    .000000000005942614_EB /
      DATA ERC2CS(16) /   -.000000000001332386_EB /
      DATA ERC2CS(17) /    .000000000000302804_EB /
      DATA ERC2CS(18) /   -.000000000000069666_EB /
      DATA ERC2CS(19) /    .000000000000016208_EB /
      DATA ERC2CS(20) /   -.000000000000003809_EB /
      DATA ERC2CS(21) /    .000000000000000904_EB /
      DATA ERC2CS(22) /   -.000000000000000216_EB /
      DATA ERC2CS(23) /    .000000000000000052_EB /
      DATA ERFCCS( 1) /   0.0715179310202925_EB /
      DATA ERFCCS( 2) /   -.026532434337606719_EB /
      DATA ERFCCS( 3) /    .001711153977920853_EB /
      DATA ERFCCS( 4) /   -.000163751663458512_EB /
      DATA ERFCCS( 5) /    .000019871293500549_EB /
      DATA ERFCCS( 6) /   -.000002843712412769_EB /
      DATA ERFCCS( 7) /    .000000460616130901_EB /
      DATA ERFCCS( 8) /   -.000000082277530261_EB /
      DATA ERFCCS( 9) /    .000000015921418724_EB /
      DATA ERFCCS(10) /   -.000000003295071356_EB /
      DATA ERFCCS(11) /    .000000000722343973_EB /
      DATA ERFCCS(12) /   -.000000000166485584_EB /
      DATA ERFCCS(13) /    .000000000040103931_EB /
      DATA ERFCCS(14) /   -.000000000010048164_EB /
      DATA ERFCCS(15) /    .000000000002608272_EB /
      DATA ERFCCS(16) /   -.000000000000699105_EB /
      DATA ERFCCS(17) /    .000000000000192946_EB /
      DATA ERFCCS(18) /   -.000000000000054704_EB /
      DATA ERFCCS(19) /    .000000000000015901_EB /
      DATA ERFCCS(20) /   -.000000000000004729_EB /
      DATA ERFCCS(21) /    .000000000000001432_EB /
      DATA ERFCCS(22) /   -.000000000000000439_EB /
      DATA ERFCCS(23) /    .000000000000000138_EB /
      DATA ERFCCS(24) /   -.000000000000000048_EB /
      DATA SQRTPI /1.7724538509055160_EB/
C
      XSML = -200.
      XMAX = 200.
      SQEPS = 0.001
C
      IF (X.GT.XSML) GOTO 20
      ERFC = 2.
      RETURN
C
 20   IF (X.GT.XMAX) GOTO 40
      Y = ABS(X)
      IF (Y.GT.1.0) GOTO 30
C
C ERFC(X) = 1.0 - ERF(X) FOR -1. .LE. X .LE. 1.
C
      IF (Y.LT.SQEPS) ERFC = 1.0 - 2.0*X/SQRTPI
      IF (Y.GE.SQEPS) ERFC = 1.0 -
     .  X*(1.0 + CSEVL (2.*X*X-1., ERFCS, 10) )
      RETURN
C
C ERFC(X) = 1.0 - ERF(X) FOR 1. .LT. ABS(X) .LE. XMAX
C
 30   Y = Y*Y
      IF (Y.LE.4.) ERFC = EXP(-Y)/ABS(X) * (0.5 + CSEVL ((8./Y-5.)/3.,
     .  ERC2CS, 10) )
      IF (Y.GT.4.) ERFC = EXP(-Y)/ABS(X) * (0.5 + CSEVL (8./Y-1.,
     .  ERFCCS, 10) )
      IF (X.LT.0.) ERFC = 2.0 - ERFC
      RETURN
C
 40   ERFC = 0.
      RETURN
C
      END FUNCTION ERFC
C
C
      REAL(EB) FUNCTION CSEVL(X,CS,N)
C
      REAL(EB), INTENT(IN) :: X
      REAL(EB) CS(:),B1,B0,TWOX,B2
      INTEGER NI,N,I
C
      B1=0.
      B0=0.
      TWOX=2.*X
      DO I=1,N
      B2=B1
      B1=B0
      NI=N+1-I
      B0=TWOX*B1-B2+CS(NI)
      ENDDO
C
      CSEVL = 0.5*(B0-B2)
C
      END FUNCTION CSEVL
C
C
      SUBROUTINE CHECKREAD(NAME,LU,IOS)
C
      INTEGER :: II,IOS
      INTEGER, INTENT(IN) :: LU
      CHARACTER(4), INTENT(IN) :: NAME
      CHARACTER(80) TEXT
C
      IOS = 1
      READLOOP: DO
      READ(LU,'(A)',END=10) TEXT
C
      TLOOP: DO II=1,72
      IF (TEXT(II:II).NE.'&' .AND. TEXT(II:II).NE.' ') EXIT TLOOP
      IF (TEXT(II:II).EQ.'&') THEN
         IF (TEXT(II+1:II+4).EQ.NAME) THEN
            BACKSPACE(LU)
            IOS = 0
            EXIT READLOOP
            ELSE
            CYCLE READLOOP
            ENDIF
         ENDIF
      ENDDO TLOOP
C
      ENDDO READLOOP
C
   10 RETURN
      END SUBROUTINE CHECKREAD
C
C
C Memory checking routine
C
      SUBROUTINE ChkMemErr(CodeSect,VarName,IZERO)
C
      CHARACTER(*), INTENT(IN) :: CodeSect, VarName
      INTEGER IZERO
      CHARACTER(100) MESSAGE
C
      IF (IZERO.EQ.0) RETURN
C
      WRITE(MESSAGE,'(4A)') 'ERROR: Memory allocation failed for ',
     .           TRIM(VarName),' in the routine ',TRIM(CodeSect)
C
      CALL SHUTDOWN(MESSAGE)
      END SUBROUTINE ChkMemErr
C
C
C Compute droplet Cumulative Number Fraction (CNF)
C
      SUBROUTINE DROPLET_SIZE_DISTRIBUTION(DM,RR,CNF,NPT,GAMMA,SIGMA)
C
      REAL(EB), INTENT(IN) :: DM,GAMMA,SIGMA
      INTEGER, INTENT(IN) :: NPT
      REAL(EB) :: SUM1,DD1,DI,ETRM,GFAC,SFAC
      INTEGER  :: J
      REAL(EB), INTENT(OUT) :: RR(0:NPT),CNF(0:NPT)
C
C Compute droplet Cumulative Distribution Function (CDF_DROP)
C
      RR(0)  = 0.
      CNF(0) = 0.
      SUM1   = 0.
      DD1    = (-LOG(1.-0.99)/0.693)**(1./GAMMA)*DM/REAL(NPT,EB)
      GFAC   = 0.693*GAMMA*DD1/(DM**GAMMA)
      SFAC   = DD1/(SQRT(TWOPI)*SIGMA)
C
      INTLOOP: DO J=1,NPT
      DI = (J-.5)*DD1
      RR(J) = .5*DI
C
      IF (DI.LE.DM) THEN
      ETRM = EXP(-(LOG(DI/DM))**2/(2.*SIGMA**2))
      SUM1 = SUM1 + (SFAC/DI**4)*ETRM
      ELSE
      ETRM = EXP(-0.693*(DI/DM)**GAMMA)
      SUM1 = SUM1 + GFAC*DI**(GAMMA-4.)*ETRM
      ENDIF
C
      CNF(J) = SUM1
      ENDDO INTLOOP
C
      CNF = CNF/SUM1
C
      END SUBROUTINE DROPLET_SIZE_DISTRIBUTION
C
C
      END MODULE CONS
C
C
C
      MODULE TRAN 
C
C Coordinate transformation arrays
C
      USE PREC
      IMPLICIT NONE
C
      TYPE TRAN_TYPE
      REAL(EB), POINTER, DIMENSION(:,:) :: C1,C2,C3,CCSTORE,PCSTORE
      INTEGER, POINTER, DIMENSION(:,:) :: IDERIVSTORE
      INTEGER NOC(3),ITRAN(3),NOCMAX
      END TYPE TRAN_TYPE
C
      TYPE (TRAN_TYPE), ALLOCATABLE, TARGET, DIMENSION(:) :: TRANS
C
C
      CONTAINS
C
C
C Coordinate transformation function
C
      REAL(EB) FUNCTION G(X,IC,NM)
C
      REAL(EB), INTENT(IN) :: X
      INTEGER, INTENT(IN)  :: IC,NM
      INTEGER I,II,N
      TYPE (TRAN_TYPE), POINTER :: T
C
      T => TRANS(NM)
C
      N = T%NOC(IC)
      IF (N.EQ.0) THEN
         G = X
         RETURN
         ENDIF
C
      IF (T%ITRAN(IC).EQ.1) THEN
      G = 0.
      DO I=1,N+1
      G = G + T%C1(I,IC)*X**I
      ENDDO
      ENDIF
C
      IF (T%ITRAN(IC).EQ.2) THEN
      ILOOP: DO I=1,N+1
      II = I
      IF (X.LE.T%C1(I,IC)) EXIT ILOOP
      ENDDO ILOOP
      G = T%C2(II-1,IC) + T%C3(II,IC)*(X-T%C1(II-1,IC))
      ENDIF
C
      END FUNCTION G
C
C
C Derivative of the coordinate transformation function
C
      REAL(EB) FUNCTION GP(X,IC,NM)
C
      REAL(EB), INTENT(IN) :: X
      INTEGER, INTENT(IN)  :: IC,NM
      INTEGER I,II,N
      TYPE (TRAN_TYPE), POINTER :: T
C
      T => TRANS(NM)
C
      N = T%NOC(IC)
      IF (N.EQ.0) THEN
         GP = 1.
         RETURN
         ENDIF
C
      IF (T%ITRAN(IC).EQ.1) THEN
      GP = 0.
      DO I=1,N+1
      GP = GP + I*T%C1(I,IC)*X**(I-1)
      ENDDO
      ENDIF
C
      IF (T%ITRAN(IC).EQ.2) THEN
      ILOOP: DO I=1,N+1
      II = I
      IF (X.LE.T%C1(I,IC)) EXIT ILOOP
      ENDDO ILOOP
      GP = T%C3(II,IC)
      ENDIF
C
      END FUNCTION GP
C
C
C Inverse of the coordinate transformation function
C
      REAL(EB) FUNCTION GINV(Z,IC,NM)
C
      REAL(EB) GF
      INTEGER N,IT,II,I
      REAL(EB), INTENT(IN) :: Z
      INTEGER, INTENT(IN)  :: IC,NM
      TYPE (TRAN_TYPE), POINTER :: T
C
      T => TRANS(NM)
C
      GINV = Z
      N = T%NOC(IC)
      IF (N.EQ.0) RETURN
C
      IF (T%ITRAN(IC).EQ.1) THEN
      LOOP1: DO IT=1,10
      GF = G(GINV,IC,NM)-Z
      IF (ABS(GF).LT.0.002) EXIT LOOP1
      GINV = GINV - GF/GP(GINV,IC,NM)
      ENDDO LOOP1
      ENDIF
C
      IF (T%ITRAN(IC).EQ.2) THEN
      ILOOP: DO I=1,N+1
      II = I
      IF (Z.LE.T%C2(I,IC)) EXIT ILOOP
      ENDDO ILOOP
      GINV = T%C1(II-1,IC) + (Z-T%C2(II-1,IC))/T%C3(II,IC)
      ENDIF
C
      END FUNCTION GINV
C
C
      END MODULE TRAN
C
C
C
      module isodefs

      interface

      subroutine isoheader(isofile,isolonglabel,isoshortlabel,
     .                     isounits,levels,nlevels,error)

cDEC$ ATTRIBUTES C :: ISOHEADER
cDEC$ ATTRIBUTES REFERENCE :: ISOFILE,ISOLONGLABEL,ISOSHORTLABEL
cDEC$ ATTRIBUTES REFERENCE :: ISOUNITS,LEVELS,NLEVELS,ERROR

      character(len=*) :: isofile
      character(len=30), intent(in) :: isolonglabel, 
     .      isoshortlabel, isounits
      integer, intent(in) :: nlevels
      integer, intent(out) :: error
      real, dimension(nlevels), intent(in) :: levels

      end subroutine isoheader

      subroutine tisoheader(isofile,isolonglabel,isoshortlabel,
     .                      isounits,levels,nlevels,error)

cDEC$ ATTRIBUTES C :: TISOHEADER
cDEC$ ATTRIBUTES REFERENCE :: ISOFILE,ISOLONGLABEL,ISOSHORTLABEL
cDEC$ ATTRIBUTES REFERENCE :: ISOUNITS,LEVELS,NLEVELS,ERROR

      character(len=*) :: isofile
      character(len=30), intent(in) :: isolonglabel, 
     .                  isoshortlabel, isounits
      integer, intent(in) :: nlevels
      integer, intent(out) :: error
      real, dimension(nlevels), intent(in) :: levels

      end subroutine tisoheader

      subroutine iso2file(isofile,t,data,iblank,level,nlevels,
     .                    xplt, nx, yplt, ny, zplt, nz, isooffset, 
     .                    reduce_triangles, error)

cDEC$ ATTRIBUTES C :: ISO2FILE
cDEC$ ATTRIBUTES REFERENCE :: ISOFILE, T, DATA, IBLANK, LEVEL
cDEC$ ATTRIBUTES REFERENCE :: NLEVELS, XPLT, NX, YPLT, NY, ZPLT, NZ 
cDEC$ ATTRIBUTES REFERENCE :: ISOOFFSET, REDUCE_TRIANGLES, ERROR

      character(len=*), intent(in) :: isofile
      integer, intent(in) :: nlevels, isooffset, nx, ny, nz
      integer, intent(out) :: error
      real, intent(in) :: t
      real, dimension(nlevels), intent(in)  :: level
      real, intent(in), dimension(nx*ny*nz) :: data
      integer, intent(in), dimension(nx*ny*nz) :: iblank
      real, intent(in), dimension(nx) :: xplt
      real, intent(in), dimension(ny) :: yplt
      real, intent(in), dimension(nz) :: zplt
      integer, intent(in) :: reduce_triangles

      end subroutine iso2file

      subroutine isot2file(isofile,t,data,data2flag,data2,
     .                     iblank,level,nlevels,
     .                     xplt, nx, yplt, ny, zplt, nz, 
     .                     isooffset, reduce_triangles, error)

cDEC$ ATTRIBUTES C :: ISOT2FILE
cDEC$ ATTRIBUTES REFERENCE :: ISOFILE, T, DATA, DATA2FLAG, DATA2
cDEC$ ATTRIBUTES REFERENCE :: IBLANK, LEVEL, NLEVELS, XPLT, NX
cDEC$ ATTRIBUTES REFERENCE :: YPLT, NY, ZPLT, NZ, ISOOFFSET
cDEC$ ATTRIBUTES REFERENCE :: REDUCE_TRIANGLES, ERROR

      character(len=*), intent(in) :: isofile
      integer, intent(in) :: nlevels, isooffset, nx, ny, nz, data2flag
      integer, intent(out) :: error
      real, intent(in) :: t
      real, dimension(nlevels), intent(in)  :: level
      real, intent(in), dimension(nx*ny*nz) :: data, data2
      integer, intent(in), dimension(nx*ny*nz) :: iblank
      real, intent(in), dimension(nx) :: xplt
      real, intent(in), dimension(ny) :: yplt
      real, intent(in), dimension(nz) :: zplt
      integer, intent(in) :: reduce_triangles

      end subroutine isot2file

      end interface
      end module isodefs
C
C
      module compressdefs

      interface

      subroutine smoke3dheader(file,is1,is2,js1,js2,ks1,ks2)

cDEC$ ATTRIBUTES C :: SMOKE3DHEADER
cDEC$ ATTRIBUTES REFERENCE :: FILE,IS1,IS2,JS1,JS2,KS1,KS2
      character(len=*), intent(in) :: file
      integer, intent(in) ::is1,is2,js1,js2,ks1,ks2

      end subroutine smoke3dheader

      subroutine smoke3dtofile(file,time,dx,extcoef,type,xyz,nx,ny,nz)

cDEC$ ATTRIBUTES C :: SMOKE3DTOFILE
cDEC$ ATTRIBUTES REFERENCE :: FILE,TIME,DX,EXTCOEF,TYPE,XYZ,NX,NY,NZ
      character(len=*), intent(in) :: file
      real, intent(in) :: time, dx, extcoef
      integer, intent(in) :: nx,ny,nz
      real, intent(in), dimension(nx*ny*nz) :: xyz
      integer, intent(in) :: type
      end subroutine smoke3dtofile

      end interface
      end module compressdefs
C
C
      MODULE RADCALV
C
C Module wrapper for RadCal subroutine
C
      USE PREC
      IMPLICIT NONE
      PRIVATE
      PUBLIC OMMAX,OMMIN,DD,SPECIE,SVF,PLANCK,P,RCT,RCALLOC,INIT_RADCAL,
     .       RADCAL,RCDEALLOC
C
      REAL(EB), ALLOCATABLE, DIMENSION(:,:) :: P,X,UUU,GC,GAMMA,SD15,
     .    SD,SD7,SD3
C
      REAL(EB), ALLOCATABLE, DIMENSION(:) :: SVF,XPART,RCT,SPECIE,TAU,
     .    TAUS,AC,AD,QW,TTAU,XTOT,XT,XSTAR,AB,PKPA,AMBDA,ATOT,BCNT,DD
C
      REAL(EB) OMMIN,OMMAX,TWALL
C
      INTEGER NPT,NPRINT,NOM
C
C
      CONTAINS
C
C
      SUBROUTINE INIT_RADCAL
C
      NPT=1
      TWALL=0.
c      TWALL=293.15
      IF(OMMAX.LT.1100.) THEN 
         NOM=INT((OMMAX-OMMIN)/5.)
      ELSEIF(OMMIN.GT.5000.) THEN
         NOM=INT((OMMAX-OMMIN)/50.)
      ELSEIF(OMMIN.LT.1100..AND.OMMAX.GT.5000.) THEN
         NOM=INT((1100.-OMMIN)/5.)+INT((5000.-1100.)/25.)
     2        +INT((OMMAX-5000.)/50.)
      ELSEIF(OMMIN.LT.1100.) THEN
         NOM=INT((1100.-OMMIN)/5.)+INT((OMMAX-1100.)/25.)
      ELSEIF(OMMAX.GT.5000.) THEN
         NOM=INT((5000.-OMMIN)/25.)+INT((OMMAX-5000.)/50.)
      ELSE
         NOM=INT((OMMAX-OMMIN)/25.)
      ENDIF
      NPRINT=1
C
      END SUBROUTINE INIT_RADCAL
C
C**************************************************************************
C
      SUBROUTINE RADCAL(AMEAN,AP0)
C
      INTEGER I,II,J,K,L,KK,NM,N,MM,KMAX,LMAX,KMIN
      REAL (EB) DOM,ABGAS,PTOT,TEMP,UK,GKD,GKDD,XD,YD,XX,ENN,ARG,ARGNEW,
     .          RSL,RSS,ABLONG,ABSHRT,ABIL,ABIS,OMEGA,WL,DAMBDA,AP0,
     .          SDWEAK,GDINV,GDDINV,YC,Y,AIWALL,AMEAN,XC,AOM,Q,
     .          LTERM
C
C  [NOTE: THE TOTAL INTENSITY CALCULATED IS THAT WHICH LEAVES INTERVAL J=1.
C  P(I,J) IS PARTIAL PRESSURE, ATM, OF SPECIES I IN  INTERVAL J.
C  I=1,2,3,4,5, OR 6 IMPLIES SPECIES IS CO2, H2O, CH4, CO, O2, OR N2, RESP.]
C
      DOM=5.0
      OMEGA=OMMIN-DOM
      NM=NOM-1
C
C     LOOP 1000 COMPUTES EACH SPECTRAL CONTRIBUTION
C     *********************************************
      L1000: DO KK=1,NOM
      OMEGA=OMEGA+DOM
      IF(OMEGA.GT.1100.) OMEGA=OMEGA+20.
      IF(OMEGA.GT.5000.) OMEGA=OMEGA+25.
      AMBDA(KK)=10000./OMEGA
      ABGAS=0.
C
C          LOOP 200 COMPUTES THE CONTRIBUTION OF EACH SPECIES TO TAU
C	   *********************************************************
      L200: DO I=1,4
C     IF SPECIE(I) IS SET TO 0., THAT PARTICULAR RADIATING SPECIES IS
C     NOT PRESENT.  THE SPECIES CONSIDERED ARE
C          I   SPECIES
C          1     CO2
C          2     H2O
C          3     CH4
C          4     CO
C          5     PARTICULATES
      IF(SPECIE(I).EQ.0.) CYCLE L200
C
C               LOOP 100 IS FOR EACH ELEMENT ALONG PATH
C               ***************************************
      L100: DO J=1,NPT
C     (CALCULATION PROCEEDS IN ACCORDANCE WITH THE SLG MODEL, TABLE 5-18
C     IN NASA SP-3080.)
      IF(KK.LE.1) THEN
         UUU(I,J)=273./RCT(J)*P(I,J)*100.*DD(J)
         GC(I,J)=0.
         PTOT=0.
         DO II=1,6
            PTOT=P(II,J)+PTOT
            GC(I,J)=GC(I,J)+GAMMA(I,II)*P(II,J)*(273./RCT(J))**.5
         ENDDO
         GC(I,J)=GC(I,J)+GAMMA(I,7)*P(I,J)*273./RCT(J)
      ENDIF
      IF(P(I,J).EQ.0.) THEN
         IF(J.GT.1) THEN
            XSTAR(J)=XSTAR(J-1)
            AC(J)=AC(J-1)
            AD(J)=AD(J-1)
         ELSE
            XSTAR(1)=1.D-34
            AC(1)=1.
            AD(1)=1.
         ENDIF
         X(I,J)=XSTAR(J)
      ELSE
         TEMP=RCT(J)
         SELECT CASE (I)
         CASE (1)
         CALL CO2(OMEGA,TEMP,GC(1,J),SDWEAK,GDINV,GDDINV)
         CASE (2)
         CALL H2O(OMEGA,TEMP,GC(2,J),SDWEAK,GDINV,GDDINV)
         CASE (3)
         CALL FUEL(OMEGA,TEMP,P(3,J),PTOT,GC(3,J),SDWEAK,GDINV,GDDINV)
         CASE (4)
         CALL CO(OMEGA,TEMP,GC(4,J),SDWEAK,GDINV,GDDINV)   
         END SELECT
         UK=SDWEAK*UUU(I,J)
         IF(J.EQ.1) THEN
            XSTAR(1)=UK+1.D-34
            ABGAS=UK/DD(1)+ABGAS
            AD(1)=GDDINV
            AC(1)=GDINV
         ELSE
            GKD=UK*GDINV
            GKDD=UK*GDDINV
            XSTAR(J)=XSTAR(J-1)+UK
            AD(J)=(XSTAR(J-1)*AD(J-1)+GKDD)/XSTAR(J)
            AC(J)=(XSTAR(J-1)*AC(J-1)+GKD)/XSTAR(J)
         ENDIF
         IF(XSTAR(J).GE.1.E-6) THEN
            XD=1.7*AD(J)*(DLOG(1.+(XSTAR(J)/1.7/AD(J))**2))**.5
            YD=1.-(XD/XSTAR(J))**2
            XC=XSTAR(J)/(1.+XSTAR(J)/4./AC(J))**.5
C
C   THE FOLLOWING LOOP COMPUTES THE OPTICAL THICKNESS, XC, FOR METHANE USING
C   THE GODSON EQUATION AND AN APPROXIMATION TO THE LADENBERG-REICHE
C   FUNCTION AS RECOMMENDED BY BROSMER AND TIEN (JQSRT 33,P 521).  THE
C   ERROR FUNCTION IS FOUND FROM ITS SERIES EXPANSION.
C
            IF((I.EQ.3.).AND.(XC.LE.10)) THEN
               AOM=XC
               XX=.5*3.141593**.5*XC
               IF(XX.LE.3.) THEN
                  ENN=1.
                  DO N=1,30
                     ENN=ENN*N
                     MM=2*N+1
                     ARG=1.128379*(-1.)**N*((.88622693*XC)**MM)/(MM*ENN)
                     ARGNEW=ARG+AOM
C     IF(ABS(ARG/ARGNEW).LT..000001)N=30
                     AOM=ARGNEW
                  ENDDO
               ELSE
                  AOM=1.-EXP(-XX**2)/(3.141593**.5*XX)
               ENDIF
               IF(AOM.GE.1.)AOM=.9999999
               XC=-DLOG(1.-AOM)
            ENDIF
C     
            YC=1.-(XC/XSTAR(J))**2
            Y=MAX(1./YC**2+1./YD**2-1.,1._EB)
            X(I,J)=XSTAR(J)*((1.-(Y**(-.5)))**.5)
         ELSE
            X(I,J)=XSTAR(J)
         ENDIF
      ENDIF
      ENDDO L100
C
      ENDDO L200
C
C  DETERMINE OPTICAL DEPTH OF SOOT
C
      IF(SPECIE(5).EQ.0.) THEN
         DO J=1,NPT
            XPART(J)=0.
         ENDDO
      ELSE
         CALL POD(OMEGA)
      ENDIF
      AB(KK)=ABGAS+XPART(1)/DD(1)
C     
C     EVALUATE THE COMBINED SPECTRAL TRANSMITTANCE AND RADIANCE
C     *********************************************************
      L500: DO J=1,NPT
      XTOT(J)=0.
      DO I=1,4
         IF(SPECIE(I).EQ.0.) X(I,J)=0.
         XTOT(J)=X(I,J)+XTOT(J)
      ENDDO
      XTOT(J)=XTOT(J)+XPART(J)
      IF(XTOT(J).GE.99.) THEN
         TAU(J)=0.
      ELSE
         TAU(J)=EXP(-XTOT(J))
      ENDIF
      IF(J.EQ.1) THEN
         QW(KK)=-(TAU(1)-1.)*PLANCK(RCT(1),AMBDA(KK))
      ELSE
         QW(KK)=QW(KK)-(TAU(J)-TAU(J-1))*PLANCK(RCT(J),AMBDA(KK))
      ENDIF
      ENDDO L500
      XT(KK)=XTOT(NPT)
      TTAU(KK)=TAU(NPT)
      QW(KK)=QW(KK)+TTAU(KK)*PLANCK(TWALL,AMBDA(KK))
      ENDDO L1000
C     
C     INTEGRATE THE RADIANCE OVER THE SPECTRUM
C     
      Q=QW(1)*(AMBDA(1)-AMBDA(2))
      DO KK=2,NM
         Q=Q+QW(KK)*(AMBDA(KK-1)-AMBDA(KK+1))/2.
      ENDDO
      Q=Q+QW(NOM)*(AMBDA(NOM-1)-AMBDA(NOM))
C     
C     DETERMINE SOOT RADIANCE FOR SHORT AND LONG WAVELENGTHS.
C     
      RSL=0.
      RSS=0.
      ABLONG=0.
      ABSHRT=0.
      ABIL=0.
      ABIS=0.
      IF(.NOT.(SPECIE(5).EQ.0..AND.TWALL.EQ.0.)) THEN
      KMAX=OMMIN/5*5
      DO KK=5,KMAX,5
         OMEGA=FLOAT(KK)
         WL=10000./OMEGA
         DAMBDA=10000./(OMEGA-2.5)-10000./(OMEGA+2.5)
         CALL POD(OMEGA)
C     
         DO J=1,NPT
         IF(XPART(J).GE.33.) THEN
            TAUS(J)=0.
         ELSE
            TAUS(J)=EXP(-XPART(J))
         ENDIF
         IF(J.EQ.1) THEN
            RSL=RSL-(TAUS(1)-1.)*PLANCK(RCT(1),WL)*DAMBDA
            ABLONG=ABLONG+XPART(1)/DD(1)*PLANCK(RCT(1),WL)*DAMBDA
     2           *5.5411E7/(RCT(1))**4
            ABIL=ABIL+XPART(1)/DD(1)*PLANCK(TWALL,WL)*DAMBDA*5.5411E7
     2           /(TWALL+.000001)**4
         ELSE
            RSL=RSL-(TAUS(J)-TAUS(J-1))*PLANCK(RCT(J),WL)*DAMBDA
         ENDIF
      ENDDO
C
      RSL=RSL+TAUS(NPT)*PLANCK(TWALL,WL)*DAMBDA
      ENDDO
      KMIN=OMMAX/100*100
      DO KK=KMIN,25000,100
         OMEGA=FLOAT(KK)
         WL=10000./OMEGA
         DAMBDA=10000./(OMEGA-50.)-10000./(OMEGA+50.)
         CALL POD(OMEGA)
         DO J=1,NPT
         IF(XPART(J).GE.33.) THEN
            TAUS(J)=0.
         ELSE
            TAUS(J)=EXP(-XPART(J))
         ENDIF
         IF(J.NE.1) THEN
            RSS=RSS-(TAUS(J)-TAUS(J-1))*PLANCK(RCT(J),WL)*DAMBDA
         ELSE
          RSS=RSS-(TAUS(1)-1.)*PLANCK(RCT(1),WL)*DAMBDA
          ABSHRT=ABSHRT+XPART(1)/DD(1)*PLANCK(RCT(1),WL)*DAMBDA*5.5411E7
     2          /(RCT(1))**4
          ABIS=ABIS+XPART(1)/DD(1)*PLANCK(TWALL,WL)*DAMBDA*5.5411E7
     2          /(TWALL+.000001)**4
         ENDIF
      ENDDO
      RSS=RSS+TAUS(NPT)*PLANCK(TWALL,WL)*DAMBDA
      ENDDO
      ENDIF
      Q=Q+RSS+RSL
C
C
      IF (NPRINT.NE.0) THEN
          IF(NPRINT.EQ.1) THEN
            NPRINT=2
            DO J=1,NPT
               DO I=1,6
                  PKPA(I)=P(I,J)*101.
               ENDDO
            ENDDO
          ENDIF
          LMAX=NOM/2
          IF(LMAX*2.LT.NOM) LMAX=LMAX+1
          DO L=1,LMAX
             K=NOM-LMAX+1-L
             J=K+LMAX
             IF(K.LT.1) K=1
          ENDDO
      ENDIF

C
C     THE FOLLOWING SECTION COMPUTES THE MEAN ABSORPTION COEFFICIENTS
C     IF THE SYSTEM IS HOMOGENEOUS (IE., NPT=1).
C
      IF(NPT.EQ.1) THEN
      NM=NOM-1
      AIWALL=AB(1)*(AMBDA(1)-AMBDA(2))/2.*PLANCK(TWALL,AMBDA(1))
      AP0=AB(1)*(AMBDA(1)-AMBDA(2))/2.*PLANCK(RCT(1),AMBDA(1))
      DO KK=2,NM
         AIWALL=AIWALL+AB(KK)*(AMBDA(KK-1)-AMBDA(KK+1))/2.
     2        *PLANCK(TWALL,AMBDA(KK))
         AP0=AP0+AB(KK)*(AMBDA(KK-1)-AMBDA(KK+1))/2.
     2        *PLANCK(RCT(1),AMBDA(KK))
      ENDDO
      AP0=(AP0+AB(NOM)*(AMBDA(NM)-AMBDA(NOM))/2.
     2     *PLANCK(RCT(1),AMBDA(NOM)))*5.5411E7/RCT(1)**4
      IF(TWALL.EQ.RCT(1).OR.TWALL.EQ.0.) THEN
      AIWALL=AP0
      LTERM = MAX(1E-10_EB,(5.5411E7*Q-RCT(1)**4)/(-RCT(1)**4))
c      LTERM = (1.-5.5411E7*Q/RCT(1)**4)
      AMEAN=-1./DD(1)*DLOG(LTERM)
       ELSE
      AIWALL=(AIWALL+AB(NOM)*(AMBDA(NM)-AMBDA(NOM))/2.*
     2     PLANCK(TWALL,AMBDA(NOM)))*5.5411E7/TWALL**4
      AMEAN=-1./DD(1)*DLOG((5.5411E7*Q-RCT(1)**4)/(TWALL**4-RCT(1)**4))
      ENDIF
      ENDIF
C
      END SUBROUTINE RADCAL
C
C*****************************************************************************
C
      SUBROUTINE CO2(OMEGA,TEMP,GC1,SDWEAK,GDINV,GDDINV)
C
      INTEGER I,J,K,L
      REAL(EB) OMEGA,TEMP,GC1,SDWEAK,GDINV,GDDINV,AA,BB,CC,QQ,EE,FF,GG,
     .         SMINUS,SPLUS,SDSTRG,GD,OM1,OM2,OM3,T0,Q2,BE,COM1,
     .         COM2,COM3,X13,X23,X33,XBAR,OM12,ALPHA,OMPRIM,V3,GAM,
     .         OMVV3,DELTA,V,OMVBAR,F1,F2,UNFLO1,UNFLO2,UNFLO3,TEST,
     .         VBAR1,OMA,OMB,TTEMP,TT,T1,TW,WW,TEMP1,TEMP2,TEMP3,WM,
     .         DINV,A,B,D,G,W1,DINV1,DINV2,DINV3
C
      IF(OMEGA.GT.5725.) THEN
         SDWEAK=0.
         GDINV=1.
         GDDINV=1.
      ELSE
         WM=44.
         GD=5.94E-6*OMEGA*(TEMP/(273.*WM))**.5
         IF(OMEGA.GT.4550.) THEN
CONTRIBUTION TO 2.0 MICRON BAND FROM (000)-(041),(000)-(121),AND (000)
C     -(201) TRANS.
            OM1=1354.91
            OM2=673.0
            OM3=2396.49
            BCNT(1)=4860.5
            BCNT(2)=4983.5
            BCNT(3)=5109.0
            T0=300.
            Q2=1.4388
            BE=0.391635
            COM1=4.*OM2+OM3
            COM2=OM1+2.*OM2+OM3
            COM3=2.*OM1+OM3
            ATOT(3)=0.426*T0/TEMP*(1.-EXP(-Q2*COM3/TEMP/
     1              (1.-EXP(-Q2*OM1/TEMP))))**2/(1.-EXP(-Q2*OM3/TEMP))
            ATOT(2)=1.01*T0/TEMP*(1.-EXP(-Q2*COM2/TEMP))/
     1              (1.-EXP(-Q2*OM1/TEMP))/(1.-EXP(-Q2*OM2/TEMP))**2/
     2              (1.-EXP(-Q2*OM3/TEMP))
            ATOT(1)=0.272*T0/TEMP*(1.-EXP(-Q2*COM1/TEMP))/
     1              (1.-EXP(-Q2*OM2/TEMP))**4/(1.-EXP(-Q2*OM3/TEMP))
            SDWEAK=0.0
            DO K=1,3
               SDWEAK=SDWEAK+ATOT(K)*Q2/(4.*BE*TEMP)*ABS(OMEGA-BCNT(K))
     1              *EXP(-Q2/(4.*BE*TEMP)*(OMEGA-BCNT(K))**2)
            ENDDO
            DINV=1./(4.*BE)
            GDINV=GC1*DINV
            GDDINV=GD*DINV
C***EXPRESS S/D AT STP, AS IS IN NASA SP-3080
            SDWEAK=SDWEAK*TEMP/273.
         ELSEIF((OMEGA.LE.4550).AND.(OMEGA.GT.3800.)) THEN
            SDWEAK=0.
            GDINV=1.
            GDDINV=1.
         ELSEIF((OMEGA.LE.3800.).AND.(OMEGA.GT.3050.)) THEN
            B=.391635
            A=.0030875
            X13=-19.37
            X23=-12.53
            X33=-12.63
            OM1=1354.91
            OM2=673.
            OM3=2396.49
            T0=300.
            Q2=1.4388
            XBAR=.5*(.5*X13+X23)
            OM12=.5*(.5*OM1+OM2)
            SDWEAK=0.
            SDSTRG=0.
            IF(OMEGA.LE.2395.) THEN
               ALPHA=2700.
               OMPRIM=OM3
               AA=ALPHA*B*Q2/(A*(1.-EXP(-OM3*Q2/T0))*(1.-EXP(-OM12*Q2
     1         /T0))**3*(1.+EXP(-OM12*Q2/T0))*(1.-EXP(-OMPRIM*Q2/T0)))
               BB=(1.-EXP(-Q2*OMEGA/TEMP))*(1.-EXP(-Q2*OM3/TEMP))*
     1         (1.-EXP(-OM12*Q2/TEMP))**3*(1.+EXP(-OM12*Q2/TEMP))
     2         *(1.-EXP(-Q2*OMPRIM/TEMP))
               CC=AA*BB*OMEGA/TEMP*T0/TEMP
               L202: DO J=1,20
                  V=FLOAT(J-1)
                  IF(J/2*2.EQ.J)G=(V+1.)*(V+3.)/4.
                  IF(J/2*2.NE.J)G=(V+2.)*(V+2.)/4.
                  L201: DO K=1,10
                     V3=FLOAT(K-1)
                     QQ=(V3+1.)*G*EXP(-(V3*OM3+V*OM12)*Q2/TEMP)
                     GAM=B-A*(V3+1.)
                     OMVV3=OM3+.5*X13+X23+2.*X33+XBAR*V+2.*X33*V3
                     DELTA=A*(OMEGA-OMVV3)
                     IF(GAM*GAM.LE.DELTA) CYCLE L202
                     D=2.*(GAM*GAM-DELTA)**.5
                     OMVBAR=OMVV3*(1.-EXP(-OMVV3*Q2/TEMP))
                     F1=GAM-D/2
                     F2=GAM+D/2.
                     EE=Q2*GAM/(A*A*TEMP)
                     UNFLO1=EE*DELTA*(1.+.5*A/GAM)
                     IF(UNFLO1.LE.-78.) CYCLE L202
                     UNFLO2=EE*2.*GAM*F1
                     IF(UNFLO2.GE.78.) CYCLE L202
                     FF=EXP(EE*DELTA*(1.+.5*A/GAM))
                     SMINUS=CC*QQ/OMVBAR*ABS(F1)*FF*EXP(-EE*2.*GAM*F1)
                     UNFLO3=EE*2.*GAM*F2
                     IF(UNFLO3.GE.78.) THEN
                        SPLUS=0.
                     ELSE
                        SPLUS=CC*QQ/OMVBAR*ABS(F2)*FF*EXP(-EE*2.*GAM*F2)
                     ENDIF
                     GG=SDWEAK
                     SDWEAK=(SMINUS+SPLUS)/D+SDWEAK
                     TEST=(SDWEAK-GG)/SDWEAK
                     IF(TEST.LT..0001) CYCLE L202
                     SDSTRG=(.5*G)**.5*(SMINUS**.5+SPLUS**.5)/D+SDSTRG
                  ENDDO L201
               ENDDO L202
               IF(SDWEAK.EQ.0.) THEN
                  SDWEAK=0.
                  GDINV=1.
                  GDDINV=1.
               ELSE
                  DINV=SDSTRG*SDSTRG/SDWEAK
                  GDINV=GC1*DINV
                  GDDINV=GD*DINV
C***  EXPRESS S/D AT STP, AS IS K IN NASA SP-3080
                  SDWEAK=SDWEAK*TEMP/273.
               ENDIF
            ELSE
CALCULATE ABSORPTION COEF. AND LINE SPACING PARAMETER FOR 2.7 MICRON BAND
               L=1
CONTRIBUTION TO 2.7 MICRON BAND FROM (000)-(021) AND (010)-(031) TRANS.
               ALPHA=28.5
               OMPRIM=2.*OM2+OM3
               L120: DO
               AA=ALPHA*B*Q2/(A*(1.-EXP(-OM3*Q2/T0))*(1.-EXP(-OM12*Q2
     1         /T0))**3*(1.+EXP(-OM12*Q2/T0))*(1.-EXP(-OMPRIM*Q2/T0)))
               BB=(1.-EXP(-Q2*OMEGA/TEMP))*(1.-EXP(-Q2*OM3/TEMP))*
     1         (1.-EXP(-OM12*Q2/TEMP))**3*(1.+EXP(-OM12*Q2/TEMP))
     2         *(1.-EXP(-Q2*OMPRIM/TEMP))
               CC=AA*BB*OMEGA/TEMP*T0/TEMP
               L102: DO J=1,20
               V=FLOAT(J-1)
               IF(J/2*2.EQ.J)G=(V+1.)*(V+3.)/4.
               IF(J/2*2.NE.J)G=(V+2.)*(V+2.)/4.
               VBAR1=-1.+(V+3.)*(V+4.)/(V+2.)/6.
               IF(J/2*2.EQ.J)VBAR1=-1.+(V+5.)/6.
               L101: DO K=1,10
               V3=FLOAT(K-1)
               QQ=(V3+1)*G*EXP(-(V3*OM3+V*OM12)*Q2/TEMP)*(VBAR1+1.)
               GAM=B-A*(V3+1.)
               IF(L.EQ.2) THEN
                  OMVV3=3728.-5.*V-47.*V3
                  IF(V.EQ.0.)OMVV3=3715.-47.*V3
               ELSE
                  OMVV3=3598.-18.*V-47.*V3
                  IF(V.EQ.0.)OMVV3=3613.-47.*V3
               ENDIF
               DELTA=A*(OMEGA-OMVV3)
               IF(GAM*GAM.LE.DELTA) CYCLE L102
               D=2.*(GAM*GAM-DELTA)**.5
               OMVBAR=OMVV3*(1.-EXP(-OMVV3*Q2/TEMP))
               F1=GAM-D/2
               F2=GAM+D/2.
               EE=Q2*GAM/(A*A*TEMP)
               UNFLO1=EE*DELTA*(1.+.5*A/GAM)
               IF(UNFLO1.LE.-78.) CYCLE L102
               UNFLO2=EE*2.*GAM*F1
               IF(UNFLO2.GE.78.) CYCLE L102
               FF=EXP(EE*DELTA*(1.+.5*A/GAM))
               SMINUS=CC*QQ/OMVBAR*ABS(F1)*FF*EXP(-EE*2.*GAM*F1)
               UNFLO3=EE*2.*GAM*F2
               IF(UNFLO3.GE.78.) THEN
                  SPLUS=0.
               ELSE
                  SPLUS=CC*QQ/OMVBAR*ABS(F2)*FF*EXP(-EE*2.*GAM*F2)
               ENDIF
               GG=SDWEAK
               SDWEAK=(SMINUS+SPLUS)/D+SDWEAK
               TEST=(SDWEAK-GG)/SDWEAK
               IF(TEST.LT..0001) CYCLE L102
               SDSTRG=(.5*G)**.5*(SMINUS**.5+SPLUS**.5)/D+SDSTRG
               ENDDO L101
               ENDDO L102
               IF(L.EQ.2) EXIT L120
CONTRIBUTION TO 2.7 MICRON BAND FROM (000)-(101) AND (010)-(111) TRANS.
               ALPHA=42.3
               OMPRIM=OM1+OM3
               L=2
            ENDDO L120
CALCULATE ABSORPTION COEF AND LINE SPACING PARAMETER FOR 4.3 MICRON BAND
            IF(SDWEAK.EQ.0.) THEN
               SDWEAK=0.
               GDINV=1.
               GDDINV=1.
            ELSE
               DINV=SDSTRG*SDSTRG/SDWEAK
               GDINV=GC1*DINV
               GDDINV=GD*DINV
C***EXPRESS S/D AT STP, AS IS K IN NASA SP-3080
               SDWEAK=SDWEAK*TEMP/273.
            ENDIF
         ENDIF
      ELSEIF((OMEGA.LE.3050.).AND.(OMEGA.GT.2474.)) THEN
         SDWEAK=0.
         GDINV=1.
         GDDINV=1.
      ELSEIF((OMEGA.LE.2474.).AND.(OMEGA.GT.1975.)) THEN
         B=.391635
         A=.0030875
         X13=-19.37
         X23=-12.53
         X33=-12.63
         OM1=1354.91
         OM2=673.
         OM3=2396.49
         T0=300.
         Q2=1.4388
         XBAR=.5*(.5*X13+X23)
         OM12=.5*(.5*OM1+OM2)
         SDWEAK=0.
         SDSTRG=0.
         IF(OMEGA.LE.2395.) THEN
               ALPHA=2700.
               OMPRIM=OM3
               AA=ALPHA*B*Q2/(A*(1.-EXP(-OM3*Q2/T0))*(1.-EXP(-OM12*Q2
     1         /T0))**3*(1.+EXP(-OM12*Q2/T0))*(1.-EXP(-OMPRIM*Q2/T0)))
               BB=(1.-EXP(-Q2*OMEGA/TEMP))*(1.-EXP(-Q2*OM3/TEMP))*
     1         (1.-EXP(-OM12*Q2/TEMP))**3*(1.+EXP(-OM12*Q2/TEMP))
     2         *(1.-EXP(-Q2*OMPRIM/TEMP))
               CC=AA*BB*OMEGA/TEMP*T0/TEMP
               L202A: DO J=1,20
                  V=FLOAT(J-1)
                  IF(J/2*2.EQ.J)G=(V+1.)*(V+3.)/4.
                  IF(J/2*2.NE.J)G=(V+2.)*(V+2.)/4.
                  L201A: DO K=1,10
                     V3=FLOAT(K-1)
                     QQ=(V3+1.)*G*EXP(-(V3*OM3+V*OM12)*Q2/TEMP)
                     GAM=B-A*(V3+1.)
                     OMVV3=OM3+.5*X13+X23+2.*X33+XBAR*V+2.*X33*V3
                     DELTA=A*(OMEGA-OMVV3)
                     IF(GAM*GAM.LE.DELTA) CYCLE L202A
                     D=2.*(GAM*GAM-DELTA)**.5
                     OMVBAR=OMVV3*(1.-EXP(-OMVV3*Q2/TEMP))
                     F1=GAM-D/2
                     F2=GAM+D/2.
                     EE=Q2*GAM/(A*A*TEMP)
                     UNFLO1=EE*DELTA*(1.+.5*A/GAM)
                     IF(UNFLO1.LE.-78.) CYCLE L202A
                     UNFLO2=EE*2.*GAM*F1
                     IF(UNFLO2.GE.78.) CYCLE L202A
                     FF=EXP(EE*DELTA*(1.+.5*A/GAM))
                     SMINUS=CC*QQ/OMVBAR*ABS(F1)*FF*EXP(-EE*2.*GAM*F1)
                     UNFLO3=EE*2.*GAM*F2
                     IF(UNFLO3.GE.78.) THEN
                        SPLUS=0.
                        ELSE
                       SPLUS=CC*QQ/OMVBAR*ABS(F2)*FF*EXP(-EE*2.*GAM*F2)
                       ENDIF
                     GG=SDWEAK
                     SDWEAK=(SMINUS+SPLUS)/D+SDWEAK
                     TEST=(SDWEAK-GG)/SDWEAK
                     IF(TEST.LT..0001) CYCLE L202A
                     SDSTRG=(.5*G)**.5*(SMINUS**.5+SPLUS**.5)/D+SDSTRG
                  ENDDO L201A
               ENDDO L202A
               IF(SDWEAK.EQ.0.) THEN
                  SDWEAK=0.
                  GDINV=1.
                  GDDINV=1.
               ELSE
                  DINV=SDSTRG*SDSTRG/SDWEAK
                  GDINV=GC1*DINV
                  GDDINV=GD*DINV
C***  EXPRESS S/D AT STP, AS IS K IN NASA SP-3080
                  SDWEAK=SDWEAK*TEMP/273.
               ENDIF
            ELSE
CALCULATE ABSORPTION COEF. AND LINE SPACING PARAMETER FOR 2.7 MICRON BAND
               L=1
CONTRIBUTION TO 2.7 MICRON BAND FROM (000)-(021) AND (010)-(031) TRANS.
               ALPHA=28.5
               OMPRIM=2.*OM2+OM3
               L120A: DO
               AA=ALPHA*B*Q2/(A*(1.-EXP(-OM3*Q2/T0))*(1.-EXP(-OM12*Q2
     1         /T0))**3*(1.+EXP(-OM12*Q2/T0))*(1.-EXP(-OMPRIM*Q2/T0)))
               BB=(1.-EXP(-Q2*OMEGA/TEMP))*(1.-EXP(-Q2*OM3/TEMP))*
     1         (1.-EXP(-OM12*Q2/TEMP))**3*(1.+EXP(-OM12*Q2/TEMP))
     2         *(1.-EXP(-Q2*OMPRIM/TEMP))
               CC=AA*BB*OMEGA/TEMP*T0/TEMP
               L102A: DO J=1,20
                  V=FLOAT(J-1)
                  IF(J/2*2.EQ.J)G=(V+1.)*(V+3.)/4.
                  IF(J/2*2.NE.J)G=(V+2.)*(V+2.)/4.
                  VBAR1=-1.+(V+3.)*(V+4.)/(V+2.)/6.
                  IF(J/2*2.EQ.J)VBAR1=-1.+(V+5.)/6.
                  L101A: DO K=1,10
                     V3=FLOAT(K-1)
                    QQ=(V3+1)*G*EXP(-(V3*OM3+V*OM12)*Q2/TEMP)*(VBAR1+1.)
                     GAM=B-A*(V3+1.)
                     IF(L.EQ.2) THEN
                        OMVV3=3728.-5.*V-47.*V3
                        IF(V.EQ.0.)OMVV3=3715.-47.*V3
                       ELSE
                        OMVV3=3598.-18.*V-47.*V3
                        IF(V.EQ.0.)OMVV3=3613.-47.*V3
                     ENDIF
                     DELTA=A*(OMEGA-OMVV3)
                     IF(GAM*GAM.LE.DELTA) CYCLE L102A
                     D=2.*(GAM*GAM-DELTA)**.5
                     OMVBAR=OMVV3*(1.-EXP(-OMVV3*Q2/TEMP))
                     F1=GAM-D/2
                     F2=GAM+D/2.
                     EE=Q2*GAM/(A*A*TEMP)
                     UNFLO1=EE*DELTA*(1.+.5*A/GAM)
                     IF(UNFLO1.LE.-78.) CYCLE L102A
                     UNFLO2=EE*2.*GAM*F1
                     IF(UNFLO2.GE.78.) CYCLE L102A
                     FF=EXP(EE*DELTA*(1.+.5*A/GAM))
                     SMINUS=CC*QQ/OMVBAR*ABS(F1)*FF*EXP(-EE*2.*GAM*F1)
                     UNFLO3=EE*2.*GAM*F2
                     IF(UNFLO3.GE.78.) THEN
                        SPLUS=0.
                       ELSE
                       SPLUS=CC*QQ/OMVBAR*ABS(F2)*FF*EXP(-EE*2.*GAM*F2)
                     ENDIF
                     GG=SDWEAK
                     SDWEAK=(SMINUS+SPLUS)/D+SDWEAK
                     TEST=(SDWEAK-GG)/SDWEAK
                     IF(TEST.LT..0001) CYCLE L102A
                     SDSTRG=(.5*G)**.5*(SMINUS**.5+SPLUS**.5)/D+SDSTRG
                  ENDDO L101A
               ENDDO L102A
               IF(L.EQ.2) EXIT L120A
CONTRIBUTION TO 2.7 MICRON BAND FROM (000)-(101) AND (010)-(111) TRANS.
               ALPHA=42.3
               OMPRIM=OM1+OM3
               L=2
            ENDDO L120A
CALCULATE ABSORPTION COEF AND LINE SPACING PARAMETER FOR 4.3 MICRON BAND
            IF(SDWEAK.EQ.0.) THEN
               SDWEAK=0.
               GDINV=1.
               GDDINV=1.
              ELSE
               DINV=SDSTRG*SDSTRG/SDWEAK
               GDINV=GC1*DINV
               GDDINV=GD*DINV
C***EXPRESS S/D AT STP, AS IS K IN NASA SP-3080
               SDWEAK=SDWEAK*TEMP/273.
             ENDIF
           ENDIF
         ELSEIF((OMEGA.LE.1975.).AND.(OMEGA.GT.1100.)) THEN
            SDWEAK=0.
            GDINV=1.
            GDDINV=1.
         ELSEIF((OMEGA.LE.1100.).AND.(OMEGA.GT.880.)) THEN
CONTRIBUTION TO 10.0 MICRON BAND FROM (100)-(001) AND (020)-(001) TRANS.
            OM1=1354.91
            OM2=673.
            OM3=2396.49
            Q2=1.4388
            BCNT(1)=960.8
            BCNT(2)=1063.6
            OMA=OM3
            OMB=(OM1+2.*OM2)/2.
            T0=300.
            ATOT(1)=0.0219
            ATOT(2)=0.0532
            BE=0.391635
            DO K=1,2
               ATOT(K)=T0/TEMP*ATOT(K)*EXP(Q2*OMB*(1./T0-1./TEMP))
     1         *(1.-EXP(-Q2*(OMA-OMB)/TEMP))/(1.-EXP(-Q2*OMA/TEMP))
     2         /(1.-EXP(-OMB*Q2/TEMP))
            ENDDO
            SDWEAK=0.
            DO I=1,2
               SDWEAK=SDWEAK+ATOT(I)*Q2/(4.*BE*TEMP)*ABS(OMEGA-BCNT(I))
     1         *EXP(-Q2/(4.*BE*TEMP)*(OMEGA-BCNT(I))**2)
            ENDDO
            DINV=1./4./BE
            GDINV=GC1*DINV
            GDDINV=GD*DINV
C***EXPRESS S/D AT STP, AS IS IN NASA SP-3080
            SDWEAK=SDWEAK*TEMP/273.
         ELSEIF((OMEGA.LE.880.).AND.(OMEGA.GT.500.))  THEN
CONTRIBUTION TO 15.0 MICRON BAND FROM (000)-(010) TRANS.
            TTEMP=TEMP
            J=(OMEGA-495.)/5.
            W1=495.+5.*FLOAT(J)
            WW=(OMEGA-W1)/5
            IF(TEMP.GE.2400.)TEMP=2399.99
            IF(TEMP.LT.300.)TEMP=300.
            I=TEMP/300.
            IF((I.GT.2).AND.(TEMP.LT.1200.)) THEN
               I=2
               TT=(TEMP-600.)/600.
            ELSEIF((I.GT.5).AND.(TEMP.LT.2400.)) THEN
               I=5
               TT=(TEMP-1800.)/600.
            ELSE
               T1=FLOAT(I)*300.
               TT=(TEMP-T1)/300.
               IF(I.GT.4)I=I-1
               ENDIF
            TW=TT*WW
            SDWEAK=SD15(I,J)*(1.-TT-WW+TW)+SD15(I+1,J)*(TT-TW)
     1      +SD15(I,J+1)*(WW-TW)+SD15(I+1,J+1)*TW
            IF(SDWEAK.EQ.0.) THEN
               SDWEAK=0.
               GDINV=1.
               GDDINV=1.
               ELSE
CALCULATE LINE SPACING PARAMETER FOR 15.0 MICRON BAND
               DINV1=1.2
               DINV2=8.0
               DINV3=30.0
               TEMP1=300.0
               TEMP2=550.0
               TEMP3=830.0
               DINV=DINV1*(TEMP-TEMP2)*(TEMP-TEMP3)/(TEMP1-TEMP2)
     1         /(TEMP1-TEMP3)+DINV2*(TEMP-TEMP1)*(TEMP-TEMP3)
     2         /(TEMP2-TEMP1)/(TEMP2-TEMP3)+DINV3*(TEMP-TEMP1)
     3         *(TEMP-TEMP2)/(TEMP3-TEMP1)/(TEMP3-TEMP2)
               GDINV=GC1*DINV
               GDDINV=GD*DINV
              ENDIF
              TEMP = TTEMP  ! Line added by Jason Floyd, Aug 30, 2002
         ELSE
            SDWEAK=0.
            GDINV=1.
            GDDINV=1.
            ENDIF
         ENDIF
      END SUBROUTINE CO2
C
C****************************************************************************
C
      SUBROUTINE H2O(OMEGA,TEMP,GC2,SDWEAK,GDINV,GDDINV)
C
      INTEGER I,J
      REAL(EB) OMEGA,TEMP,GC2,SDWEAK,GDINV,GDDINV,WM,W1,WW,T1,TT,TW,
     .         D,B,DINV,TTEMP,GD
C
      IF (OMEGA.GE.9300..OR.OMEGA.LT.50.) THEN
         SDWEAK=0.
         GDINV=1.
         GDDINV=1.
        ELSE
         WM=18.
         GD=5.94E-6*OMEGA*(TEMP/(273.*WM))**.5
         J=(OMEGA-25.)/25.
         TTEMP=TEMP
         IF(TEMP.GE.2500.) TEMP=2499.99
         IF(TEMP.LT.300.) TEMP=300.
         I=TEMP/500. +1
         IF(I.EQ.2.AND.TEMP.LT.600.) I=1
         W1=25.+25.*FLOAT(J)
         WW=(OMEGA-W1)/25.
         IF(I.GT.2) THEN
            T1=FLOAT(I-1)*500.
            TT=(TEMP-T1)/500.
           ELSE
            IF(I.EQ.1) TT=(TEMP-300.)/300.
            IF(I.EQ.2) TT=(TEMP-600.)/400.
           ENDIF
         TW=TT*WW
         SDWEAK=SD(I,J)*(1.-TT-WW+TW)+SD(I+1,J)*(TT-TW)+SD(I,J+1)
     1   *(WW-TW)+SD(I+1,J+1)*TW
         D=-2.294+.3004E-02*TEMP-.366E-06*TEMP**2
         B=SIN(.0036*OMEGA-8.043)
         DINV=EXP(.7941*B+D)
C     DINV=EXP(0.00106*TEMP-1.21)
         GDINV=GC2*DINV
         GDDINV=GD*DINV
         TEMP=TTEMP
      ENDIF
      END SUBROUTINE H2O
C
C***********************************************************************
C
      SUBROUTINE CO(OMEGA,TEMP,GC4,SDWEAK,GDINV,GDDINV)
C
      INTEGER J
      REAL(EB) OMEGA,TEMP,GC4,SDWEAK,GDINV,GDDINV,AA,BB,CC,QQ,EE,FF,GG,
     .         SMINUS,SPLUS,SDSTRG,B,ALPHA,A,OME,WX,WY,OMPRIM,T0,
     .         Q2,WM,GD,V,GAM,OMV,DELTA,D,OMVBAR,F1,F2,TEST,DINV
C
      IF(OMEGA.LT.1600.OR.OMEGA.GT.2400.) THEN
         SDWEAK=0.
         GDINV=1.
         GDDINV=1.
      ELSE
         B=1.93139
         ALPHA=260.
         A=.017485
         OME=2170.21
         WX=13.461
         WY=.0308
         OMPRIM=OME-2.*WX+3.25*WY
         T0=300.
         Q2=1.4388
         WM=28.
         GD=5.94E-6*OMEGA*(TEMP/(273.*WM))**.5
         SDWEAK=1.D-99
         SDSTRG=1.D-99
         AA=ALPHA*B*Q2/(A*(1.-EXP(-OMPRIM*Q2/T0))**2)
         BB=(1.-EXP(-OMEGA*Q2/TEMP))*(1.-EXP(-OMPRIM*Q2/TEMP))**2
         CC=AA*BB*OMEGA/TEMP*T0/TEMP
         L101: DO J=1,20
         V=FLOAT(J-1)
         QQ=(V+1.)*EXP(-V*OME*Q2/TEMP)
         GAM=B-A*(V+1.)
         OMV=OME-2.*(V+1.)*WX+(3.*(V+1.)*(V+1.)+.25)*WY
         DELTA=A*(OMEGA-OMV)
         IF(GAM*GAM.LE.DELTA) EXIT L101
         D=2.*(GAM*GAM-DELTA)**.5
         OMVBAR=OMV*(1.-EXP(-OMV*Q2/TEMP))
         F1=GAM-D/2.
         F2=GAM+D/2.
         EE=Q2*GAM/(A*A*TEMP)
         FF=EXP(EE*DELTA*(1.+.5*A/GAM))
         SMINUS=CC*QQ/OMVBAR*ABS(F1)*FF*EXP(-EE*2.*GAM*F1)
         SPLUS=CC*QQ/OMVBAR*ABS(F2)*FF*EXP(-EE*2.*GAM*F2)
         GG=SDWEAK
         SDWEAK=(SMINUS+SPLUS)/D+SDWEAK
         TEST=(SDWEAK-GG)/SDWEAK
         IF(TEST.LT..0001) EXIT L101
         SDSTRG=(SMINUS**.5+SPLUS**.5)/D+SDSTRG
         ENDDO L101
         DINV=SDSTRG*SDSTRG/SDWEAK
         GDINV=GC4*DINV
         GDDINV=GD*DINV
C***EXPRESS S/D AT STP, AS IS K IN NASA SP-3080
         SDWEAK=SDWEAK*TEMP/273.
      ENDIF
      END SUBROUTINE CO
C
C****************************************************************************
C
      SUBROUTINE POD(OMEGA)
C
C
C***POD CALCULATES PARTICLE OPTICAL DEPTH, XPART, OF THE VOLUME
C   FRACTION OF SOOT PARTICLES IN GAS CLOUD.  RIN AND RIK ARE
C   THE REAL AND IMAGINARY PARTS OF THE INDEX OF REFRACTION.  THE
C   PARTICLES ARE ASSUMED TO BE IN THE RAYLEIGH LIMIT.
C
      INTEGER J
      REAL(EB) OMEGA,RIN,RIK,ABCO,FF,LAMBDA
      LAMBDA=10000./OMEGA
      RIN=1.6
      RIK=.5
c      FF=36.*3.1416*RIN*RIK/LAMBDA/((RIN*RIN-RIK*RIK+2.)**2 +
c     .   (2.*RIN*RIK)**2) ! OLD DALZELL AND SAOFIM MODEL
C     FF=7./LAMBDA
C
C     ABSORPTION COEF. IS BASED UPON MEASUREMENTS OF WIDMANN AND
C     MULHOLLAND
      FF=8.9/LAMBDA
      DO J=1,NPT
         ABCO=FF*SVF(J)*1.E6
         IF(J.EQ.1) THEN
            XPART(1)=ABCO*DD(1)
         ELSE
            XPART(J)=XPART(J-1)+ABCO*DD(J)
         ENDIF
      ENDDO
      END SUBROUTINE POD
C
C****************************************************************************
C
      SUBROUTINE FUEL(OMEGA,TEMP,PCH4,PTOT,GC3,SDWEAK,GDINV,GDDINV)
C
      INTEGER I,J,K
      REAL(EB) OMEGA,TEMP,PCH4,PTOT,GC3,SDWEAK,GDINV,GDDINV,PI,BE,Q2,
     .     WM,GD,OM1,OM2,OM3,OM4,COM1,COM2,COM3,COM4,DINV,PE,W1,SDB,
     .     SDA,SDC
C
      IF(OMEGA.GT.5000..OR.OMEGA.LT.1125.) THEN
C
         SDWEAK=0.0
         GDINV=1.
         GDDINV=1.
C
      ELSE
C
         PI=3.14159
         BE=5.2412
         Q2=1.4388
         WM=16.
         GD=5.94E-6*OMEGA*(TEMP/(273.*WM))**.5
         IF(OMEGA.GE.3400.) THEN
C
C CONTRIBUTION TO 2.4 MICRON BAND FROM (0000)-(0110), (0000)-(0011),
C (0000)-(1001), AND (0000)-(0102) TRANS.  THE INTEGRATED BAND INTENSITIES
C OF VINCENT-GEISSE (ANNALES DE PHYSIQUE SER.12, V. 10, 1955) HAVE
C BEEN MULTIPLIED BY A FACTOR OF 4 AND THE LINE SPACING IS THAT
C OF V4 FROM GRAY AND PENNER (JQSRT V. 5, 1965).
C
            OM1=2914.2
            OM2=1526.0
            OM3=3020.3
            OM4=1306.2
            BCNT(1)=4123.0
            BCNT(2)=4216.3
            BCNT(3)=4313.2
            BCNT(4)=4546.0
            COM1=OM2+2.*OM4
            COM2=OM1+OM4
            COM3=OM3+OM4
            COM4=OM2+OM3
            ATOT(1)=.64*273./TEMP**(1.-EXP(-Q2*COM1/TEMP))/
     2      (1.-EXP(-Q2*OM2/TEMP))/(1.-EXP(-Q2*OM4/TEMP))**2
            ATOT(2)=17.6*273./TEMP*(1.-EXP(-Q2*COM2/TEMP))/
     2      (1.-EXP(-Q2*OM1/TEMP))/(1.-EXP(-Q2*OM4/TEMP))
            ATOT(3)=14.8*273./TEMP*(1.-EXP(-Q2*COM3/TEMP))/
     2      (1.-EXP(-Q2*OM3/TEMP))/(1.-EXP(-Q2*OM4/TEMP))
            ATOT(4)=5.04*273./TEMP*(1.-EXP(-Q2*COM4/TEMP))/
     2      (1.-EXP(-Q2*OM2/TEMP))/(1.-EXP(-Q2*OM3/TEMP))
            DINV=1./5.74
            GDINV=GC3*DINV
            GDDINV=GD*DINV
            SDWEAK=0.0
            DO I=1,4
               SDWEAK=SDWEAK+2.*(OMEGA-BCNT(I))**2*(Q2*BE/TEMP)**1.5
     2         *ATOT(I)/PI**0.5*DINV**3*EXP(-Q2*BE*DINV**2/TEMP
     3         *(OMEGA-BCNT(I))**2)
            ENDDO
            SDWEAK=SDWEAK*(TEMP/273.)
C
           ELSE
            PE=PTOT+.3*PCH4
            IF(OMEGA.GE.2625.) THEN
C
C CONTRIBUTION TO 3.3 MICRON BAND FROM (0000)-(0010) TRANS.
C REFER TO BROSMER AND TIEN, JQSRT V. 33, P. 521
C
              GDINV=.00734*PE*(273./TEMP)**.5*EXP(1.02*(TEMP-273.)/273.)
               GDDINV=GD/9.4
               J=(OMEGA-2600.)/25.
               W1=2600.+25.*FLOAT(J)
               SDB=SD3(2,J)+(OMEGA-W1)/25.*(SD3(2,J+1)-SD3(2,J))
               IF(TEMP.GT.600.) THEN
                  SDC=SD3(3,J)+(OMEGA-W1)/25.*(SD3(3,J+1)-SD3(3,J))
                  SDWEAK=SDB+(TEMP-600.)/250.*(SDC-SDB)
                  IF(SDWEAK.LT.0.)SDWEAK=0.
               ELSE
                  SDA=SD3(1,J)+(OMEGA-W1)/25.*(SD3(1,J+1)-SD3(1,J))
                  SDWEAK=SDA+(TEMP-290.)/310.*(SDB-SDA)
                  IF(SDWEAK.LT.0.)SDWEAK=0.
              ENDIF
C
            ELSEIF(OMEGA.GT.1450.) THEN
C
               SDWEAK=0.0
               GDINV=1.
               GDDINV=1.
C
            ELSE
C
C CONTRIBUTION TO 7.7 MICRON BAND FROM (0000)-(0001) TRANS.
C REFER TO BROSMER AND TIEN, JQSRT V. 33, P. 521.
C
               GDINV=.0243*PE*(TEMP/273.)**.8
               GDDINV=GD/5.1
               J=(OMEGA-1100.)/25.
               W1=1100.+25.*FLOAT(J)
               SDB=SD7(2,J)+(OMEGA-W1)/25.*(SD7(2,J+1)-SD7(2,J))
               IF(TEMP.GT.600.) THEN
                  SDC=SD7(3,J)+(OMEGA-W1)/25.*(SD7(3,J+1)-SD7(3,J))
                  SDWEAK=SDB+(TEMP-600.)/250.*(SDC-SDB)
                  IF(SDWEAK.LT.0.)SDWEAK=0.
                 ELSE
                  SDA=SD7(1,J)+(OMEGA-W1)/25.*(SD7(1,J+1)-SD7(1,J))
                  SDWEAK=SDA+(TEMP-290.)/310.*(SDB-SDA)
                  IF(SDWEAK.LT.0.)SDWEAK=0.
                 ENDIF
              ENDIF
C
         ENDIF
       ENDIF
      END SUBROUTINE FUEL
C
C*******************************************************************************
C
      REAL(EB) FUNCTION PLANCK(A,B)
      REAL (EB) Q1,Q2,OVRFLO,A,B
C     COMPUTES BLACKBODY FUNCTION IN UNITS OF W/M-2/MICRON/SR
      Q1=.59544E8
      Q2=14388.

      IF(A.EQ.0.) THEN 
         PLANCK=0.
      ELSE
         OVRFLO=Q2/A/B
         IF(OVRFLO.GT.38.) THEN
            PLANCK=0.
         ELSE
            PLANCK=2.*Q1*(B**(-5))/(EXP(Q2/A/B)-1.)
         ENDIF
      ENDIF
      END FUNCTION PLANCK
C
C
      SUBROUTINE RCALLOC
C     
      INTEGER IZERO
C
      ALLOCATE(SVF(50),STAT=IZERO)
      ALLOCATE(RCT(50),STAT=IZERO)
      ALLOCATE(DD(50),STAT=IZERO)
      ALLOCATE(XPART(50),STAT=IZERO)
      ALLOCATE(P(6,50),STAT=IZERO)
      ALLOCATE(SPECIE(5),STAT=IZERO)
      ALLOCATE(QW(600),STAT=IZERO)
      ALLOCATE(TTAU(600),STAT=IZERO)
      ALLOCATE(XTOT(50),STAT=IZERO)
      ALLOCATE(XT(600),STAT=IZERO)
      ALLOCATE(XSTAR(50),STAT=IZERO)
      ALLOCATE(X(4,50),STAT=IZERO)
      ALLOCATE(TAU(50),STAT=IZERO)
      ALLOCATE(AC(50),STAT=IZERO)
      ALLOCATE(AD(50),STAT=IZERO)
      ALLOCATE(GC(4,50),STAT=IZERO)
      ALLOCATE(AMBDA(600),STAT=IZERO)
      ALLOCATE(TAUS(50),STAT=IZERO)
      ALLOCATE(UUU(4,50),STAT=IZERO)
      ALLOCATE(AB(600),STAT=IZERO)
      ALLOCATE(PKPA(50),STAT=IZERO)
      ALLOCATE(ATOT(4),STAT=IZERO)
      ALLOCATE(BCNT(4),STAT=IZERO)
      ALLOCATE(GAMMA(4,7),STAT=IZERO)
      ALLOCATE(SD15(6,80),STAT=IZERO)
      ALLOCATE(SD(6,376),STAT=IZERO)
      ALLOCATE(SD7(3,16),STAT=IZERO)
      ALLOCATE(SD3(3,32),STAT=IZERO)
C
C  Initialize SD Array
C
C TEMP,K= 300     600      1000      1500      2000      2500       
C
      SD(1:6,1:8) = RESHAPE ((/   ! 50-225
     . .950E+00, .103E+00, .420E-01, .114E-01, .450E-02, .300E-02, 
     . .208E+01, .365E+00, .113E+00, .375E-01, .195E-01, .134E-01, 
     . .368E+01, .990E+00, .300E+00, .104E+00, .577E-01, .365E-01,   
     . .650E+01, .201E+01, .650E+00, .214E+00, .128E+00, .845E-01,    
     . .825E+01, .325E+01, .121E+01, .415E+00, .260E+00, .168E+00,   
     . .870E+01, .452E+01, .189E+01, .765E+00, .450E+00, .289E+00,   
     . .810E+01, .540E+01, .261E+01, .126E+01, .695E+00, .460E+00,   
     . .682E+01, .600E+01, .337E+01, .179E+01, .101E+01, .679E+00/), 
     . (/6,8/))
      SD(1:6,9:16) = RESHAPE ((/   ! 250-425
     . .493E+01, .622E+01, .407E+01, .230E+01, .135E+01, .935E+00,     
     . .316E+01, .592E+01, .456E+01, .281E+01, .172E+01, .122E+01,    
     . .199E+01, .528E+01, .479E+01, .328E+01, .213E+01, .149E+01,     
     . .113E+01, .450E+01, .484E+01, .361E+01, .249E+01, .179E+01,     
     . .585E+00, .370E+01, .471E+01, .383E+01, .284E+01, .208E+01,     
     . .293E+00, .289E+01, .443E+01, .394E+01, .312E+01, .237E+01,     
     . .138E+00, .205E+01, .400E+01, .396E+01, .330E+01, .260E+01,     
     . .620E-01, .143E+01, .347E+01, .388E+01, .341E+01, .280E+01/),   
     . (/6,8/))
      SD(1:6,17:24) = RESHAPE ((/  ! 450-625
     . .255E-01, .950E+00, .292E+01, .370E+01, .345E+01, .295E+01,     
     . .940E-02, .610E+00, .236E+01, .343E+01, .342E+01, .304E+01,     
     . .340E-02, .386E+00, .188E+01, .310E+01, .334E+01, .309E+01,     
     . .105E-02, .236E+00, .145E+01, .274E+01, .319E+01, .307E+01,     
     . .350E-03, .144E+00, .110E+01, .238E+01, .300E+01, .301E+01,    
     . .126E-03, .820E-01, .818E+00, .204E+01, .276E+01, .289E+01,     
     . .430E-04, .445E-01, .598E+00, .174E+01, .248E+01, .275E+01,    
     . .150E-04, .242E-01, .427E+00, .145E+01, .222E+01, .260E+01/),  
     . (/6,8/))
      SD(1:6,25:32) = RESHAPE ((/  ! 650-825
     1 .510E-05, .127E-01, .294E+00, .118E+01, .195E+01, .241E+01,     
     1 .170E-05, .630E-02, .200E+00, .950E+00, .169E+01, .221E+01,     
     1 .570E-06, .300E-02, .134E+00, .748E+00, .146E+01, .200E+01,     
     1 .195E-06, .140E-02, .902E-01, .580E+00, .124E+01, .178E+01,     
     1 .680E-07, .620E-03, .590E-01, .443E+00, .103E+01, .156E+01,     
     1 .385E-07, .275E-03, .450E-01, .330E+00, .845E+00, .136E+01,     
     1 .670E-07, .113E-03, .355E-01, .242E+00, .695E+00, .117E+01,     
     1 .113E-06, .500E-04, .289E-01, .174E+00, .560E+00, .100E+01/),   
     1 (/6,8/))
      SD(1:6,33:40) = RESHAPE ((/  ! 850-1025
     1 .195E-06, .230E-04, .245E-01, .123E+00, .450E+00, .855E+00,     
     1 .328E-06, .103E-04, .214E-01, .100E+00, .357E+00, .718E+00,     
     1 .560E-06, .460E-05, .189E-01, .830E-01, .278E+00, .595E+00,     
     1 .950E-06, .205E-05, .174E-01, .730E-01, .239E+00, .492E+00,     
     1 .160E-05, .140E-05, .166E-01, .665E-01, .211E+00, .405E+00,     
     1 .275E-05, .350E-05, .165E-01, .630E-01, .195E+00, .352E+00,     
     1 .470E-05, .850E-05, .167E-01, .620E-01, .190E+00, .312E+00,    
     1 .810E-05, .215E-04, .175E-01, .630E-01, .191E+00, .289E+00/),   
     1 (/6,8/))
      SD(1:6,41:48) = RESHAPE ((/  ! 1050-1225
     1 .136E-04, .570E-04, .188E-01, .675E-01, .194E+00, .281E+00,     
     1 .235E-04, .150E-03, .208E-01, .745E-01, .202E+00, .283E+00,     
     1 .400E-04, .380E-03, .233E-01, .865E-01, .223E+00, .314E+00,     
     1 .680E-04, .950E-03, .268E-01, .122E+00, .260E+00, .380E+00,     
     1 .120E-03, .245E-02, .343E-01, .176E+00, .328E+00, .461E+00,     
     1 .200E-03, .620E-02, .638E-01, .251E+00, .411E+00, .511E+00,     
     1 .365E-03, .140E-01, .107E+00, .330E+00, .458E+00, .542E+00,     
     1 .680E-03, .330E-01, .166E+00, .405E+00, .487E+00, .571E+00/),   
     1 (/6,8/))
      SD(1:6,49:56) = RESHAPE ((/  ! 1250-1425
     1 .130E-02, .635E-01, .244E+00, .459E+00, .535E+00, .557E+00,     
     1 .250E-02, .123E+00, .341E+00, .477E+00, .502E+00, .562E+00,     
     1 .500E-02, .212E+00, .407E+00, .547E+00, .531E+00, .514E+00,     
     1 .103E-01, .285E+00, .489E+00, .592E+00, .497E+00, .486E+00,     
     1 .219E-01, .328E+00, .491E+00, .558E+00, .489E+00, .485E+00,     
     1 .485E-01, .345E+00, .505E+00, .521E+00, .477E+00, .484E+00,     
     1 .114E+00, .361E+00, .538E+00, .563E+00, .503E+00, .502E+00,     
     1 .249E+00, .460E+00, .621E+00, .624E+00, .538E+00, .538E+00/),   
     1 (/6,8/))
      SD(1:6,57:64) = RESHAPE ((/  ! 1450-1625
     1 .397E+00, .569E+00, .749E+00, .768E+00, .581E+00, .565E+00,     
     1 .418E+00, .627E+00, .824E+00, .849E+00, .640E+00, .594E+00,     
     1 .108E+01, .125E+01, .113E+01, .940E+00, .807E+00, .663E+00,     
     1 .165E+01, .155E+01, .118E+01, .670E+00, .562E+00, .483E+00,     
     1 .142E+01, .675E+00, .557E+00, .349E+00, .276E+00, .263E+00,     
     1 .451E+00, .202E+00, .132E+00, .118E+00, .134E+00, .156E+00,     
     1 .603E-01, .538E-01, .863E-01, .112E+00, .120E+00, .125E+00,     
     1 .501E+00, .252E+00, .118E+00, .112E+00, .131E+00, .140E+00/),   
     1 (/6,8/))
      SD(1:6,65:72) = RESHAPE ((/  ! 1650-1825
     1 .730E+00, .430E+00, .237E+00, .191E+00, .171E+00, .170E+00,     
     1 .149E+01, .506E+00, .294E+00, .238E+00, .210E+00, .201E+00,     
     1 .100E+01, .553E+00, .434E+00, .340E+00, .260E+00, .220E+00,     
     1 .802E+00, .658E+00, .528E+00, .411E+00, .300E+00, .240E+00,     
     1 .580E+00, .527E+00, .460E+00, .378E+00, .322E+00, .283E+00,     
     1 .330E+00, .403E+00, .430E+00, .356E+00, .318E+00, .270E+00,     
     1 .250E+00, .393E+00, .405E+00, .342E+00, .301E+00, .275E+00,     
     1 .147E+00, .249E+00, .313E+00, .318E+00, .291E+00, .268E+00/),   
     1 (/6,8/))
      SD(1:6,73:80) = RESHAPE ((/  ! 1850-2025
     1 .910E-01, .252E+00, .298E+00, .295E+00, .269E+00, .253E+00,     
     1 .580E-01, .158E+00, .214E+00, .244E+00, .244E+00, .245E+00,     
     1 .370E-01, .113E+00, .184E+00, .218E+00, .214E+00, .218E+00,     
     1 .244E-01, .118E+00, .156E+00, .188E+00, .195E+00, .200E+00,    
     1 .162E-01, .606E-01, .976E-01, .141E+00, .166E+00, .179E+00,    
     1 .112E-01, .425E-01, .903E-01, .133E+00, .148E+00, .156E+00,    
     1 .780E-02, .400E-01, .765E-01, .112E+00, .129E+00, .137E+00,    
     1 .540E-02, .352E-01, .647E-01, .876E-01, .110E+00, .118E+00/),  
     1 (/6,8/))
      SD(1:6,81:88) = RESHAPE ((/  ! 2050-2225
     1 .380E-02, .252E-01, .507E-01, .705E-01, .888E-01, .100E+00,     
     1 .260E-02, .179E-01, .377E-01, .546E-01, .724E-01, .828E-01,     
     1 .180E-02, .123E-01, .294E-01, .443E-01, .608E-01, .686E-01,     
     1 .127E-02, .850E-02, .212E-01, .378E-01, .579E-01, .640E-01,     
     1 .880E-03, .680E-02, .152E-01, .275E-01, .449E-01, .521E-01,     
     1 .620E-02, .400E-02, .107E-01, .214E-01, .374E-01, .453E-01,     
     1 .480E-03, .298E-02, .931E-02, .189E-01, .329E-01, .403E-01,     
     1 .405E-03, .175E-02, .696E-02, .152E-01, .295E-01, .365E-01/),   
     1 (/6,8/))
      SD(1:6,89:96) = RESHAPE ((/  ! 2250-2425
     1 .321E-03, .120E-02, .452E-02, .101E-01, .252E-01, .331E-01,     
     1 .229E-03, .721E-03, .364E-02, .930E-02, .225E-01, .305E-01,     
     1 .195E-03, .544E-03, .318E-02, .750E-02, .202E-01, .284E-01,     
     1 .154E-03, .375E-03, .185E-02, .603E-02, .175E-01, .269E-01,     
     1 .101E-03, .263E-03, .119E-02, .480E-02, .156E-01, .253E-01,     
     1 .852E-04, .185E-03, .909E-03, .360E-02, .133E-01, .241E-01,     
     1 .763E-04, .137E-03, .711E-03, .316E-02, .122E-01, .237E-01,     
     1 .615E-04, .126E-03, .610E-03, .257E-02, .101E-01, .218E-01/),   
     1 (/6,8/))
      SD(1:6,97:104) = RESHAPE ((/  ! 2450-2625
     1 .480E-04, .113E-03, .518E-03, .201E-02, .920E-02, .200E-01,     
     1 .372E-04, .106E-03, .435E-03, .168E-02, .785E-02, .183E-01,     
     1 .355E-04, .101E-03, .376E-03, .168E-02, .669E-02, .166E-01,     
     1 .358E-04, .990E-04, .366E-03, .167E-02, .651E-02, .156E-01,     
     1 .389E-04, .102E-03, .376E-03, .167E-02, .641E-02, .152E-01,     
     1 .422E-04, .106E-03, .373E-03, .168E-02, .656E-02, .150E-01,     
     1 .521E-04, .111E-03, .371E-03, .170E-02, .673E-02, .152E-01,     
     1 .646E-04, .121E-03, .384E-03, .179E-02, .798E-02, .179E-01/),   
     1 (/6,8/))
      SD(1:6,105:112) = RESHAPE ((/  ! 2650-2825
     1 .742E-04, .129E-03, .479E-03, .201E-02, .788E-02, .175E-01,     
     1 .953E-04, .165E-03, .544E-03, .249E-02, .945E-02, .204E-01,     
     1 .101E-03, .190E-03, .761E-03, .324E-02, .106E-01, .231E-01,     
     1 .147E-03, .272E-03, .892E-03, .441E-02, .125E-01, .257E-01,     
     1 .195E-03, .326E-03, .100E-02, .499E-02, .147E-01, .295E-01,     
     1 .261E-03, .421E-03, .145E-02, .568E-02, .161E-01, .306E-01,     
     1 .305E-03, .515E-03, .195E-02, .754E-02, .185E-01, .363E-01,     
     1 .362E-03, .645E-03, .237E-02, .830E-02, .205E-01, .373E-01/),   
     1 (/6,8/))
      SD(1:6,113:120) = RESHAPE ((/  ! 2850-3025
     1 .507E-03, .850E-03, .274E-02, .888E-02, .234E-01, .431E-01,     
     1 .799E-03, .118E-02, .322E-02, .110E-01, .262E-01, .451E-01,     
     1 .935E-03, .160E-02, .386E-02, .126E-01, .292E-01, .530E-01,     
     1 .108E-02, .231E-02, .451E-02, .140E-01, .306E-01, .536E-01,     
     1 .192E-02, .271E-02, .563E-02, .159E-01, .357E-01, .629E-01,     
     1 .263E-02, .300E-02, .625E-02, .179E-01, .385E-01, .666E-01,     
     1 .295E-02, .330E-02, .701E-02, .203E-01, .460E-01, .782E-01,     
     1 .310E-02, .370E-02, .846E-02, .220E-01, .519E-01, .889E-01/),   
     1 (/6,8/))
      SD(1:6,121:128) = RESHAPE ((/  ! 3050-3225
     1 .340E-02, .400E-02, .969E-02, .279E-01, .662E-01, .109E+00,     
     1 .730E-02, .450E-02, .111E-01, .272E-01, .676E-01, .109E+00,     
     1 .900E-02, .480E-02, .137E-01, .372E-01, .864E-01, .133E+00,     
     1 .100E-02, .510E-02, .162E-01, .471E-01, .100E+00, .142E+00,     
     1 .640E-03, .550E-02, .205E-01, .530E-01, .122E+00, .168E+00,     
     1 .160E-02, .600E-02, .247E-01, .633E-01, .135E+00, .177E+00,     
     1 .330E-02, .700E-02, .283E-01, .770E-01, .153E+00, .185E+00,     
     1 .410E-02, .860E-02, .376E-01, .914E-01, .166E+00, .206E+00/),   
     1 (/6,8/))
      SD(1:6,129:136) = RESHAPE ((/  ! 3250-3425
     1 .410E-02, .103E-01, .514E-01, .117E+00, .194E+00, .228E+00,     
     1 .290E-02, .129E-01, .664E-01, .147E+00, .220E+00, .254E+00,     
     1 .220E-02, .161E-01, .834E-01, .171E+00, .237E+00, .263E+00,     
     1 .220E-02, .212E-01, .103E+00, .201E+00, .268E+00, .283E+00,     
     1 .250E-02, .285E-01, .135E+00, .240E+00, .295E+00, .295E+00,     
     1 .310E-02, .385E-01, .169E+00, .272E+00, .312E+00, .301E+00,     
     1 .420E-02, .540E-01, .214E+00, .309E+00, .329E+00, .307E+00,     
     1 .600E-02, .770E-01, .267E+00, .343E+00, .332E+00, .314E+00/),   
     1 (/6,8/))
      SD(1:6,137:144) = RESHAPE ((/  ! 3450-3625
     1 .940E-02, .117E+00, .333E+00, .372E+00, .344E+00, .303E+00,     
     1 .165E-01, .173E+00, .365E+00, .385E+00, .353E+00, .300E+00,     
     1 .360E-01, .258E+00, .438E+00, .393E+00, .315E+00, .288E+00,     
     1 .720E-01, .375E+00, .510E+00, .409E+00, .294E+00, .271E+00,     
     1 .133E+00, .401E+00, .499E+00, .390E+00, .281E+00, .257E+00,     
     1 .215E+00, .500E+00, .443E+00, .341E+00, .254E+00, .230E+00,     
     1 .318E+00, .450E+00, .346E+00, .286E+00, .245E+00, .219E+00,     
     1 .442E+00, .400E+00, .354E+00, .279E+00, .233E+00, .216E+00/),   
     1 (/6,8/))
      SD(1:6,145:152) = RESHAPE ((/  ! 3650-3825
     1 .473E+00, .405E+00, .347E+00, .281E+00, .238E+00, .219E+00,     
     1 .568E+00, .501E+00, .423E+00, .315E+00, .243E+00, .218E+00,     
     1 .690E+00, .708E+00, .673E+00, .432E+00, .268E+00, .189E+00,     
     1 .617E+00, .831E+00, .566E+00, .320E+00, .194E+00, .123E+00,     
     1 .181E+01, .520E+00, .200E+00, .131E+00, .124E+00, .107E+00,     
     1 .136E+00, .124E+00, .120E+00, .119E+00, .115E+00, .115E+00,     
     1 .455E+00, .298E+00, .167E+00, .129E+00, .123E+00, .112E+00,     
     1 .760E+00, .503E+00, .242E+00, .154E+00, .129E+00, .127E+00/),   
     1 (/6,8/))
      SD(1:6,153:160) = RESHAPE ((/  ! 3850-4025
     1 .836E+00, .584E+00, .277E+00, .184E+00, .161E+00, .145E+00,     
     1 .840E+00, .728E+00, .422E+00, .236E+00, .197E+00, .167E+00,     
     1 .505E+00, .500E+00, .379E+00, .276E+00, .227E+00, .192E+00,     
     1 .117E+00, .400E+00, .423E+00, .315E+00, .243E+00, .202E+00,     
     1 .460E-01, .300E+00, .358E+00, .290E+00, .230E+00, .202E+00,     
     1 .183E-01, .205E+00, .269E+00, .235E+00, .195E+00, .192E+00,     
     1 .730E-02, .135E+00, .186E+00, .179E+00, .159E+00, .168E+00,     
     1 .557E-02, .790E-01, .113E+00, .124E+00, .124E+00, .134E+00/),   
     1 (/6,8/))
      SD(1:6,161:168) = RESHAPE ((/  ! 4050-4225
     1 .283E-02, .415E-01, .662E-01, .886E-01, .103E+00, .106E+00,     
     1 .226E-02, .197E-01, .367E-01, .594E-01, .801E-01, .879E-01,     
     1 .155E-02, .860E-02, .211E-01, .395E-01, .503E-01, .610E-01,     
     1 .103E-02, .521E-02, .119E-01, .246E-01, .354E-01, .480E-01,     
     1 .821E-03, .365E-02, .759E-02, .166E-01, .258E-01, .370E-01,     
     1 .752E-03, .183E-02, .445E-02, .100E-01, .179E-01, .268E-01,     
     1 .429E-03, .141E-02, .354E-02, .821E-02, .142E-01, .212E-01,     
     1 .327E-03, .902E-03, .209E-02, .588E-02, .112E-01, .172E-01/),   
     1 (/6,8/))
      SD(1:6,169:176) = RESHAPE ((/  ! 4250-4425
     1 .225E-03, .685E-03, .189E-02, .512E-02, .101E-01, .164E-01,     
     1 .186E-03, .551E-03, .156E-02, .366E-02, .812E-02, .136E-01,     
     1 .173E-03, .472E-03, .139E-02, .306E-02, .661E-02, .115E-01,     
     1 .138E-03, .395E-03, .110E-02, .272E-02, .587E-02, .104E-01,     
     1 .900E-04, .270E-03, .968E-03, .222E-02, .497E-02, .921E-02,     
     1 .752E-04, .233E-03, .744E-03, .208E-02, .466E-02, .876E-02,     
     1 .618E-04, .175E-03, .638E-03, .185E-02, .465E-02, .914E-02,     
     1 .504E-04, .134E-03, .499E-03, .174E-02, .455E-02, .935E-02/),   
     1 (/6,8/))
      SD(1:6,177:184) = RESHAPE ((/  ! 4450-4625
     1 .375E-04, .123E-03, .485E-03, .182E-02, .456E-02, .971E-02,     
     1 .305E-04, .892E-04, .338E-03, .134E-02, .460E-02, .104E-01,     
     1 .257E-04, .790E-04, .329E-03, .154E-02, .477E-02, .112E-01,     
     1 .242E-04, .740E-04, .308E-03, .135E-02, .497E-02, .122E-01,     
     1 .215E-04, .653E-04, .282E-03, .131E-02, .521E-02, .133E-01,     
     1 .218E-04, .660E-04, .272E-03, .152E-02, .573E-02, .148E-01,     
     1 .215E-04, .671E-04, .268E-03, .134E-02, .607E-02, .159E-01,     
     1 .217E-04, .695E-04, .285E-03, .161E-02, .677E-02, .173E-01/),   
     1 (/6,8/))
      SD(1:6,185:192) = RESHAPE ((/  ! 4650-4825
     1 .219E-04, .722E-04, .297E-03, .169E-02, .783E-02, .197E-01,     
     1 .226E-04, .771E-04, .341E-03, .236E-02, .925E-02, .226E-01,     
     1 .250E-04, .815E-04, .387E-03, .286E-02, .106E-01, .250E-01,    
     1 .280E-04, .845E-04, .420E-03, .357E-02, .124E-01, .276E-01,     
     1 .351E-04, .192E-03, .470E-03, .467E-02, .166E-01, .313E-01,     
     1 .435E-04, .200E-03, .105E-02, .566E-02, .185E-01, .341E-01,     
     1 .522E-04, .233E-03, .129E-02, .736E-02, .229E-01, .378E-01,     
     1 .673E-04, .306E-03, .183E-02, .982E-02, .258E-01, .404E-01/),   
     1 (/6,8/))
      SD(1:6,193:200) = RESHAPE ((/  ! 4850-5025
     1 .886E-04, .399E-03, .246E-02, .128E-01, .302E-01, .430E-01,     
     1 .113E-03, .618E-03, .346E-02, .161E-01, .358E-01, .459E-01,     
     1 .174E-03, .825E-03, .441E-02, .200E-01, .417E-01, .493E-01,     
     1 .265E-03, .163E-02, .777E-02, .245E-01, .450E-01, .507E-01,     
     1 .355E-03, .200E-02, .978E-02, .317E-01, .492E-01, .527E-01,     
     1 .538E-03, .271E-02, .167E-01, .401E-01, .503E-01, .523E-01,     
     1 .651E-03, .301E-02, .264E-01, .467E-01, .520E-01, .526E-01,     
     1 .987E-03, .530E-02, .321E-01, .499E-01, .523E-01, .510E-01/),   
     1 (/6,8/))
      SD(1:6,201:208) = RESHAPE ((/  ! 5050-5225
     1 .135E-02, .860E-02, .389E-01, .528E-01, .513E-01, .492E-01,    
     1 .226E-02, .130E-01, .472E-01, .559E-01, .500E-01, .469E-01,     
     1 .431E-02, .198E-01, .526E-01, .557E-01, .480E-01, .452E-01,     
     1 .628E-02, .282E-01, .488E-01, .495E-01, .451E-01, .430E-01,     
     1 .900E-02, .390E-01, .471E-01, .449E-01, .430E-01, .423E-01,     
     1 .180E-01, .462E-01, .412E-01, .391E-01, .403E-01, .415E-01,     
     1 .348E-01, .710E-01, .402E-01, .360E-01, .384E-01, .414E-01,     
     1 .718E-01, .590E-01, .399E-01, .360E-01, .376E-01, .420E-01/),   
     1 (/6,8/))
      SD(1:6,209:216) = RESHAPE ((/  ! 5250-5425
     1 .111E+00, .368E-01, .340E-01, .369E-01, .409E-01, .454E-01,     
     1 .329E-01, .285E-01, .365E-01, .423E-01, .461E-01, .482E-01,     
     1 .281E-01, .270E-01, .432E-01, .505E-01, .529E-01, .511E-01,     
     1 .121E+00, .422E-01, .589E-01, .598E-01, .572E-01, .544E-01,     
     1 .139E+00, .105E+00, .844E-01, .687E-01, .593E-01, .560E-01,     
     1 .774E-01, .710E-01, .683E-01, .618E-01, .556E-01, .534E-01,     
     1 .858E-01, .483E-01, .579E-01, .547E-01, .503E-01, .495E-01,     
     1 .985E-01, .575E-01, .589E-01, .510E-01, .451E-01, .449E-01/),   
     1 (/6,8/))
      SD(1:6,217:224) = RESHAPE ((/  ! 5450-5625
     1 .996E-01, .682E-01, .539E-01, .489E-01, .454E-01, .446E-01,     
     1 .680E-01, .680E-01, .548E-01, .495E-01, .460E-01, .458E-01,     
     1 .325E-01, .520E-01, .515E-01, .483E-01, .449E-01, .454E-01,     
     1 .150E-01, .350E-01, .451E-01, .464E-01, .452E-01, .449E-01,     
     1 .620E-02, .238E-01, .369E-01, .408E-01, .414E-01, .417E-01,     
     1 .270E-02, .158E-01, .282E-01, .339E-01, .366E-01, .384E-01,     
     1 .113E-02, .101E-01, .203E-01, .263E-01, .303E-01, .333E-01,     
     1 .829E-03, .590E-02, .148E-01, .206E-01, .247E-01, .295E-01/),   
     1 (/6,8/))
      SD(1:6,225:232) = RESHAPE ((/  ! 5650-5825
     1 .365E-03, .310E-02, .969E-02, .154E-01, .203E-01, .258E-01,     
     1 .240E-03, .130E-02, .589E-02, .112E-01, .164E-01, .222E-01,     
     1 .158E-03, .400E-03, .417E-02, .850E-02, .134E-01, .190E-01,     
     1 .103E-03, .262E-03, .208E-02, .594E-02, .109E-01, .162E-01,     
     1 .741E-04, .181E-03, .142E-02, .455E-02, .907E-02, .141E-01,     
     1 .625E-04, .135E-03, .816E-03, .316E-02, .698E-02, .121E-01,     
     1 .499E-04, .111E-03, .624E-03, .230E-02, .551E-02, .102E-01,     
     1 .325E-04, .677E-04, .425E-03, .124E-02, .385E-02, .818E-02/),   
     1 (/6,8/))
      SD(1:6,233:240) = RESHAPE ((/  ! 5850-6025
     1 .231E-04, .563E-04, .278E-03, .986E-03, .290E-02, .672E-02,    
     1 .165E-04, .481E-04, .247E-03, .944E-03, .253E-02, .612E-02,           
     1 .126E-04, .432E-04, .241E-03, .886E-03, .220E-02, .582E-02,          
     1 .118E-04, .420E-04, .235E-03, .847E-03, .209E-02, .571E-02,          
     1 .110E-04, .408E-04, .226E-03, .812E-03, .221E-02, .604E-02,         
     1 .101E-04, .400E-04, .213E-03, .805E-03, .239E-02, .641E-02,        
     1 .983E-05, .395E-04, .186E-03, .801E-03, .247E-02, .691E-02,       
     1 .979E-05, .401E-04, .193E-03, .805E-03, .260E-02, .732E-02/),    
     1 (/6,8/))
      SD(1:6,241:248) = RESHAPE ((/  ! 6050-6225
     1 .976E-05, .410E-04, .201E-03, .814E-03, .285E-02, .776E-02,     
     1 .988E-05, .420E-04, .210E-03, .832E-03, .317E-02, .842E-02,    
     1 .991E-05, .425E-04, .219E-03, .877E-03, .340E-02, .888E-02,        
     1 .102E-04, .435E-04, .231E-03, .937E-03, .361E-02, .929E-02,       
     1 .110E-04, .486E-04, .244E-03, .971E-03, .402E-02, .994E-02,      
     1 .127E-04, .579E-04, .257E-03, .111E-02, .437E-02, .104E-01,     
     1 .131E-04, .612E-04, .277E-03, .113E-02, .465E-02, .110E-01,        
     1 .150E-04, .783E-04, .353E-03, .116E-02, .510E-02, .116E-01/),     
     1 (/6,8/))
      SD(1:6,249:256) = RESHAPE ((/  ! 6250-6425
     1 .178E-04, .922E-04, .394E-03, .157E-02, .555E-02, .123E-01,      
     1 .203E-04, .115E-03, .481E-03, .188E-02, .601E-02, .131E-01,     
     1 .230E-04, .145E-03, .617E-03, .183E-02, .644E-02, .139E-01,       
     1 .280E-04, .187E-03, .723E-03, .202E-02, .686E-02, .146E-01,      
     1 .305E-04, .209E-03, .811E-03, .243E-02, .779E-02, .157E-01,     
     1 .455E-04, .244E-03, .935E-03, .243E-02, .844E-02, .166E-01,    
     1 .661E-04, .320E-03, .989E-03, .288E-02, .902E-02, .173E-01,        
     1 .723E-04, .397E-03, .122E-02, .359E-02, .100E-01, .184E-01/),    
     1 (/6,8/))
      SD(1:6,257:264) = RESHAPE ((/  ! 6450-6625
     1 .847E-04, .481E-03, .143E-02, .429E-02, .108E-01, .192E-01,     
     1 .103E-03, .591E-03, .174E-02, .488E-02, .116E-01, .200E-01,           
     1 .131E-03, .703E-03, .247E-02, .549E-02, .124E-01, .205E-01,          
     1 .165E-03, .872E-03, .265E-02, .641E-02, .131E-01, .211E-01,         
     1 .205E-03, .110E-02, .298E-02, .749E-02, .140E-01, .218E-01,         
     1 .253E-03, .130E-02, .346E-02, .811E-02, .150E-01, .230E-01,         
     1 .338E-03, .150E-02, .445E-02, .890E-02, .159E-01, .237E-01,        
     1 .437E-03, .170E-02, .491E-02, .107E-01, .170E-01, .245E-01/),     
     1 (/6,8/))
      SD(1:6,265:272) = RESHAPE ((/  ! 6650-6825
     1 .581E-03, .190E-02, .537E-02, .116E-01, .179E-01, .254E-01,         
     1 .685E-03, .220E-02, .578E-02, .128E-01, .189E-01, .263E-01,        
     1 .900E-03, .250E-02, .649E-02, .134E-01, .195E-01, .275E-01,       
     1 .121E-02, .280E-02, .722E-02, .142E-01, .202E-01, .281E-01,      
     1 .152E-02, .330E-02, .813E-02, .161E-01, .212E-01, .288E-01,     
     1 .185E-02, .370E-02, .907E-02, .168E-01, .222E-01, .292E-01,    
     1 .220E-02, .430E-02, .929E-02, .183E-01, .233E-01, .294E-01,       
     1 .255E-02, .500E-02, .114E-01, .195E-01, .245E-01, .289E-01/),       
     1 (/6,8/))
      SD(1:6,273:280) = RESHAPE ((/  ! 6850-7025
     1 .290E-02, .580E-02, .167E-01, .215E-01, .260E-01, .291E-01,        
     1 .320E-02, .670E-02, .208E-01, .237E-01, .274E-01, .293E-01,        
     1 .360E-02, .880E-02, .220E-01, .253E-01, .282E-01, .300E-01,       
     1 .400E-02, .920E-02, .238E-01, .273E-01, .290E-01, .304E-01,        
     1 .460E-02, .108E-01, .272E-01, .279E-01, .298E-01, .310E-01,       
     1 .530E-02, .128E-01, .304E-01, .292E-01, .297E-01, .312E-01,        
     1 .620E-02, .152E-01, .344E-01, .303E-01, .293E-01, .310E-01,       
     1 .760E-02, .182E-01, .341E-01, .297E-01, .290E-01, .300E-01/),    
     1 (/6,8/))
      SD(1:6,281:288) = RESHAPE ((/  ! 7050-7225
     1 .980E-02, .222E-01, .398E-01, .318E-01, .291E-01, .294E-01,        
     1 .132E-01, .271E-01, .402E-01, .294E-01, .274E-01, .282E-01,       
     1 .190E-01, .335E-01, .421E-01, .286E-01, .262E-01, .269E-01,      
     1 .240E-01, .432E-01, .431E-01, .276E-01, .245E-01, .257E-01,     
     1 .288E-01, .570E-01, .458E-01, .270E-01, .228E-01, .243E-01,   
     1 .323E-01, .740E-01, .449E-01, .261E-01, .214E-01, .221E-01,        
     1 .570E-01, .890E-01, .435E-01, .225E-01, .199E-01, .196E-01,       
     1 .216E-01, .680E-01, .378E-01, .239E-01, .195E-01, .192E-01/),    
     1 (/6,8/))
      SD(1:6,289:296) = RESHAPE ((/  ! 7250-7425
     1 .126E-01, .475E-01, .364E-01, .238E-01, .197E-01, .192E-01,       
     1 .117E-01, .369E-01, .385E-01, .249E-01, .212E-01, .204E-01,      
     1 .140E-01, .370E-01, .419E-01, .272E-01, .228E-01, .213E-01,     
     1 .425E-01, .418E-01, .440E-01, .280E-01, .248E-01, .229E-01,   
     1 .640E-01, .460E-01, .427E-01, .290E-01, .263E-01, .238E-01,   
     1 .385E-01, .385E-01, .374E-01, .259E-01, .235E-01, .224E-01,        
     1 .182E-01, .179E-01, .282E-01, .231E-01, .211E-01, .214E-01,       
     1 .170E-01, .810E-02, .191E-01, .175E-01, .181E-01, .194E-01/),      
     1 (/6,8/))
      SD(1:6,297:304) = RESHAPE ((/  ! 7450-7625
     1 .161E-01, .370E-02, .105E-01, .127E-01, .152E-01, .171E-01,       
     1 .145E-01, .170E-02, .554E-02, .855E-02, .113E-01, .131E-01,      
     1 .175E-02, .140E-02, .385E-02, .595E-02, .803E-02, .945E-02,    
     1 .772E-03, .751E-03, .384E-02, .575E-02, .537E-02, .594E-02,       
     1 .491E-03, .600E-03, .301E-02, .453E-02, .380E-02, .434E-02,      
     1 .275E-03, .410E-03, .193E-02, .366E-02, .319E-02, .332E-02,     
     1 .185E-01, .280E-03, .131E-02, .232E-02, .247E-02, .256E-02,      
     1 .101E-03, .160E-03, .915E-03, .150E-02, .186E-02, .197E-02/),   
     1 (/6,8/))
      SD(1:6,305:312) = RESHAPE ((/  ! 7650-7825
     1 .691E-04, .110E-03, .565E-03, .114E-02, .205E-02, .192E-02,          
     1 .476E-04, .750E-04, .114E-02, .124E-02, .175E-02, .187E-02,         
     1 .305E-04, .590E-04, .529E-03, .114E-02, .160E-02, .185E-02,        
     1 .240E-04, .480E-04, .293E-03, .842E-03, .141E-02, .184E-02,       
     1 .170E-04, .360E-04, .122E-03, .435E-03, .124E-02, .182E-02,      
     1 .120E-04, .240E-04, .121E-03, .435E-03, .118E-02, .187E-02,     
     1 .810E-05, .170E-04, .103E-03, .439E-03, .126E-02, .192E-02,    
     1 .550E-05, .120E-04, .866E-04, .367E-03, .119E-02, .193E-02/),    
     1 (/6,8/))
      SD(1:6,313:320) = RESHAPE ((/  ! 7850-8025
     1 .390E-05, .900E-05, .716E-04, .351E-03, .116E-02, .194E-02,         
     1 .295E-05, .830E-05, .373E-04, .254E-03, .114E-02, .196E-02,        
     1 .230E-05, .800E-05, .465E-04, .298E-03, .117E-02, .201E-02,       
     1 .225E-05, .820E-05, .367E-04, .252E-03, .116E-02, .205E-02,      
     1 .220E-05, .840E-05, .371E-04, .268E-03, .127E-02, .211E-02,     
     1 .223E-05, .920E-05, .396E-04, .273E-03, .128E-02, .216E-02,   
     1 .235E-05, .103E-04, .415E-04, .263E-03, .121E-02, .221E-02,      
     1 .280E-05, .125E-04, .633E-04, .363E-03, .136E-02, .231E-02/),   
     1 (/6,8/))
      SD(1:6,321:328) = RESHAPE ((/  ! 8050-8225
     1 .310E-05, .150E-04, .979E-04, .492E-03, .150E-02, .241E-02,           
     1 .370E-05, .180E-04, .120E-03, .580E-03, .167E-02, .251E-02,           
     1 .420E-05, .200E-04, .987E-04, .509E-03, .171E-02, .257E-02,           
     1 .510E-05, .240E-04, .134E-03, .547E-03, .173E-02, .267E-02,           
     1 .600E-05, .270E-04, .121E-03, .534E-03, .172E-02, .274E-02,           
     1 .720E-05, .300E-04, .204E-03, .684E-03, .184E-02, .285E-02,           
     1 .820E-05, .330E-04, .276E-03, .819E-03, .199E-02, .297E-02,           
     1 .100E-04, .380E-04, .317E-03, .859E-03, .214E-02, .308E-02/),         
     1 (/6,8/))
      SD(1:6,329:336) = RESHAPE ((/  ! 8250-8425
     1 .125E-04, .420E-04, .240E-03, .818E-03, .220E-02, .317E-02,           
     1 .145E-04, .500E-04, .452E-03, .109E-02, .238E-02, .293E-02,           
     1 .175E-04, .560E-04, .301E-03, .941E-03, .243E-02, .342E-02,           
     1 .198E-04, .630E-04, .280E-03, .107E-02, .260E-02, .353E-02,           
     1 .230E-04, .710E-04, .276E-03, .109E-02, .272E-02, .365E-02,           
     1 .280E-04, .830E-04, .369E-03, .127E-02, .295E-02, .377E-02,           
     1 .330E-04, .890E-04, .430E-03, .139E-02, .306E-02, .385E-02,           
     1 .360E-04, .950E-04, .371E-03, .135E-02, .306E-02, .384E-02/),         
     1 (/6,8/))
      SD(1:6,337:344) = RESHAPE ((/  ! 8450-8625
     1 .390E-04, .980E-04, .434E-03, .147E-02, .316E-02, .385E-02,           
     1 .400E-04, .990E-04, .397E-03, .143E-02, .318E-02, .384E-02,           
     1 .400E-04, .980E-04, .364E-03, .141E-02, .317E-02, .381E-02,           
     1 .390E-04, .940E-04, .390E-03, .142E-02, .314E-02, .376E-02,          
     1 .380E-04, .900E-04, .380E-03, .145E-02, .318E-02, .375E-02,         
     1 .380E-04, .900E-04, .380E-03, .145E-02, .318E-02, .375E-02,        
     1 .330E-04, .750E-04, .358E-03, .138E-02, .310E-02, .372E-02,       
     1 .270E-04, .580E-04, .382E-03, .143E-02, .315E-02, .369E-02/),    
     1 (/6,8/))
      SD(1:6,345:352) = RESHAPE ((/  ! 8650-8825
     1 .240E-04, .500E-04, .343E-03, .136E-02, .306E-02, .363E-02,          
     1 .200E-04, .450E-04, .309E-03, .134E-02, .306E-02, .359E-02,          
     1 .180E-04, .400E-04, .281E-03, .127E-02, .294E-02, .341E-02,          
     1 .170E-04, .360E-04, .276E-03, .124E-02, .290E-02, .336E-02,         
     1 .160E-04, .310E-04, .272E-03, .122E-02, .283E-02, .323E-02,        
     1 .140E-04, .280E-04, .241E-03, .117E-02, .273E-02, .309E-02,       
     1 .120E-04, .250E-04, .237E-03, .115E-02, .269E-02, .297E-02,      
     1 .100E-04, .220E-04, .218E-03, .111E-02, .259E-02, .284E-02/),   
     1 (/6,8/))
      SD(1:6,353:360) = RESHAPE ((/  ! 8850-9025
     1 .920E-05, .198E-04, .206E-03, .105E-02, .246E-02, .269E-02,       
     1 .810E-05, .170E-04, .205E-03, .100E-02, .235E-02, .257E-02,        
     1 .720E-05, .160E-04, .177E-03, .921E-03, .220E-02, .245E-02,      
     1 .650E-05, .150E-04, .172E-03, .834E-03, .205E-02, .232E-02,     
     1 .590E-05, .130E-04, .147E-03, .735E-03, .194E-02, .218E-02,    
     1 .510E-05, .110E-04, .120E-03, .629E-03, .177E-02, .203E-02,     
     1 .460E-05, .950E-05, .960E-04, .513E-03, .154E-02, .180E-02,      
     1 .420E-05, .800E-05, .578E-04, .314E-03, .123E-02, .154E-02/),     
     1 (/6,8/))
      SD(1:6,361:368) = RESHAPE ((/  ! 9050-9225
     1 .380E-05, .720E-05, .529E-04, .292E-03, .114E-02, .137E-02,      
     1 .330E-05, .660E-05, .485E-04, .269E-03, .102E-02, .122E-02,      
     1 .290E-05, .580E-05, .430E-04, .239E-03, .896E-03, .107E-02,      
     1 .270E-05, .520E-05, .259E-04, .193E-03, .748E-03, .944E-03,     
     1 .240E-05, .450E-05, .316E-04, .207E-03, .671E-02, .848E-03,      
     1 .220E-05, .400E-05, .444E-05, .602E-04, .516E-03, .750E-03,     
     1 .190E-05, .360E-05, .324E-05, .460E-04, .439E-03, .688E-03,      
     1 .170E-05, .320E-05, .180E-05, .321E-04, .384E-03, .653E-03/),   
     1 (/6,8/))
      SD(1:6,369:376) = RESHAPE ((/  ! 9250-9300
     1 .140E-05, .280E-05, .171E-05, .344E-04, .340E-03, .616E-03,    
     1 .130E-05, .250E-05, .299E-05, .600E-04, .343E-03, .619E-03,    
     1 .120E-05, .220E-05, .299E-05, .600E-04, .343E-03, .619E-03,   
     1 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,
     1 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1./),
     1 (/6,8/))
C
C Intialize GAMMA Array
C
      GAMMA = RESHAPE((/
C     LINE BROADENING PARAMETERS,GAMMA(I,J),
C     J=CO2,H2O,CH4,CO,O2,N2,SELF RESONANT.
C   I=	    CO2  H2O  CH4   CO
C    J
     1     .09 , .12, .0 , .07,
     2     .07 , .09, .0 , .06,
     3     .0  , .0 , .16, .0 ,
     4     .06 , .10, .0 , .06,
     5     .055, .04, .0 , .05,
     6     .07 , .09, .0 , .06,
     7     .01 , .44, .0 , .0 /),(/4,7/))
C
C Initialize SD15 Array
C
C  THE FOLLOWING ARE DATA FOR THE 15.0 MICRON BAND OF CO2
C  TEMP, K=300	    600	     1200      1500	 1800	   2400    
C
      SD15(1:6,1:8) = RESHAPE ((/  ! 500-535
     1 .000E+00, .000E+00, .000E+00, .105E-01, .300E-01, .880E-01,          
     1 .000E+00, .000E+00, .000E+00, .180E-01, .490E-01, .880E-01,          
     1 .000E+00, .000E+00, .000E+00, .300E-01, .540E-01, .740E-01,          
     1 .000E+00, .000E+00, .000E+00, .300E-01, .560E-01, .890E-01,          
     1 .000E+00, .000E+00, .000E+00, .330E-01, .690E-01, .990E-01,          
     1 .000E+00, .000E+00, .880E-02, .380E-01, .720E-01, .970E-01,          
     1 .000E+00, .000E+00, .110E-01, .530E-01, .950E-01, .124E+00,          
     1 .000E+00, .000E+00, .285E-01, .630E-01, .990E-01, .140E+00/),        
     1 (/6,8/))
      SD15(1:6,9:16) = RESHAPE ((/  ! 540-575
     1 .000E+00, .000E+00, .330E-01, .680E-01, .103E+00, .134E+00,          
     1 .000E+00, .000E+00, .450E-01, .920E-01, .138E+00, .176E+00,          
     1 .000E+00, .000E+00, .490E-01, .970E-01, .148E+00, .191E+00,          
     1 .000E+00, .000E+00, .490E-01, .120E-01, .188E+00, .247E+00,          
     1 .000E+00, .000E+00, .480E-01, .126E+00, .201E+00, .241E+00,          
     1 .000E+00, .000E+00, .820E-01, .198E+00, .270E+00, .265E+00,          
     1 .000E+00, .750E-02, .690E-01, .140E+00, .225E+00, .340E+00,          
     1 .000E+00, .205E-01, .820E-01, .145E+00, .236E+00, .530E+00/),        
     1 (/6,8/))
      SD15(1:6,17:24) = RESHAPE ((/  ! 580-615
     1 .000E+00, .355E-01, .117E+00, .193E+00, .295E+00, .550E+00,          
     1 .157E-01, .520E-01, .170E+00, .235E+00, .305E+00, .410E+00,          
     1 .150E-01, .880E-01, .270E+00, .330E+00, .440E+00, .520E+00,          
     1 .510E-01, .130E+00, .400E+00, .530E+00, .560E+00, .540E+00,          
     1 .120E+00, .165E+00, .275E+00, .320E+00, .420E+00, .560E+00,          
     1 .880E-01, .190E+00, .430E+00, .540E+00, .620E+00, .680E+00,          
     1 .110E+00, .350E+00, .710E+00, .760E+00, .760E+00, .690E+00,          
     1 .180E+00, .470E+00, .920E+00, .970E+00, .910E+00, .670E+00/),        
     1 (/6,8/))
      SD15(1:6,25:32) = RESHAPE ((/  ! 620-655
     1 .970E-01, .265E+00, .610E+00, .720E+00, .780E+00, .730E+00,          
     1 .175E+00, .380E+00, .720E+00, .790E+00, .830E+00, .840E+00,          
     1 .370E+00, .640E+00, .920E+00, .960E+00, .980E+00, .940E+00,          
     1 .590E+00, .840E+00, .107E+01, .110E+01, .111E+01, .106E+01,          
     1 .940E+00, .103E+01, .115E+01, .115E+01, .115E+01, .118E+01,          
     1 .196E+01, .177E+01, .146E+01, .136E+01, .132E+01, .139E+01,          
     1 .345E+01, .282E+01, .198E+01, .172E+01, .156E+01, .148E+01,          
     1 .282E+01, .248E+01, .200E+01, .190E+01, .186E+01, .205E+01/),        
     1 (/6,8/))
      SD15(1:6,33:40) = RESHAPE ((/  ! 660-695
     1 .254E+01, .234E+01, .184E+01, .176E+01, .174E+01, .203E+01,          
     1 .142E+02, .860E+01, .370E+01, .260E+01, .196E+01, .142E+01,          
     1 .450E+01, .570E+01, .580E+01, .520E+01, .350E+01, .420E+01,          
     1 .360E+01, .310E+01, .330E+01, .290E+01, .205E+01, .200E+01,          
     1 .310E+01, .260E+01, .200E+01, .196E+01, .180E+01, .210E+01,          
     1 .240E+01, .250E+01, .230E+01, .220E+01, .170E+01, .194E+01,          
     1 .182E+01, .200E+01, .218E+01, .205E+01, .184E+01, .130E+01,          
     1 .104E+01, .135E+01, .172E+01, .172E+01, .165E+01, .130E+01/),        
     1 (/6,8/))
      SD15(1:6,41:48) = RESHAPE ((/  ! 700-735
     1 .550E+00, .120E+01, .143E+01, .147E+01, .148E+01, .125E+01,          
     1 .136E+01, .128E+01, .128E+01, .135E+01, .138E+01, .134E+01,          
     1 .210E+00, .780E+00, .127E+01, .133E+01, .137E+01, .132E+01,          
     1 .190E+00, .780E+00, .140E+01, .146E+01, .147E+01, .142E+01,          
     1 .900E+00, .106E+01, .140E+01, .150E+01, .155E+01, .134E+01,          
     1 .720E-01, .300E+00, .800E+00, .100E+01, .115E+01, .126E+01,          
     1 .640E-01, .210E+00, .560E+00, .720E+00, .860E+00, .102E+01,          
     1 .680E-01, .210E+00, .530E+00, .670E+00, .790E+00, .101E+01/),        
     1 (/6,8/))
      SD15(1:6,49:56) = RESHAPE ((/  ! 740-775
     1 .690E-01, .210E+00, .540E+00, .690E+00, .820E+00, .910E+00,          
     1 .330E-01, .140E+00, .390E+00, .530E+00, .690E+00, .770E+00,          
     1 .230E-01, .780E-01, .270E+00, .410E+00, .560E+00, .890E+00,          
     1 .300E-01, .860E-01, .280E+00, .400E+00, .520E+00, .710E+00,          
     1 .175E-01, .620E-01, .225E+00, .335E+00, .450E+00, .660E+00,          
     1 .105E-01, .450E-01, .180E+00, .280E+00, .380E+00, .600E+00,          
     1 .450E-02, .300E-01, .148E+00, .240E+00, .345E+00, .570E+00,          
     1 .000E+00, .140E-01, .124E+00, .205E+00, .285E+00, .430E+00/),        
     1 (/6,8/))
      SD15(1:6,57:64) = RESHAPE ((/  ! 780-815
     1 .000E+00, .115E-01, .110E+00, .185E+00, .260E+00, .375E+00,          
     1 .000E+00, .135E-01, .840E-01, .140E+00, .205E+00, .335E+00,          
     1 .000E+00, .430E-02, .650E-01, .120E+00, .185E+00, .325E+00,          
     1 .000E+00, .000E+00, .540E-01, .115E+00, .180E+00, .315E+00,          
     1 .000E+00, .000E+00, .440E-01, .950E-01, .150E+00, .270E+00,          
     1 .000E+00, .000E+00, .360E-01, .790E-01, .125E+00, .205E+00,          
     1 .000E+00, .000E+00, .250E-01, .650E-01, .110E+00, .178E+00,          
     1 .000E+00, .000E+00, .180E-01, .620E-01, .103E+00, .153E+00/),        
     1 (/6,8/))
      SD15(1:6,65:72) = RESHAPE ((/  ! 820-855
     1 .000E+00, .000E+00, .320E-01, .580E-01, .860E-01, .147E+00,          
     1 .000E+00, .000E+00, .800E-02, .510E-01, .870E-01, .134E+00,          
     1 .000E+00, .000E+00, .600E-02, .480E-01, .830E-01, .133E+00,          
     1 .000E+00, .000E+00, .000E+00, .430E-01, .780E-01, .118E+00,          
     1 .000E+00, .000E+00, .000E+00, .420E-01, .700E-01, .108E+00,          
     1 .000E+00, .000E+00, .000E+00, .360E-01, .640E-01, .980E-01,          
     1 .000E+00, .000E+00, .000E+00, .350E-01, .610E-01, .870E-01,          
     1 .000E+00, .000E+00, .000E+00, .320E-01, .580E-01, .860E-01/),        
     1 (/6,8/))
      SD15(1:6,73:80) = RESHAPE ((/  ! 860-880
     1 .000E+00, .000E+00, .000E+00, .330E-01, .560E-01, .750E-01,          
     1 .000E+00, .000E+00, .000E+00, .300E-01, .530E-01, .750E-01,          
     1 .000E+00, .000E+00, .000E+00, .290E-01, .530E-01, .850E-01,          
     1 .000E+00, .000E+00, .000E+00, .240E-01, .470E-01, .900E-01,          
     1 .000E+00, .000E+00, .000E+00, .220E-01, .450E-01, .860E-01,          
     1 .000E+00, .000E+00, .000E+00, .000E+00, .000E+00, .000E+00,
     1 .000E+00, .000E+00, .000E+00, .000E+00, .000E+00, .000E+00,
     1 .000E+00, .000E+00, .000E+00, .000E+00, .000E+00, .000E+00/),
     1 (/6,8/))
C
C Initialize SD7 Array
C
C   THE FOLLOWING DATA ARE FOR THE 7.7 MICRON BAND OF CH4
C TEMP,K= 290	600   850
C
      SD7(1:3,1:8) = RESHAPE ((/
     1 0., 0., 0.,
     1 0., 0., 0.03,
     1 0., 0., 0.22,
     1 0.16, 0.20, 0.47,
     1 0.34, 0.34, 0.62,
     1 0.69, 0.53, 0.65,
     1 1.27, 0.88, 1.09,
     1 1.68, 1.38, 0.87/),(/3,8/))
      SD7(1:3,9:16) = RESHAPE ((/
     1 0.55, 0.28, 0.40,
     1 1.25, 0.86, 0.93,
     1 0.34, 0.59, 0.75,
     1 0., 0.13, 0.25,
     1 0., 0., 0.06,
     1 0., 0., 0.,
     1 0., 0., 0.,
     1 0., 0., 0./),(/3,8/))
C
C Initialize SD3 Array
C
C  THE FOLLOWING DATA ARE FOR THE 3.3 MICRON BAND OF CH4
C TEMP, K= 290	 600   850
      SD3(1:3,1:8) = RESHAPE ((/
     1 0., 0., 0.03,
     1 0., 0., 0.03,
     1 0., 0., 0.03,
     1 0., 0., 0.06,
     1 0.03, 0.03, 0.09,
     1 0.07, 0.07, 0.12,
     1 0.09, 0.09, 0.12,
     1 0.14, 0.15, 0.22/),(/3,8/))
      SD3(1:3,9:16) = RESHAPE ((/
     1 0.18, 0.22, 0.28,
     1 0.24, 0.31, 0.37,
     1 0.33, 0.44, 0.47,
     1 0.45, 0.50, 0.53,
     1 0.59, 0.62, 0.62,
     1 0.74, 0.70, 0.68,
     1 0.91, 0.77, 0.72,
     1 1.00, 0.81, 0.75/),(/3,8/))
      SD3(1:3,17:24) = RESHAPE ((/
     1 1.03, 0.84, 0.78,
     1 1.03, 0.84, 0.78,
     1 1.00, 0.81, 0.75,
     1 0.94, 0.77, 0.72,
     1 0.72, 0.68, 0.68,
     1 0.52, 0.63, 0.63,
     1 0.33, 0.50, 0.56,
     1 0.25, 0.42, 0.50/),(/3,8/))
      SD3(1:3,25:32) = RESHAPE ((/
     1 0.17, 0.26, 0.37,
     1 0.08, 0.18, 0.31,
     1 0.04, 0.11, 0.22,
     1 0., 0.06, 0.16,
     1 0., 0.02, 0.12,
     1 0., 0., 0.06,
     1 0., 0., 0.03,
     1 0., 0., 0./),(/3,8/))
C
      END SUBROUTINE RCALLOC
C
      SUBROUTINE RCDEALLOC
C     
      DEALLOCATE(SVF)
      DEALLOCATE(RCT)
      DEALLOCATE(DD)
      DEALLOCATE(XPART)
      DEALLOCATE(P)
      DEALLOCATE(SPECIE)
      DEALLOCATE(QW)
      DEALLOCATE(TTAU)
      DEALLOCATE(XTOT)
      DEALLOCATE(XT)
      DEALLOCATE(XSTAR)
      DEALLOCATE(X)
      DEALLOCATE(TAU)
      DEALLOCATE(AC)
      DEALLOCATE(AD)
      DEALLOCATE(GC)
      DEALLOCATE(AMBDA)
      DEALLOCATE(TAUS)
      DEALLOCATE(UUU)
      DEALLOCATE(AB)
      DEALLOCATE(PKPA)
      DEALLOCATE(ATOT)
      DEALLOCATE(BCNT)
      DEALLOCATE(GAMMA)
      DEALLOCATE(SD15)
      DEALLOCATE(SD)
      DEALLOCATE(SD7)
      DEALLOCATE(SD3)
C     
      END SUBROUTINE RCDEALLOC
C
      END MODULE RADCALV


      MODULE RADCONS
C
      USE PREC
      IMPLICIT NONE
      INTEGER  NUMBER_RADIATION_ANGLES, NUMBER_SPECTRAL_BANDS
      REAL(EB), ALLOCATABLE, DIMENSION(:)   :: BBFRAC,WL_LOW,WL_HIGH
      REAL(EB), ALLOCATABLE, DIMENSION(:,:) :: WQABS, WQSCA
      INTEGER  NRDMIE, NLMBDMIE, NMIEANG, NDG
      REAL(EB), ALLOCATABLE, DIMENSION(:) :: KWR
      REAL(EB) DGROUP_A, DGROUP_B, RADTMP

      END MODULE RADCONS


      MODULE WATERDATA
C
      USE PREC
      IMPLICIT NONE
      INTEGER ::  I,J
      INTEGER, PARAMETER :: NWATERK=183
      REAL(EB) :: CPLXREF(NWATERK,2)
c
c     Hale, G.M. and Querry, M.R., "Optical Constants of Water 
c     in the 200-nm to 200-\mu m Wavelength Region", 
c     Applied Optics, 12(3), 555-63 (1973)
c
      DATA ((CPLXREF(I,J), J = 1,2), I = 1,10)  
     . / 1.0000000E-6_EB,  2.8647890E-6_EB,
     .   1.0200000E-6_EB,  2.1915636E-6_EB,
     .   1.0400000E-6_EB,  1.3241691E-6_EB,
     .   1.0600000E-6_EB,  1.0122254E-6_EB,
     .   1.0800000E-6_EB,  1.1172677E-6_EB,
     .   1.1000000E-6_EB,  1.4880987E-6_EB,
     .   1.1200000E-6_EB,  4.6345919E-6_EB,
     .   1.1400000E-6_EB,  5.9874090E-6_EB,
     .   1.1600000E-6_EB,  8.2155782E-6_EB,
     .   1.1800000E-6_EB,  9.7657473E-6_EB /
      DATA ((CPLXREF(I,J), J = 1,2), I =11,20)  
     . / 1.2000000E-6_EB,  9.9312684E-6_EB,
     .   1.2200000E-6_EB,  9.2230290E-6_EB,
     .   1.2400000E-6_EB,  8.6834937E-6_EB,
     .   1.2600000E-6_EB,  8.9238177E-6_EB,
     .   1.2800000E-6_EB,  9.9821980E-6_EB,
     .   1.3000000E-6_EB,  1.1483029E-5_EB,
     .   1.3200000E-6_EB,  1.1953809E-5_EB,
     .   1.3400000E-6_EB,  1.2614780E-5_EB,
     .   1.3600000E-6_EB,  2.9978533E-5_EB,
     .   1.3800000E-6_EB,  6.6988316E-5_EB /
      DATA ((CPLXREF(I,J), J = 1,2), I =21,30)  
     . / 1.4000000E-6_EB,  1.3803508E-4_EB,
     .   1.4200000E-6_EB,  2.4995602E-4_EB,
     .   1.4400000E-6_EB,  3.3002369E-4_EB,
     .   1.4600000E-6_EB,  3.2996003E-4_EB,
     .   1.4800000E-6_EB,  2.5003560E-4_EB,
     .   1.5000000E-6_EB,  2.0996516E-4_EB,
     .   1.5200000E-6_EB,  1.6994565E-4_EB,
     .   1.5400000E-6_EB,  1.4497583E-4_EB,
     .   1.5600000E-6_EB,  1.2004433E-4_EB,
     .   1.5800000E-6_EB,  9.9957388E-5_EB /
      DATA ((CPLXREF(I,J), J = 1,2), I =31,40)  
     . / 1.6000000E-6_EB,  8.5561825E-5_EB,
     .   1.6200000E-6_EB,  7.5028952E-5_EB,
     .   1.6400000E-6_EB,  6.4992643E-5_EB,
     .   1.6600000E-6_EB,  5.9972898E-5_EB,
     .   1.6800000E-6_EB,  6.0027012E-5_EB,
     .   1.7000000E-6_EB,  6.0065211E-5_EB,
     .   1.7200000E-6_EB,  6.9942231E-5_EB,
     .   1.7400000E-6_EB,  8.5017388E-5_EB,
     .   1.7600000E-6_EB,  1.0000023E-4_EB,
     .   1.7800000E-6_EB,  1.1501809E-4_EB /
      DATA ((CPLXREF(I,J), J = 1,2), I =41,50)  
     . / 1.8000000E-6_EB,  1.1502128E-4_EB,
     .   1.8200000E-6_EB,  1.3005838E-4_EB,
     .   1.8400000E-6_EB,  1.4993669E-4_EB,
     .   1.8600000E-6_EB,  2.1003200E-4_EB,
     .   1.8800000E-6_EB,  4.6497435E-4_EB,
     .   1.9000000E-6_EB,  1.0000183E-3_EB,
     .   1.9200000E-6_EB,  1.7500423E-3_EB,
     .   1.9400000E-6_EB,  1.8499391E-3_EB,
     .   1.9600000E-6_EB,  1.6500261E-3_EB,
     .   1.9800000E-6_EB,  1.4500559E-3_EB /
      DATA ((CPLXREF(I,J), J = 1,2), I =51,60)  
     . / 2.0000000E-6_EB,  1.1000790E-3_EB,
     .   2.0200000E-6_EB,  9.0001961E-4_EB,
     .   2.0400000E-6_EB,  7.3003417E-4_EB,
     .   2.0600000E-6_EB,  6.3998112E-4_EB,
     .   2.0800000E-6_EB,  5.2006742E-4_EB,
     .   2.1000000E-6_EB,  4.5003447E-4_EB,
     .   2.1200000E-6_EB,  4.0505888E-4_EB,
     .   2.1400000E-6_EB,  3.4995785E-4_EB,
     .   2.1600000E-6_EB,  3.2005422E-4_EB,
     .   2.1800000E-6_EB,  2.9994500E-4_EB /
      DATA ((CPLXREF(I,J), J = 1,2), I =61,70)  
     . / 2.2000000E-6_EB,  2.8904129E-4_EB,
     .   2.2200000E-6_EB,  2.8495578E-4_EB,
     .   2.2400000E-6_EB,  2.9500960E-4_EB,
     .   2.2600000E-6_EB,  3.1005293E-4_EB,
     .   2.2800000E-6_EB,  3.5997028E-4_EB,
     .   2.3000000E-6_EB,  4.0998313E-4_EB,
     .   2.3200000E-6_EB,  4.9496551E-4_EB,
     .   2.3400000E-6_EB,  5.9494505E-4_EB,
     .   2.3600000E-6_EB,  6.9994116E-4_EB,
     .   2.3800000E-6_EB,  8.2007768E-4_EB /
      DATA ((CPLXREF(I,J), J = 1,2), I =71,80)  
     . / 2.4000000E-6_EB,  9.5607557E-4_EB,
     .   2.4200000E-6_EB,  1.1500727E-3_EB,
     .   2.4400000E-6_EB,  1.2999617E-3_EB,
     .   2.4600000E-6_EB,  1.4999176E-3_EB,
     .   2.4800000E-6_EB,  1.6999912E-3_EB,
     .   2.5000000E-6_EB,  1.8000424E-3_EB,
     .   2.5200000E-6_EB,  2.0500716E-3_EB,
     .   2.5400000E-6_EB,  2.1999478E-3_EB,
     .   2.5600000E-6_EB,  2.3500946E-3_EB,
     .   2.5800000E-6_EB,  2.7000302E-3_EB /
      DATA ((CPLXREF(I,J), J = 1,2), I =81,90)  
     . / 2.6000000E-6_EB,  3.1699367E-3_EB,
     .   2.6500000E-6_EB,  6.7000889E-3_EB,
     .   2.7000000E-6_EB,  1.8999997E-2_EB,
     .   2.7500000E-6_EB,  5.9000926E-2_EB,
     .   2.8000000E-6_EB,  1.1500027E-1_EB,
     .   2.8500000E-6_EB,  1.8499960E-1_EB,
     .   2.9000000E-6_EB,  2.6769861E-1_EB,
     .   2.9500000E-6_EB,  2.9813700E-1_EB,
     .   3.0000000E-6_EB,  2.7215495E-1_EB,
     .   3.0500000E-6_EB,  2.4000020E-1_EB /
      DATA ((CPLXREF(I,J), J = 1,2), I =91,100)  
     . / 3.1000000E-6_EB,  1.9200142E-1_EB,
     .   3.1500000E-6_EB,  1.3500032E-1_EB,
     .   3.2000000E-6_EB,  9.2401540E-2_EB,
     .   3.2500000E-6_EB,  6.0999713E-2_EB,
     .   3.3000000E-6_EB,  3.6798931E-2_EB,
     .   3.3500000E-6_EB,  2.6099958E-2_EB,
     .   3.4000000E-6_EB,  1.9500046E-2_EB,
     .   3.4500000E-6_EB,  1.3199993E-2_EB,
     .   3.5000000E-6_EB,  9.4000888E-3_EB,
     .   3.6000000E-6_EB,  5.1500311E-3_EB /
      DATA ((CPLXREF(I,J), J = 1,2), I =101,110)  
     . / 3.7000000E-6_EB,  3.6000769E-3_EB,
     .   3.8000000E-6_EB,  3.4001225E-3_EB,
     .   3.9000000E-6_EB,  3.7999516E-3_EB,
     .   4.0000000E-6_EB,  4.5998962E-3_EB,
     .   4.1000000E-6_EB,  5.6118033E-3_EB,
     .   4.2000000E-6_EB,  6.8850428E-3_EB,
     .   4.3000000E-6_EB,  8.4519233E-3_EB,
     .   4.4000000E-6_EB,  1.0294142E-2_EB,
     .   4.5000000E-6_EB,  1.3392888E-2_EB,
     .   4.6000000E-6_EB,  1.4715466E-2_EB /
      DATA ((CPLXREF(I,J), J = 1,2), I =111,120)  
     . / 4.7000000E-6_EB,  1.5708593E-2_EB,
     .   4.8000000E-6_EB,  1.5011494E-2_EB,
     .   4.9000000E-6_EB,  1.3686529E-2_EB,
     .   5.0000000E-6_EB,  1.2414086E-2_EB,
     .   5.1000000E-6_EB,  1.1120156E-2_EB,
     .   5.2000000E-6_EB,  1.0096790E-2_EB,
     .   5.3000000E-6_EB,  9.7848459E-3_EB,
     .   5.4000000E-6_EB,  1.0313240E-2_EB,
     .   5.5000000E-6_EB,  1.1598416E-2_EB,
     .   5.6000000E-6_EB,  1.4215720E-2_EB /
      DATA ((CPLXREF(I,J), J = 1,2), I =121,130)  
     . / 5.7000000E-6_EB,  2.0320903E-2_EB,
     .   5.8000000E-6_EB,  3.3000777E-2_EB,
     .   5.9000000E-6_EB,  6.2209688E-2_EB,
     .   6.0000000E-6_EB,  1.0699987E-1_EB,
     .   6.1000000E-6_EB,  1.3101555E-1_EB,
     .   6.2000000E-6_EB,  8.8019050E-2_EB,
     .   6.3000000E-6_EB,  5.7002139E-2_EB,
     .   6.4000000E-6_EB,  4.4868962E-2_EB,
     .   6.5000000E-6_EB,  3.9207820E-2_EB,
     .   6.6000000E-6_EB,  3.5609327E-2_EB /
      DATA ((CPLXREF(I,J), J = 1,2), I =131,140)  
     . / 6.7000000E-6_EB,  3.3696285E-2_EB,
     .   6.8000000E-6_EB,  3.2684059E-2_EB,
     .   6.9000000E-6_EB,  3.2176355E-2_EB,
     .   7.0000000E-6_EB,  3.1974228E-2_EB,
     .   7.1000000E-6_EB,  3.1979003E-2_EB,
     .   7.2000000E-6_EB,  3.2085637E-2_EB,
     .   7.3000000E-6_EB,  3.2182721E-2_EB,
     .   7.4000000E-6_EB,  3.2388031E-2_EB,
     .   7.5000000E-6_EB,  3.2586975E-2_EB,
     .   7.6000000E-6_EB,  3.2779552E-2_EB /
      DATA ((CPLXREF(I,J), J = 1,2), I =141,150)  
     . / 7.7000000E-6_EB,  3.3088313E-2_EB,
     .   7.8000000E-6_EB,  3.3518031E-2_EB,
     .   7.9000000E-6_EB,  3.3884883E-2_EB,
     .   8.0000000E-6_EB,  3.4313806E-2_EB,
     .   8.2000000E-6_EB,  3.5106397E-2_EB,
     .   8.4000000E-6_EB,  3.6096341E-2_EB,
     .   8.6000000E-6_EB,  3.1001791E-2_EB,
     .   8.8000000E-6_EB,  3.8515496E-2_EB,
     .   9.0000000E-6_EB,  3.9892186E-2_EB,
     .   9.2000000E-6_EB,  4.1510792E-2_EB /
      DATA ((CPLXREF(I,J), J = 1,2), I =151,160)  
     . / 9.4000000E-6_EB,  4.3310835E-2_EB,
     .   9.6000000E-6_EB,  4.5378257E-2_EB,
     .   9.8000000E-6_EB,  4.7883356E-2_EB,
     .   1.0000000E-5_EB,  5.0770427E-2_EB,
     .   1.0500000E-5_EB,  6.6176625E-2_EB,
     .   1.1000000E-5_EB,  9.6813952E-2_EB,
     .   1.1500000E-5_EB,  1.4202987E-1_EB,
     .   1.2000000E-5_EB,  1.9900734E-1_EB,
     .   1.2500000E-5_EB,  2.5902467E-1_EB,
     .   1.3000000E-5_EB,  3.0497270E-1_EB /
      DATA ((CPLXREF(I,J), J = 1,2), I =161,170)  
     . / 1.3500000E-5_EB,  3.4302267E-1_EB,
     .   1.4000000E-5_EB,  3.6998750E-1_EB,
     .   1.4500000E-5_EB,  3.8804760E-1_EB,
     .   1.5000000E-5_EB,  4.0202539E-1_EB,
     .   1.5500000E-5_EB,  4.1394609E-1_EB,
     .   1.6000000E-5_EB,  4.2195159E-1_EB,
     .   1.6500000E-5_EB,  4.2804722E-1_EB,
     .   1.7000000E-5_EB,  4.2897828E-1_EB,
     .   1.7500000E-5_EB,  4.2906183E-1_EB,
     .   1.8000000E-5_EB,  4.2599412E-1_EB /
      DATA ((CPLXREF(I,J), J = 1,2), I =171,180)  
     . / 1.8500000E-5_EB,  4.2104440E-1_EB,
     .   1.9000000E-5_EB,  4.1397792E-1_EB,
     .   1.9500000E-5_EB,  4.0407849E-1_EB,
     .   2.0000000E-5_EB,  3.9295355E-1_EB,
     .   3.0000000E-5_EB,  3.2801834E-1_EB,
     .   3.8000000E-5_EB,  3.6105890E-1_EB,
     .   5.0000000E-5_EB,  5.1407047E-1_EB,
     .   6.0000000E-5_EB,  5.8680428E-1_EB,
     .   7.0000000E-5_EB,  5.7598174E-1_EB,
     .   8.0000000E-5_EB,  5.4685638E-1_EB /
      DATA ((CPLXREF(I,J), J = 1,2), I =181,NWATERK)  
     . / 9.0000000E-5_EB,  5.3571554E-1_EB,
     .   1.0000000E-4_EB,  5.3237328E-1_EB,
     .   2.0000000E-4_EB,  5.0452117E-1_EB /

      END MODULE WATERDATA
!
!
!

      MODULE MIEV
C
      USE PREC
      USE CONS
      USE WATERDATA, ONLY: CPLXREF, NWATERK
      USE RADCALV, ONLY: PLANCK
      USE RADCONS

      IMPLICIT NONE
      REAL(EB), ALLOCATABLE :: RDMIE(:), RDWGHT(:), 
     .                         LMBDMIE(:),LMBDWGHT(:)
      REAL(EB), ALLOCATABLE :: QSCA(:,:), QABS(:,:), 
     .                         CHI_F(:,:)

      PRIVATE 
      PUBLIC MEAN_CROSS_SECTIONS, INTERPOLATE1D
      CONTAINS

      SUBROUTINE MEAN_CROSS_SECTIONS
!
!     This subroutine calculates the mean scattering and absorption
!     coefficients for each radiation band and droplet size group.
!
      INTEGER  NSB
!
      INTEGER  I, J, IBND,IZERO, NX, KS, N
      INTEGER  NLAMBDALOW(1), NLAMBDAHIGH(1)
      INTEGER  ND, NRDINT
      REAL(EB) RMMAX, RMMIN, GAMMA, SIGMA, RDTMP, IB, IBSUM
      REAL(EB) DM_ADJUSTED
      REAL(EB) AVAL, BVAL, ASUM, BSUM
      REAL(EB), ALLOCATABLE, DIMENSION(:) :: FDDIST, RDDIST
      INTEGER  IPHI, ITHETA
      TYPE (SPRINKLER_TYPE), POINTER :: S
      TYPE (LAGRANGIAN_TYPE), POINTER :: LP
!
!     Numerical parameters
!
      NRDINT = 300
!
!     Physical parameters
!
      RMMIN = 0.5E-6   ! minimum mean radius (m)
      GAMMA = 2.4
      SIGMA = 1.15/GAMMA
!
      NSB = NUMBER_SPECTRAL_BANDS
!
!     Find the maximum mean radius
!
      RMMAX = 0.0
C
      SPRINKLER_LOOP: DO KS=1,NST
!
      S => SPRINKLER(KS)
!
      IF (PRESSURE.LT.0.) THEN
         PIPE_PRESSURE = S%OPERATING_PRESSURE
         ELSE
         PIPE_PRESSURE = PRESSURE
         ENDIF
!
      DO IPHI=1,S%NPHI(3)
      DO ITHETA=1,S%NTHETA(3)
         DM_ADJUSTED = S%DROPLET_DIAMETER(ITHETA,IPHI)*
     .      (S%OPERATING_PRESSURE/PIPE_PRESSURE)**ONTH
            IF (DM_ADJUSTED .GT. 2.*RMMAX) RMMAX = 0.5*DM_ADJUSTED
      ENDDO
      ENDDO
      ENDDO SPRINKLER_LOOP
!
      LAGRANGIAN_LOOP: DO N=1,NPC
      LP=>LAGRANGIAN(N)
      IF (.NOT.LP%WATER) CYCLE LAGRANGIAN_LOOP
      IF (LP%DIAMETER.GT.2.*RMMAX) RMMAX = 0.5*LP%DIAMETER
      ENDDO LAGRANGIAN_LOOP
!
!     Allow increase of the mean radius
!
      RMMAX = 1.5*RMMAX
!
!     Calculate parameters of the droplet group lookup table
!
      DGROUP_A = (LOG(RMMAX)-LOG(RMMIN))/(NDG-1)
      DGROUP_B = LOG(RMMAX)-DGROUP_A*NDG
!
!     Generate the droplet radii for mie table (microns)
!
      RDTMP = 0.02
      NX = 0
      DO WHILE (RDTMP .LT. 3.*RMMAX*1.0E6) 
         IF (RDTMP .LT. 1000.0) AVAL = 0.02
         IF (RDTMP .LT. 1.00) AVAL = 0.1
         IF (RDTMP .LT. 0.10) AVAL = 0.02
         NX = NX + 1
         RDTMP = RDTMP + MIN(300._EB,MAX(AVAL,0.02*RDTMP**(1.5)))
      ENDDO
      NRDMIE = NX 
!
      ALLOCATE(RDMIE(1:NRDMIE),STAT=IZERO)
      CALL ChkMemErr('MIEV','RDMIE',IZERO)
!
      RDTMP = 0.02
      RDMIE(1) = RDTMP
      DO NX = 2, NRDMIE
         IF (RDTMP .LT. 1000.0) AVAL = 0.02
         IF (RDTMP .LT. 1.00) AVAL = 0.1
         IF (RDTMP .LT. 0.10) AVAL = 0.02
         RDTMP = RDTMP + MIN(300._EB,MAX(AVAL,0.02*RDTMP**(1.5)))
         RDMIE(NX) = RDTMP
      ENDDO
      RDMIE = RDMIE*1.0E-6
!
      NLMBDMIE = NWATERK
!
!     Allocate arrays
!
      ALLOCATE(QSCA(1:NRDMIE,1:NLMBDMIE),STAT=IZERO)
      CALL ChkMemErr('INIT','QSCA',IZERO)
      ALLOCATE(QABS(1:NRDMIE,1:NLMBDMIE),STAT=IZERO)
      CALL ChkMemErr('INIT','QABS',IZERO)
      ALLOCATE(CHI_F(1:NRDMIE,1:NLMBDMIE),STAT=IZERO)
      CALL ChkMemErr('INIT','CHI_F',IZERO)
!
      ALLOCATE(LMBDMIE(1:NLMBDMIE),STAT=IZERO)
      CALL ChkMemErr('INIT','LMBDMIE',IZERO)
      ALLOCATE(LMBDWGHT(1:NLMBDMIE),STAT=IZERO)
      CALL ChkMemErr('INIT','LMBDWGHT',IZERO)
!
      ALLOCATE(FDDIST(0:NRDINT),STAT=IZERO)
      CALL ChkMemErr('INIT','FDDIST',IZERO)
      ALLOCATE(RDDIST(0:NRDINT),STAT=IZERO)
      CALL ChkMemErr('INIT','RDDIST',IZERO)
      ALLOCATE(RDWGHT(0:NRDINT),STAT=IZERO)
      CALL ChkMemErr('INIT','RDWGHT',IZERO)
!
      CALL MIE_SCATTERING
!
!     Generate integration weights for lambda
!
      LMBDWGHT(1) = 0.5*(LMBDMIE(2)-LMBDMIE(1))
      DO I = 2, NLMBDMIE-1
        LMBDWGHT(I) = 0.5*(LMBDMIE(I+1) - LMBDMIE(I-1))
      ENDDO
        LMBDWGHT(NLMBDMIE) = 0.5*(LMBDMIE(NLMBDMIE)-LMBDMIE(NLMBDMIE-1))
     
!
!     Loop over all radiation bands
!
      BANDLOOP: DO IBND = 1,NSB
!
      IF (NSB .EQ. 1) THEN
      NLAMBDALOW = 1
      NLAMBDAHIGH = NLMBDMIE
        ELSE
      NLAMBDALOW  = MINLOC(LMBDMIE,MASK=LMBDMIE.GE.WL_LOW(IBND)*1.E-6)
      NLAMBDAHIGH = MAXLOC(LMBDMIE,MASK=LMBDMIE.LE.WL_HIGH(IBND)*1.0E-6)
        ENDIF
!
!     Loop over all droplet size groups
!
      DRGROUPLOOP: DO ND = 1, NDG
!
      KWR(ND) = EXP(DGROUP_A*REAL(ND,EB) + DGROUP_B)
      CALL DROPLET_SIZE_DISTRIBUTION(2.*KWR(ND),RDDIST,FDDIST,NRDINT,
     .                               GAMMA,SIGMA)     
!
!     Calculate integration weights for droplet radius
!
      RDWGHT(0) = 0.5*(FDDIST(1)-FDDIST(0))
      DO I = 1,NRDINT-1
         RDWGHT(I) = 0.5*(FDDIST(I+1)-FDDIST(I-1))
      ENDDO
      RDWGHT(NRDINT) = 0.5*(FDDIST(NRDINT)-FDDIST(NRDINT-1))
!
!     Loop over wavelengths
!
      IBSUM = 0.
!
      DO J = NLAMBDALOW(1),NLAMBDAHIGH(1)
      IB = PLANCK(RADTMP, LMBDMIE(J)*1.0E6)
      IBSUM = IBSUM + LMBDWGHT(J)*IB
!
      ASUM = 0.
      BSUM = 0.
!
!     Loop over droplet size distribution
!
      DO I = 0,NRDINT
!
!     Integrate effective scattering cross section 
!     = scattering cross section * (1-forward fraction)
!
         CALL INTERPOLATE1D(NRDMIE,RDMIE,QSCA(:,J),RDDIST(I),AVAL)
         CALL INTERPOLATE1D(NRDMIE,RDMIE,CHI_F(:,J),RDDIST(I),BVAL)
         BVAL = (1.-BVAL)
         AVAL = AVAL*BVAL*PI*RDDIST(I)**2
         ASUM = ASUM + RDWGHT(I)*AVAL
!
!     Integrate absorption cross sections
!
         CALL INTERPOLATE1D(NRDMIE,RDMIE,QABS(:,J),RDDIST(I),BVAL)
         BVAL = BVAL*PI*RDDIST(I)**2
         BSUM = BSUM + RDWGHT(I)*BVAL
      ENDDO
      WQSCA(ND,IBND) = WQSCA(ND,IBND) + ASUM*LMBDWGHT(J)*IB
      WQABS(ND,IBND) = WQABS(ND,IBND) + BSUM*LMBDWGHT(J)*IB
      ENDDO
!
!     Normalize with blackbody radiation
!
      WQSCA(ND,IBND)  = WQSCA(ND,IBND)/IBSUM
      WQABS(ND,IBND)  = WQABS(ND,IBND)/IBSUM
!
!     Transform cross sections back to efficiency factors
!
      WQSCA(ND,IBND)  = WQSCA(ND,IBND)/(PI*KWR(ND)**2)
      WQABS(ND,IBND)  = WQABS(ND,IBND)/(PI*KWR(ND)**2)
!
      ENDDO DRGROUPLOOP
      ENDDO BANDLOOP
!
      DEALLOCATE(RDMIE)
      DEALLOCATE(RDWGHT)
      DEALLOCATE(QSCA)
      DEALLOCATE(QABS)
      DEALLOCATE(CHI_F)
      DEALLOCATE(LMBDMIE)
      DEALLOCATE(LMBDWGHT)
      DEALLOCATE(FDDIST)
      DEALLOCATE(RDDIST)
!
      END SUBROUTINE MEAN_CROSS_SECTIONS


      SUBROUTINE INTERPOLATE1D(NX,X,Y,XI,ANS)
      INTEGER NX
      REAL(EB)    X(NX), Y(NX), XI, ANS
      INTEGER JL, JM, JU
c
c     Find the index of the value just below XI
c
      JL = 0
      JU = NX+1
      DO WHILE ((JU-JL).GT.1)
         JM=(JU+JL)/2
         IF ((X(NX).GT.X(1)).EQV.(XI.GT.X(JM))) THEN
            JL = JM
         ELSE
            JU = JM
         ENDIF
      ENDDO
c
c     Interpolate between JL and JL+1
c
      IF (JL.GE.NX) THEN
         ANS = Y(NX)
        ELSEIF (JL.LT.1) THEN
         ANS = Y(1)
        ELSE
         ANS = Y(JL) + (XI-X(JL))
     .   * (Y(JL+1)-Y(JL))  
     .   / (X(JL+1)-X(JL)+1.0E-30*(X(2)-X(1))) 
      ENDIF
      END SUBROUTINE

            
      SUBROUTINE MIE_SCATTERING
c
c     Calculates the scattering and absorption cross sections
c     and calculates forward scattering fraction by integrating 
c     the scattering phase function.
c
c ----------------------------------------------------------------------
c -----------  SPECIFICATIONS FOR SUBROUTINE  MIEV0  ---------------
c ----------------------------------------------------------------------
      INTEGER   MOMDIM
      PARAMETER  ( MOMDIM = 200)
      LOGICAL   ANYANG, PERFCT, PRNT( 2 )
      INTEGER   IPOLZN, NMOM
      REAL(EB)  GQSC, MIMCUT, PMOM( 0:MOMDIM, 4 ), SPIKE, 
     .          QE, QS
      REAL(EB), ALLOCATABLE :: XXX(:)
      COMPLEX(EB) SFORW, SBACK, TFORW( 2 ), TBACK( 2 ), CREFIN
      COMPLEX(EB), ALLOCATABLE :: S1(:), S2(:) 
c
c --------------- LOCAL VARIABLES --------------------------------------

      INTEGER   I, J, K, NX, IZERO
      INTEGER   NLAMBDA, NRA, NMIEANG2
      REAL(EB)  STMP, AIJ, FTMP, XX_MAX
      REAL(EB)  MUMIN1, MUMIN2,THETALIM1, THETALIM2, mudloc
      REAL(EB)  mu1, mu2, nu1, nu2, mud0loc, mudPiloc, mud1, mud2, dmud 
      REAL(EB),ALLOCATABLE :: XMU1(:), XNU1(:),XMU2(:),
     .         ANGLE1(:), ANGLE2(:), MUD(:), MUDX(:),PWGHT(:),
     .         PHSFUN(:), PFOR(:,:), MUD0(:,:), MUDPI(:,:)
c ----------------------------------------------------------------------
c
      NRA    = NUMBER_RADIATION_ANGLES
c
c     MIEV-code variables
c
      MIMCUT = 1.E-6
      PERFCT = .FALSE.
      ANYANG = .TRUE.
c      IPOLZN = +1234
      IPOLZN = 0
      NMOM   = 0
      PRNT   = .FALSE.
c
c     Limit for XX
c
      XX_MAX = 15000.0
c
c     Integration limits
c
      THETALIM1 = ACOS(1. - 2./REAL(NRA))
      MUMIN1 = COS(THETALIM1)
      MUMIN2 = MUMIN1**2-(1.-MUMIN1**2)
      THETALIM2 = ACOS(MUMIN2)
      NMIEANG2 = NMIEANG*2
c
c     Allocate local arrays
c
      ALLOCATE(XXX(1:NRDMIE),STAT=IZERO)
      CALL ChkMemErr('INIT','XXX',IZERO)
      ALLOCATE(S1(1:NMIEANG2),STAT=IZERO)
      CALL ChkMemErr('INIT','S1',IZERO)
      ALLOCATE(S2(1:NMIEANG2),STAT=IZERO)
      CALL ChkMemErr('INIT','S2',IZERO)
      ALLOCATE(XMU1(1:NMIEANG),STAT=IZERO)
      CALL ChkMemErr('INIT','XMU1',IZERO)
      ALLOCATE(XNU1(1:NMIEANG),STAT=IZERO)
      CALL ChkMemErr('INIT','XNU1',IZERO)
      ALLOCATE(XMU2(1:NMIEANG2),STAT=IZERO)
      CALL ChkMemErr('INIT','XMU2',IZERO)
      ALLOCATE(MUD(1:NMIEANG2),STAT=IZERO)
      CALL ChkMemErr('INIT','MUD',IZERO)
      ALLOCATE(MUDX(1:NMIEANG2),STAT=IZERO)
      CALL ChkMemErr('INIT','MUDX',IZERO)
      ALLOCATE(PWGHT(1:NMIEANG2),STAT=IZERO)
      CALL ChkMemErr('INIT','PWGHT',IZERO)
      ALLOCATE(ANGLE1(1:NMIEANG),STAT=IZERO)
      CALL ChkMemErr('INIT','ANGLE1',IZERO)
      ALLOCATE(ANGLE2(1:NMIEANG2),STAT=IZERO)
      CALL ChkMemErr('INIT','ANGLE2',IZERO)
      ALLOCATE(PHSFUN(1:NMIEANG2),STAT=IZERO)
      CALL ChkMemErr('INIT','PHSFUN',IZERO)
      ALLOCATE(PFOR(1:NMIEANG,1:NMIEANG),STAT=IZERO)
      CALL ChkMemErr('INIT','PFOR',IZERO)
      ALLOCATE(MUD0(1:NMIEANG,1:NMIEANG),STAT=IZERO)
      CALL ChkMemErr('INIT','MUD0',IZERO)
      ALLOCATE(MUDPI(1:NMIEANG,1:NMIEANG),STAT=IZERO)
      CALL ChkMemErr('INIT','MUDPI',IZERO)
c
c     Create solid angle integration arrays
c
      DO I = 1,NMIEANG
         ANGLE1(I) = THETALIM1*REAL(I-1)/REAL(NMIEANG-1)
         ANGLE1(I) = ANGLE1(I)*(1.-0.99*REAL(NMIEANG-I)/REAL(NMIEANG))
      ENDDO
      DO I = 1,NMIEANG
        XMU1(NMIEANG-I+1) = COS(ANGLE1(I))
        XNU1(NMIEANG-I+1) = SIN(ANGLE1(I))
      ENDDO
c
c     Create phase function ingtegration arrays
c
      DO I = 1,NMIEANG2
         ANGLE2(I) = THETALIM2*REAL(I-1)/REAL(NMIEANG2-1)
         ANGLE2(I) = ANGLE2(I)*(1.-0.99*REAL(NMIEANG2-I)/REAL(NMIEANG2))
      ENDDO
      DO I = 1,NMIEANG2
         XMU2(NMIEANG2-I+1) = COS(ANGLE2(I))
      ENDDO
c
c     Calculate phase function ingetration limits
c
      DO J = 1,NMIEANG
      DO I = 1,NMIEANG
         MUD0(I,J)  = XMU1(I)*XMU1(J) + XNU1(I)*XNU1(J)
         MUDPI(I,J) = XMU1(I)*XMU1(J) - XNU1(I)*XNU1(J)
      ENDDO
      ENDDO
c
c     Calculate phase function integration weights
c
      mu1 = 0.7
      mu2 = 0.9
      nu1 = SQRT(1-mu1**2)
      nu2 = SQRT(1-mu2**2)
      mud0loc  = mu1*mu2 + nu1*nu2
      mudPiloc = mu1*mu2 - nu1*nu2
      mud1 = mudPiloc
      mud2 = mud0loc
      dmud = (mud2-mud1)/(NMIEANG2-1);
      DO I = 1,NMIEANG2
      mud(I) = mud1+REAL(I-1)*dmud
      ENDDO
      mud(1)       = mud(1)       + 0.25*dmud !empirical
      mud(NMIEANG2) = mud(NMIEANG2) - 0.25*dmud !empirical
      DO I = 1,NMIEANG2
        MUDX(I) = (mud(I)-mud1)/(mud2-mud1)
      ENDDO
      DO I = 1,NMIEANG2
         PWGHT(I) = dmud/sqrt((nu1*nu2)**2-(mud(I)-mu1*mu2)**2)
      ENDDO
      PWGHT(2)         = 0.5*PWGHT(2);
      PWGHT(NMIEANG2-1) = 0.5*PWGHT(NMIEANG2-1);
c
c     Loop over wavelength
c
      LAMBDALOOP: DO NLAMBDA = 1, NWATERK
c
      CREFIN = CMPLX( 1.33, CPLXREF(NLAMBDA,2) )
      LMBDMIE(NLAMBDA) = CPLXREF(NLAMBDA,1)
c
c     Loop over droplet radius
c
      RADIUSLOOP: DO NX = 1, NRDMIE
c
      XXX(NX) = MIN(XX_MAX,2.*PI*RDMIE(NX)/LMBDMIE(NLAMBDA))
c
      CALL MIEV0( XXX(NX), CREFIN, PERFCT, MIMCUT, ANYANG,  
     .            NMIEANG2, XMU2, NMOM, IPOLZN, MOMDIM, PRNT, 
     .            QE, QS, GQSC, 
     .            PMOM, SFORW, SBACK, S1, S2, TFORW, TBACK, SPIKE )
c
      QSCA(NX,NLAMBDA) = QS
      QABS(NX,NLAMBDA) = QE-QS
c
c     Calculate single drop phase function
c
      DO I = 1,NMIEANG2
        PHSFUN(I) = 2.*(abs(S1(I))**2 + abs(S2(I))**2 )
      ENDDO
      PHSFUN = PHSFUN/(QS*XXX(NX)**2)
c
c     Calculate the innermost integral of the forward scattering fraction
c
      PFOR = 0.
      DO J = 1,NMIEANG
      DO I = J,NMIEANG
         IF (MUD0(I,J).EQ. MUDPI(I,J)) THEN
            CALL INTERPOLATE1D(NMIEANG2,XMU2,PHSFUN,MUD0(I,J),FTMP)
            PFOR(I,J) = PI*FTMP
         ELSE
            mud1 = MUDPI(I,J) 
            mud2 = MUD0(I,J)
            STMP = 0.0
            DO K = 1,NMIEANG2
               mudloc = mud1+MUDX(K)*(mud2-mud1)
               CALL INTERPOLATE1D(NMIEANG2,XMU2,PHSFUN,mudloc,FTMP)
               STMP = STMP + PWGHT(K)*FTMP
            ENDDO
            PFOR(I,J) = STMP 
         ENDIF
      ENDDO
      ENDDO
c
c     Calculate the two outer integrals of the forward fraction
c
      STMP = 0.
      DO J = 1,NMIEANG-1
      DO I = J+1,NMIEANG-1
          AIJ = (XMU1(I+1)-XMU1(I))*(XMU1(J+1)-XMU1(J))/2.
         STMP = STMP + 
     .   (2.*PFOR(I,J)+PFOR(I+1,J)+PFOR(I,J+1)+2.*PFOR(I+1,J+1))*AIJ/3.
      ENDDO
      ENDDO
      DO I = 1,NMIEANG-1
          AIJ = ((XMU1(I+1)-XMU1(I))**2)/2.
         STMP = STMP + (PFOR(I,I)+PFOR(I+1,I)+PFOR(I+1,I+1))*AIJ/3.
      ENDDO
      CHI_F(NX,NLAMBDA) = 2.*STMP/(4.*PI/NRA)      
c
      ENDDO RADIUSLOOP
      ENDDO LAMBDALOOP
c
      DEALLOCATE(XXX)
      DEALLOCATE(S1)
      DEALLOCATE(S2)
      DEALLOCATE(XMU1)
      DEALLOCATE(XNU1)
      DEALLOCATE(XMU2)
      DEALLOCATE(MUD)
      DEALLOCATE(MUDX)
      DEALLOCATE(PWGHT)
      DEALLOCATE(ANGLE1)
      DEALLOCATE(ANGLE2)
      DEALLOCATE(PHSFUN)
      DEALLOCATE(PFOR)
      DEALLOCATE(MUD0)
      DEALLOCATE(MUDPI)
c
      END SUBROUTINE MIE_SCATTERING

      SUBROUTINE MIEV0( XX, CREFIN, PERFCT, MIMCUT, ANYANG, NUMANG, XMU,
     &                  NMOM, IPOLZN, MOMDIM, PRNT, QEXT, QSCA, GQSC,
     &                  PMOM, SFORW, SBACK, S1, S2, TFORW, TBACK,
     &                  SPIKE )
c
c     Mie scattering for a single droplet and wavelength.
c     Author:  Dr. Warren J. Wiscombe (wiscombe@climate.gsfc.nasa.gov)
c         NASA Goddard Space Flight Center
c         Code 913
c         Greenbelt, MD 20771
c
c     REFERENCES
c     ----------
c
c     (1) Wiscombe, W., 1979: Mie Scattering Calculations--Advances
c         in Technique And Fast, Vector-Speed Computer Codes,
c         Ncar Tech Note TN-140+STR, National Center For
c         Atmospheric Research, Boulder, Colorado (out of print
c         but an updated electronic version available)
c
c     (2) Wiscombe, W., 1980: Improved Mie scattering algorithms,
c         Appl. Opt. 19, 1505-1509
c

c    Computes Mie scattering and extinction efficiencies; asymmetry
c    factor;  forward- and backscatter amplitude;  scattering
c    amplitudes vs. scattering angle for incident polarization parallel
c    and perpendicular to the plane of scattering;
c    coefficients in the Legendre polynomial expansions of either the
c    unpolarized phase function or the polarized phase matrix;
c    some quantities needed in polarized radiative transfer;  and
c    information about whether or not a resonance has been hit.
c
c    Input and output variables are described in file MIEV.doc. 
c    Many statements are accompanied by comments referring to 
c    references in MIEV.doc, notably the NCAR Mie report which is now
c    available electronically and which is referred to using the
c    shorthand (Rn), meaning Eq. (n) of the report.

c    CALLING TREE:
c
c        MIEV0
c            TESTMI
c                TSTBAD
c                MIPRNT
c                ERRMSG
c            CKINMI
c                WRTBAD
c                WRTDIM
c                ERRMSG
c            SMALL1
c            SMALL2
c            ERRMSG
c            BIGA
c                CONFRA
c                    ERRMSG
c            LPCOEF
c                LPCO1T
c                LPCO2T
c                ERRMSG
c            MIPRNT
c
c   I N P U T   V A R I A B L E S
c   -----------------------------
c
c  ( Even if an input variable is not needed for a particular
c    application, make sure it has a legitimate value that can
c    be written out and read in -- no indefinites, etc. )
c
c  XX        Mie size parameter ( 2 * pi * radius / wavelength )
c
c  CREFIN    Complex refractive index ( imag part can be + or -,
c            but internally a negative imaginary index is assumed ).
c            If imag part is - ,  scattering amplitudes as in Van
c            de Hulst are returned;  if imag part is + , complex
c            conjugates of those scattering amplitudes are returned
c            (the latter is the convention in physics).
c            ** NOTE ** In the 'PERFECT' case, scattering amplitudes
c            in the Van de Hulst (Ref. 6 above) convention will
c            automatically be returned unless  Im(CREFIN)  is
c            positive;  otherwise, CREFIN plays no role.
c
c  PERFCT    TRUE, assume refractive index is infinite and use
c            special case formulas for Mie coefficients  'a'
c            and  'b'  ( see Kerker, M., The Scattering of
c            Light and Other Electromagnetic Radiation, p. 90 ).
c            This is sometimes called the 'totally reflecting',
c            sometimes the 'perfectly conducting' case.
c            ( see CREFIN for additional information )
c
c  MIMCUT    (positive) value below which imaginary refractive
c            index is regarded as zero (computation proceeds
c            faster for zero imaginary index)
c
c  ANYANG    TRUE, any angles whatsoever may be input through
c            XMU.  FALSE, the angles are monotone increasing
c            and mirror symmetric about 90 degrees (this option
c            is advantageous because the scattering amplitudes
c            S1,S2 for the angles between 90 and 180 degrees
c            are evaluable from symmetry relations, and hence
c            are obtained with little added computational cost.)
c
c  NUMANG    No. of angles at which scattering amplitudes
c            S1,S2 are to be evaluated  ( set = 0 to skip
c            calculation of S1,S2 ).  Make sure NUMANG does
c            not exceed the parameter MAXANG in the program.
c
c  XMU(N)    Cosines of angles ( N = 1 TO NUMANG ) at which S1,S2
c            are to be evaluated.  If ANYANG = FALSE, then
c
c             (a) the angles must be monotone increasing and
c                 mirror symmetric about 90 degrees (if 90-A is
c                 an angle, then 90+A must be also)
c
c             (b) if NUMANG is odd, 90 degrees must be among
c                 the angles
c
c  NMOM       Highest Legendre moment PMOM to calculate,
c             numbering from zero ( NMOM = 0 prevents
c             calculation of PMOM )
c
c  IPOLZN     POSITIVE, Compute Legendre moments PMOM for the
c                       Mueller matrix elements determined by the
c                       digits of IPOLZN, with 1 referring to M1,
c                       2 to M2, 3 to S21, and 4 to D21 (Ref. 3).
c                       E.g., if IPOLZN = 14 then only moments for
c                       M1 and D21 will be returned.
c
c             0,        Compute Legendre moments PMOM for the
c                       unpolarized unnormalized phase function.
c
c             NEGATIVE, Compute Legendre moments PMOM for the
c                       Sekera phase quantities determined by the
c                       digits of ABS(IPOLZN), with 1 referring to
c                       R1, 2 to R2, 3 to R3, and 4 to R4 (REF. 4).
c                       E.g., if IPOLZN = -14 then only moments for
c                       R1 and R4 will be returned.
c
c             ( NOT USED IF  NMOM = 0 )
c
c  MOMDIM     Determines first dimension of PMOM, which is dimensioned
c             internally as PMOM( 0:MOMDIM, * ) (second dimension must
c             be the larger of unity and the highest digit in
c             IPOLZN; if not, serious errors will occur).
c             Must be given a value, even if  NMOM = 0.  Minimum: 1.
c
c  PRT(L)     Print flags (LOGICAL).  L = 1  prints  S1,S2, their
c             squared absolute values, and degree of polarization,
c             provided NUMANG is non-zero.   L = 2  prints all
c             output variables other than  S1,S2.
c
c
c O U T P U T   V A R I A B L E S
c -------------------------------
c
c  QEXT      (REAL) extinction efficiency factor  ( Ref. 2, Eq. 1A )
c
c  QSCA      (REAL) scattering efficiency factor  ( Ref. 2, Eq. 1B )
c
c  GQSC      (REAL) asymmetry factor times scattering efficiency
c            ( Ref. 2, Eq. 1C )  ( allows calculation of radiation
c            pressure efficiency factor  QPR = QEXT - GQSC )
c
c  =====================================================================
c  ==== NOTE --  S1, S2, SFORW, SBACK, TFORW, AND TBACK are calculated
c  ====          internally for negative imaginary refractive index;
c  ====          for positive imaginary index, their complex conjugates
c  ====          are taken before they are returned, to correspond to
c  ====          customary usage in some parts of physics ( in parti-
c  ====          cular, in papers on CAM approximations to Mie theory ).
c  =====================================================================
c
c  S1(N),    (COMPLEX) Mie scattering amplitudes at angles specified
c  S2(N)     by XMU(N) ( N=1 to NUMANG )  ( Ref. 2, Eqs. 1d-e ).
c
c  SFORW     (COMPLEX) forward-scattering amplitude S1 at
c            0 degrees.  ( S2(0 deg) = S1(0 deg) )
c
c  SBACK     (COMPLEX) backscattering amplitude S1 at
c            180 degrees.   ( S2(180 deg) = - S1(180 deg) )
c
c  TFORW(I)  (COMPLEX) values of
c
c                I=1:  T1 = ( S2 - (MU)*S1 ) / ( 1 - MU**2 )
c                I=2:  T2 = ( S1 - (MU)*S2 ) / ( 1 - MU**2 )
c
c            At angle theta = 0 ( MU = COS(theta) = 1 ), where the
c            expressions on the right-hand side are indeterminate.
c            ( these quantities are required for doing polarized
c            radiative transfer (Ref. 4, Appendix). )
c
c  TBACK(I)  (COMPLEX) values of  T1 (for I=1) or  T2 (for I=2) at
c            angle  theta = 180 degrees ( MU = COS(theta) = - 1 ).
c
c  SPIKE     (REAL) magnitude of the smallest denominator of
c            either Mie coefficient (a-sub-n or b-sub-n),
c            taken over all terms in the Mie series past
c            N = size parameter XX.  Values of SPIKE below
c            about 0.3 signify a ripple spike, since these
c            spikes are produced by abnormally small denominators
c            in the Mie coefficients (normal denominators are of
c            order unity or higher).  Defaults to 1.0 when not
c            on a spike.  Does not identify all resonances
c            (we are still working on that).
c
c PMOM(M,NP) (REAL) moments  M = 0 to NMOM  of unnormalized NP-th
c            phase quantity PQ  ( moments with  M .GT. 2*NTRM  are
c            zero, where  NTRM = no. terms in Mie series =
c            XX + 4*XX**1/3 + 1 ) :
c
c              PQ( MU, NP ) = sum( M=0 to infinity ) ( (2M+1)
c                                * PMOM( M,NP ) * P-sub-M( MU ) )
c
c            WHERE  MU = COS( scattering angle )
c                   P-sub-M = M-th Legendre polynomial
c
c            and the definition of 'PQ' is as follows:
c
c            IPOLZN.GT.0:  PQ(MU,1) = CABS( S1(MU) )**2
c                          PQ(MU,2) = CABS( S2(MU) )**2
c                          PQ(MU,3) = RE( S1(MU)*CONJG( S2(MU) ) )
c                          PQ(MU,4) = - IM( S1(MU)*CONJG( S2(MU) ) )
c                          ( called M1, M2, S21, D21 in literature )
c
c            IPOLZN=0:  PQ(MU,1) = ( CABS(S1)**2 + CABS(S2)**2 ) / 2
c                       ( the unnormalized phase function )
c
c            IPOLZN.LT.0:  PQ(MU,1) = CABS( T1(MU) )**2
c                          PQ(MU,2) = CABS( T2(MU) )**2
c                          PQ(MU,3) = RE( T1(MU)*CONJG( T2(MU) ) )
c                          PQ(MU,4) = - IM( T1(MU)*CONJG( T2(MU) ) )
c                          ( called R1, R2, R3, R4 in literature )
c
c            The sign of the 4th phase quantity is a source of
c            confusion.  It flips if the complex conjugates of
c            S1,S2  or  T1,T2  are used, as occurs when a
c            refractive index with positive imaginary part is
c            used (see discussion below).  The definition above
c            is consistent with a negative imaginary part.
c
c            ** WARNING **  Make sure the second dimension of PMOM
c            in the calling program is at least as large as the
c            absolute value of IPOLZN.
c
c            For small enough values of XX, or large enough values
c            of M,  PMOM  will tend to underflow.  Thus, it is
c            unwise to assume the values returned are non-zero and,
c            for example, to divide some quantity by them.
c


c      I N T E R N A L   V A R I A B L E S
c      -----------------------------------

c  AN,BN           Mie coefficients a-sub-n, b-sub-n ( Ref. 1, Eq. 16 )
c  ANM1,BNM1       Mie coefficients  a-sub-(n-1),
c                     b-sub-(n-1);  used in GQSC sum
c  ANP             Coeffs. in S+ expansion ( Ref. 2, p. 1507 )
c  BNP             Coeffs. in S- expansion ( Ref. 2, p. 1507 )
c  ANPM            Coeffs. in S+ expansion ( Ref. 2, p. 1507 )
c                     when  MU  is replaced by  - MU
c  BNPM            Coeffs. in S- expansion ( Ref. 2, p. 1507 )
c                     when  MU  is replaced by  - MU
c  CALCMO(K)       TRUE, calculate moments for K-th phase quantity
c                     (derived from IPOLZN)
c  CBIGA(N)        Bessel function ratio A-sub-N (Ref. 2, Eq. 2)
c                     ( COMPLEX version )
c  CDENAN,         (COMPLEX) denominators of An,Bn
c   CDENBN
c  CIOR            Complex index of refraction with negative
c                     imaginary part (Van de Hulst convention)
c  CIORIV          1 / cIoR
c  COEFF           ( 2N + 1 ) / ( N ( N + 1 ) )
c  CSUM1,2         temporary sum variables for TFORW, TBACK
c  FN              Floating point version of loop index for
c                     Mie series summation
c  LITA,LITB(N)    Mie coefficients An, Bn, saved in arrays for
c                     use in calculating Legendre moments PMOM
c  MAXTRM          Max. possible no. of terms in Mie series
c  MM              (-1)^(n+1), where n is Mie series sum index 
c  MIM             Magnitude of imaginary refractive index
c  MRE             Real part of refractive index
c  MAXANG          Max. possible value of input variable NUMANG
c  NANGD2          (NUMANG+1)/2 ( no. of angles in 0-90 deg; ANYANG=F )
c  NOABS           TRUE, sphere non-absorbing (determined by MIMCUT)
c  NP1DN           ( N + 1 ) / N
c  NPQUAN          Highest-numbered phase quantity for which moments are
c                     to be calculated (the largest digit in IPOLZN
c                     if  IPOLZN .NE. 0)
c  NTRM            No. of terms in Mie series
c  PASS1           TRUE on first entry, FALSE thereafter; for self-test
c  PIN(J)          Angular function pi-sub-n ( Ref. 2, Eq. 3 )
c                     at J-th angle
c  PINM1(J)        pi-sub-(n-1) ( see PIn ) at J-th angle
c  PSINM1          Ricatti-Bessel function psi-sub-(n-1), argument XX
c  PSIN            Ricatti-Bessel function psi-sub-n of argument XX
c                     ( Ref. 1, p. 11 ff. )
c  RBIGA(N)        Bessel function ratio A-sub-N (Ref. 2, Eq. 2)
c                     ( REAL version, for when imag refrac index = 0 )
c  RIORIV          1 / Mre
c  RN              1 / N
c  RTMP            (REAL) temporary variable
c  SP(J)           S+  for J-th angle  ( Ref. 2, p. 1507 )
c  SM(J)           S-  for J-TH angle  ( Ref. 2, p. 1507 )
c  SPS(J)          S+  for (NUMANG+1-J)-th angle ( ANYANG=FALSE )
c  SMS(J)          S-  for (NUMANG+1-J)-th angle ( ANYANG=FALSE )
c  TAUN            Angular function tau-sub-n ( Ref. 2, Eq. 4 )
c                     at J-th angle
c  TCOEF           N ( N+1 ) ( 2N+1 ) (for summing TFORW,TBACK series)
c  TWONP1          2N + 1
c  YESANG          TRUE if scattering amplitudes are to be calculated
c  ZETNM1          Ricatti-Bessel function  zeta-sub-(n-1) of argument
c                     XX  ( Ref. 2, Eq. 17 )
c  ZETN            Ricatti-Bessel function  zeta-sub-n of argument XX
c ----------------------------------------------------------------------
c
      IMPLICIT  NONE
c
c ----------------------------------------------------------------------
c --------  I / O SPECIFICATIONS FOR SUBROUTINE MIEV0  -----------------
c ----------------------------------------------------------------------
      LOGICAL     ANYANG, PERFCT, PRNT(*)
      INTEGER     IPOLZN, MOMDIM, NUMANG, NMOM
      REAL(EB)    GQSC, MIMCUT, PMOM( 0:MOMDIM, * ), QEXT, QSCA, SPIKE,
     &            XMU(*), XX
      COMPLEX(EB) CREFIN, SFORW, SBACK, S1(*), S2(*), TFORW(*), TBACK(*)
c ----------------------------------------------------------------------
c
c                                  ** NOTE --  MAXTRM = 10100  is neces-
c                                  ** sary to do some of the test probs,
c                                  ** but 1100 is sufficient for most
c                                  ** conceivable applications
c     .. Parameters ..

      INTEGER     MAXANG, MXANG2
      PARAMETER   ( MAXANG = 5000, MXANG2 = MAXANG / 2 + 1 )
      INTEGER     MAXTRM
c      PARAMETER ( MAXTRM = 10100 )
      PARAMETER   ( MAXTRM = 16000 ) ! works for FDS
      REAL(EB)    ONETHR
      PARAMETER   ( ONETHR = 1. / 3. )
c     ..
c     .. Local Scalars ..

      LOGICAL     NOABS, PASS1, YESANG
      INTEGER     I, J, N, NANGD2, NPQUAN, NTRM
      REAL(EB)    CHIN, CHINM1, COEFF, DENAN, DENBN, FN, MIM, MM, MRE,
     &            NP1DN, PSIN, PSINM1, RATIO, RIORIV, RN, RTMP, TAUN,
     &            TCOEF, TWONP1, XINV
      COMPLEX(EB) AN, ANM1, ANP, ANPM, BN, BNM1, BNP, BNPM, CDENAN,
     &            CDENBN, CIOR, CIORIV, CSUM1, CSUM2, ZET, 
     &            ZETN, ZETNM1
c     ..
c     .. Local Arrays ..

      LOGICAL     CALCMO( 4 )
      REAL(EB), ALLOCATABLE :: PIN(:), PINM1(:), RBIGA(:)
      COMPLEX(EB) CBIGA( MAXTRM ), LITA( MAXTRM ), LITB( MAXTRM )
      COMPLEX(EB), ALLOCATABLE :: SM(:), SMS(:), SP(:), SPS(:)

      SAVE      PASS1
      DATA      PASS1 / .TRUE. /
c
      ALLOCATE(PIN(1:NUMANG)) 
      ALLOCATE(PINM1(1:NUMANG))
      ALLOCATE(RBIGA(1:NUMANG))
      ALLOCATE(SM(1:NUMANG)) 
      ALLOCATE(SMS(1:(NUMANG+1)/2)) 
      ALLOCATE(SP(1:NUMANG)) 
      ALLOCATE(SPS(1:(NUMANG+1)/2)) 
c
c                    ** Save some input variables and replace them
c                    ** with values needed to do the self-test
c
      IF( PASS1 ) CALL TESTMI( .FALSE., XX, CREFIN, MIMCUT, PERFCT,
     &                         ANYANG, NMOM, IPOLZN, NUMANG, XMU, QEXT,
     &                         QSCA, GQSC, SFORW, SBACK, S1, S2, TFORW,
     &                         TBACK, PMOM, MOMDIM )

   10 CONTINUE
c                                        ** Check input and calculate
c                                        ** certain variables from input
      CALL CKINMI( NUMANG, MAXANG, XX, PERFCT, CREFIN, MOMDIM, NMOM,
     &             IPOLZN, ANYANG, XMU, CALCMO, NPQUAN )
!
      IF( PERFCT .AND. XX.LE.0.1 ) THEN
c                                            ** Use totally-reflecting
c                                            ** small-particle limit
         CALL SMALL1( XX, NUMANG, XMU, QEXT, QSCA, GQSC, SFORW, SBACK,
     &                S1, S2, TFORW, TBACK, LITA, LITB )
         NTRM = 2
         GO TO  100
      END IF
      NOABS = .TRUE.
!
      IF( .NOT.PERFCT ) THEN
         CIOR = CREFIN
         IF( AIMAG(CIOR).GT.0.0 ) CIOR = CONJG( CIOR )
         MRE    = REAL( CIOR )
         MIM    = -AIMAG( CIOR )
         NOABS  = MIM.LE.MIMCUT
         CIORIV = 1.0 / CIOR
         RIORIV = 1.0 / MRE
!
         IF( XX*MAX( 1._EB, ABS(CIOR) ).LE.0.1 ) THEN
c                                    ** Use general-refractive-index
c                                    ** small-particle limit
            CALL SMALL2( XX, CIOR, MIM.GT.MIMCUT, NUMANG, XMU, QEXT,
     &                   QSCA, GQSC, SFORW, SBACK, S1, S2, TFORW,
     &                   TBACK, LITA, LITB )
            NTRM = 2
            GO TO  100
         END IF
      END IF
!
      NANGD2 = ( NUMANG + 1 ) / 2
      YESANG = NUMANG.GT.0
c                              ** Number of terms in Mie series; Eq R50
      IF( XX.LE.8.0 ) THEN
         NTRM = XX + 4.*XX**ONETHR + 1.
      ELSE IF( XX.LT.4200. ) THEN
         NTRM = XX + 4.05*XX**ONETHR + 2.
      ELSE
         NTRM = XX + 4.*XX**ONETHR + 2.
      END IF
      IF( NTRM+1 .GT. MAXTRM )
     &    CALL ERRMSG('MIEV0--PARAMETER MaxTrm TOO SMALL',.TRUE.)
c                            ** Calculate logarithmic derivatives of
c                            ** J-Bessel-fcn., A-sub-(1 to NTrm)
      IF( .NOT.PERFCT ) CALL BIGA( CIOR, XX, NTRM, NOABS, YESANG, RBIGA,
     &                             CBIGA )
c                            ** Initialize Ricatti-Bessel functions
c                            ** (psi,chi,zeta)-sub-(0,1) for upward
c                            ** recurrence ( Eq. R19 )
      XINV   = 1.0 / XX
      PSINM1 = SIN( XX )
      CHINM1 = COS( XX )
      PSIN   = PSINM1*XINV - CHINM1
      CHIN   = CHINM1*XINV + PSINM1
      ZETNM1 = CMPLX( PSINM1, CHINM1 )
      ZETN   = CMPLX( PSIN, CHIN )
c                                     ** Initialize previous coeffi-
c                                     ** cients for GQSC series
      ANM1 = ( 0.0, 0.0 )
      BNM1 = ( 0.0, 0.0 )
c                             ** Initialize angular function  pi
c                             ** and sums for S+, S- ( Ref. 2, p. 1507 )
      IF( ANYANG ) THEN
         DO 20 J = 1, NUMANG
c                             ** Eq. R39
            PINM1( J ) = 0.0
            PIN( J ) = 1.0
!
            SP( J ) = ( 0.0, 0.0 )
            SM( J ) = ( 0.0, 0.0 )
   20    CONTINUE
      ELSE
         DO 30 J = 1, NANGD2
c                             ** Eq. R39
            PINM1( J ) = 0.0
            PIN( J ) = 1.0
            SP( J ) = ( 0.0, 0.0 )
            SM( J ) = ( 0.0, 0.0 )
            SPS( J ) = ( 0.0, 0.0 )
            SMS( J ) = ( 0.0, 0.0 )
   30    CONTINUE
      END IF
c                       ** Initialize Mie sums for efficiencies, etc.
      QSCA  = 0.0
      GQSC  = 0.0
      SFORW = ( 0., 0. )
      SBACK = ( 0., 0. )
      CSUM1 = ( 0., 0. )
      CSUM2 = ( 0., 0. )
c
c ---------  LOOP TO SUM MIE SERIES  -----------------------------------
      MM     = +1.0
      SPIKE  = 1.0
      DO 60  N = 1, NTRM
c                           ** Compute various numerical coefficients
         FN     = N
         RN     = 1.0 / FN
         NP1DN  = 1.0 + RN
         TWONP1 = 2*N + 1
         COEFF  = TWONP1 / ( FN * ( N + 1 ) )
         TCOEF  = TWONP1 * ( FN * ( N + 1 ) )
c                           ** Calculate Mie series coefficients
         IF( PERFCT ) THEN
c                                 ** Totally-reflecting case; Eq R/A.1,2
            AN = ( ( FN*XINV )*PSIN - PSINM1 ) /
     &           ( ( FN*XINV )*ZETN - ZETNM1 )
            BN = PSIN / ZETN
         ELSE IF( NOABS ) THEN
c                                      ** No-absorption case; Eq (R16)
            CDENAN = ( RIORIV*RBIGA(N) + ( FN*XINV ) ) * ZETN - ZETNM1
            AN   = ( ( RIORIV*RBIGA(N) + ( FN*XINV ) ) * PSIN - PSINM1 )
     &             / CDENAN
            CDENBN = ( MRE*RBIGA(N) + ( FN*XINV ) ) * ZETN - ZETNM1
            BN   = ( ( MRE*RBIGA(N) + ( FN*XINV ) ) * PSIN - PSINM1 )
     &             / CDENBN
         ELSE
c                                       ** Absorptive case; Eq (R16)
            CDENAN = ( CIORIV*CBIGA( N ) + ( FN*XINV ) )*ZETN - ZETNM1
            CDENBN =   ( CIOR*CBIGA( N ) + ( FN*XINV ) )*ZETN - ZETNM1
            AN   = ( ( CIORIV*CBIGA( N ) + ( FN*XINV ) )*PSIN - PSINM1 )
     &             / CDENAN
            BN     = ( ( CIOR*CBIGA( N ) + ( FN*XINV ) )*PSIN - PSINM1 )
     &             / CDENBN
c                                         ** Eq (R7)
            QSCA   = QSCA + TWONP1*( SQ( AN ) + SQ( BN ) )
         END IF
c                       ** Save Mie coefficients for PMOM calculation
         LITA( N ) = AN
         LITB( N ) = BN
!
         IF( .NOT.PERFCT .AND. N.GT.XX ) THEN
c                                               ** Flag resonance spikes
            DENAN  = ABS( CDENAN )
            DENBN  = ABS( CDENBN )
c                                                   ** Eq. R/B.9
            RATIO  = DENAN / DENBN
c                                                   ** Eq. R/B.10
            IF( RATIO.LE.0.2 .OR. RATIO.GE.5.0 )
     &          SPIKE = MIN( SPIKE, DENAN, DENBN )
         END IF
c                                  ** Increment Mie sums for non-angle-
c                                  ** dependent quantities
c                                                   ** Eq. R/B.2
         SFORW = SFORW + TWONP1*( AN + BN )
c                                                   ** Eq. R/B.5,6
         CSUM1 = CSUM1 + TCOEF *( AN - BN )
c                                                   ** Eq. R/B.1
         SBACK = SBACK + ( MM*TWONP1 )*( AN - BN )
c                                                   ** Eq. R/B.7,8
         CSUM2 = CSUM2 + ( MM*TCOEF ) *( AN + BN )
c                                         ** Eq (R8)
         GQSC  = GQSC  + ( FN - RN ) * REAL( ANM1 * CONJG( AN ) +
     &                                       BNM1 * CONJG( BN ) )
     &           + COEFF * REAL( AN * CONJG( BN ) )
         IF( YESANG ) THEN
c                                      ** Put Mie coefficients in form
c                                      ** needed for computing S+, S-
c                                      ** ( Eq R10 )
            ANP = COEFF*( AN + BN )
            BNP = COEFF*( AN - BN )
c                                      ** Increment Mie sums for S+, S-
c                                      ** while upward recursing
c                                      ** angular functions pi and tau
            IF( ANYANG ) THEN
c                                         ** Arbitrary angles
c                                              ** vectorizable loop
               DO 40 J = 1, NUMANG
c                                                 ** Eq. (R37b)
                  RTMP = ( XMU(J) * PIN(J) ) - PINM1( J )
c                                                 ** Eq. (R38b)
                  TAUN   = FN * RTMP - PINM1( J )
c                                                   ** Eq (R10)
                  SP( J ) = SP( J ) + ANP * ( PIN( J ) + TAUN )
                  SM( J ) = SM( J ) + BNP * ( PIN( J ) - TAUN )
                  PINM1( J ) = PIN( J )
c                                                 ** Eq. R37c
                  PIN( J ) = ( XMU( J ) * PIN( J ) ) + NP1DN * RTMP
   40          CONTINUE
            ELSE
c                                  ** Angles symmetric about 90 degrees
               ANPM = MM*ANP
               BNPM = MM*BNP
c                                          ** vectorizable loop
               DO 50 J = 1, NANGD2
c                                                 ** Eq. (R37b)
                  RTMP = ( XMU(J) * PIN(J) ) - PINM1( J )
c                                                 ** Eq. (R38b)
                  TAUN = FN * RTMP - PINM1( J )
c                                                 ** Eq (R10,12)
                  SP ( J ) = SP ( J ) + ANP * ( PIN( J ) + TAUN )
                  SMS( J ) = SMS( J ) + BNPM *( PIN( J ) + TAUN )
                  SM ( J ) = SM ( J ) + BNP * ( PIN( J ) - TAUN )
                  SPS( J ) = SPS( J ) + ANPM *( PIN( J ) - TAUN )
                  PINM1( J ) = PIN( J )
c                                                 ** Eq. R37c
                  PIN( J ) = ( XMU(J) * PIN(J) ) + NP1DN * RTMP
   50          CONTINUE
            END IF
         END IF
c                          ** Update relevant quantities for next
c                          ** pass through loop
         MM   = - MM
         ANM1 = AN
         BNM1 = BN
c                           ** Upward recurrence for Ricatti-Bessel
c                           ** functions ( Eq. R17 )
         ZET    = ( TWONP1*XINV ) * ZETN - ZETNM1
         ZETNM1 = ZETN
         ZETN   = ZET
         PSINM1 = PSIN
         PSIN   = REAL( ZETN )
   60 CONTINUE
c ---------- END LOOP TO SUM MIE SERIES --------------------------------
c
c                                         ** Eq (R6)
      QEXT = 2. / XX**2*REAL( SFORW )
      IF( PERFCT .OR. NOABS ) THEN
         QSCA = QEXT
      ELSE
         QSCA = 2./ XX**2 * QSCA
      END IF
      GQSC   = 4./ XX**2 * GQSC
      SFORW  = 0.5*SFORW
      SBACK  = 0.5*SBACK
      TFORW( 1 ) =  0.5*SFORW - 0.125*CSUM1
      TFORW( 2 ) =  0.5*SFORW + 0.125*CSUM1
      TBACK( 1 ) = -0.5*SBACK + 0.125*CSUM2
      TBACK( 2 ) =  0.5*SBACK + 0.125*CSUM2
      IF( YESANG ) THEN
c                                ** Recover scattering amplitudes
c                                ** from S+, S- ( Eq (R11) )
         IF( ANYANG ) THEN
c                                         ** vectorizable loop
            DO 70 J = 1, NUMANG
c                                                   ** Eq (R11)
               S1( J ) = 0.5*( SP( J ) + SM( J ) )
               S2( J ) = 0.5*( SP( J ) - SM( J ) )
   70       CONTINUE
         ELSE
c                                         ** vectorizable loop
            DO 80 J = 1, NANGD2
c                                                   ** Eq (R11)
               S1( J ) = 0.5*( SP( J ) + SM( J ) )
               S2( J ) = 0.5*( SP( J ) - SM( J ) )
   80       CONTINUE
c                                         ** vectorizable loop
            DO 90 J = 1, NANGD2
               S1( NUMANG + 1 - J ) = 0.5*( SPS( J ) + SMS( J ) )
               S2( NUMANG + 1 - J ) = 0.5*( SPS( J ) - SMS( J ) )
   90       CONTINUE
         END IF
      END IF
c                                 ** Calculate Legendre moments
  100 CONTINUE
      IF( NMOM.GT.0 ) CALL LPCOEF( NTRM, NMOM, IPOLZN, MOMDIM, CALCMO,
     &                             NPQUAN, LITA, LITB, PMOM )
      IF( AIMAG( CREFIN ).GT.0.0 ) THEN
c                                         ** Take complex conjugates
c                                         ** of scattering amplitudes
         SFORW = CONJG( SFORW )
         SBACK = CONJG( SBACK )
         DO 110 I = 1, 2
            TFORW( I ) = CONJG( TFORW( I ) )
            TBACK( I ) = CONJG( TBACK( I ) )
  110    CONTINUE
         DO 120 J = 1, NUMANG
            S1( J ) = CONJG( S1( J ) )
            S2( J ) = CONJG( S2( J ) )
  120    CONTINUE
      END IF

      IF( PASS1 ) THEN
c                           ** Compare test case results with
c                           ** correct answers and abort if bad;
c                           ** otherwise restore user input and proceed
         CALL TESTMI( .TRUE., XX, CREFIN, MIMCUT, PERFCT, ANYANG, NMOM,
     &                IPOLZN, NUMANG, XMU, QEXT, QSCA, GQSC, SFORW,
     &                SBACK, S1, S2, TFORW, TBACK, PMOM, MOMDIM )
         PASS1  = .FALSE.
         GO TO  10
      END IF

      IF( PRNT( 1 ) .OR. PRNT( 2 ) ) 
     &  CALL MIPRNT( PRNT, XX, PERFCT, CREFIN, NUMANG, XMU, QEXT,
     &               QSCA, GQSC, NMOM, IPOLZN, MOMDIM, CALCMO, PMOM,
     &               SFORW, SBACK, TFORW, TBACK, S1, S2 )
c
      DEALLOCATE(PIN)
      DEALLOCATE(PINM1)
      DEALLOCATE(RBIGA)
      DEALLOCATE(SM) 
      DEALLOCATE(SMS)
      DEALLOCATE(SP) 
      DEALLOCATE(SPS) 

      RETURN

      END SUBROUTINE MIEV0

      SUBROUTINE CKINMI( NUMANG, MAXANG, XX, PERFCT, CREFIN, MOMDIM,
     &                   NMOM, IPOLZN, ANYANG, XMU, CALCMO, NPQUAN )

c        Check for bad input to MIEV0 and calculate CALCMO, NPQUAN

c     Routines called :  ERRMSG, WRTBAD, WRTDIM

c     .. Scalar Arguments ..

      LOGICAL     ANYANG, PERFCT
      INTEGER     IPOLZN, MAXANG, MOMDIM, NMOM, NPQUAN, NUMANG
      REAL(EB)    XX
      COMPLEX(EB) CREFIN
c     ..
c     .. Array Arguments ..

      LOGICAL     CALCMO( * )
      REAL(EB)    XMU( * )
c     ..
c     .. Local Scalars ..

      CHARACTER(4) :: STRING
      LOGICAL     INPERR
      INTEGER     I, IP, J, L

      INPERR = .FALSE.

      IF( NUMANG.GT.MAXANG ) INPERR = WRTDIM( 'MaxAng', NUMANG )
      IF( NUMANG.LT.0 ) INPERR = WRTBAD( 'NUMANG' )

      IF( XX.LT.0. ) INPERR = WRTBAD( 'XX' )

      IF( .NOT.PERFCT .AND. REAL( CREFIN ).LE.0. )
     &    INPERR = WRTBAD( 'CREFIN' )

      IF( MOMDIM.LT.0 ) INPERR = WRTBAD( 'MOMDIM' )


      IF( NMOM.NE.0 ) THEN

         IF( NMOM.LT.0 .OR. NMOM.GT.MOMDIM ) INPERR = WRTBAD( 'NMOM' )
         IF( ABS( IPOLZN ).GT.4444 ) INPERR = WRTBAD( 'IPOLZN' )

         NPQUAN = 0

         DO 10 L = 1, 4
            CALCMO( L ) = .FALSE.
   10    CONTINUE

         IF( IPOLZN.NE.0 ) THEN
c                                 ** Parse out IPOLZN into its digits
c                                 ** to find which phase quantities are
c                                 ** to have their moments calculated
            WRITE( STRING, '(I4)' ) ABS( IPOLZN )
            DO 20 J = 1, 4
               IP = ICHAR( STRING( J:J ) ) - ICHAR( '0' )
               IF( IP.GE.1 .AND. IP.LE.4 ) CALCMO( IP ) = .TRUE.
               IF( IP.EQ.0 .OR. ( IP.GE.5 .AND. IP.LE.9 ) )
     &             INPERR = WRTBAD( 'IPOLZN' )
               NPQUAN = MAX( NPQUAN, IP )
   20       CONTINUE
         END IF
      END IF

      IF( ANYANG ) THEN
c                                ** Allow for slight imperfections in
c                                ** computation of cosine
         DO 30 I = 1, NUMANG
            IF( XMU( I ).LT.-1.00001 .OR. XMU( I ).GT.1.00001 )
     &          INPERR = WRTBAD( 'XMU' )
   30    CONTINUE
      ELSE
         DO 40 I = 1, ( NUMANG + 1 ) / 2
            IF( XMU( I ).LT.-0.00001 .OR. XMU( I ).GT.1.00001 )
     &          INPERR = WRTBAD( 'XMU' )
   40    CONTINUE
      END IF

      IF( INPERR ) CALL ERRMSG( 'MIEV0--Input error(S).  Aborting...',
     &                          .TRUE. )
      IF( XX.GT.20000.0 .OR. REAL( CREFIN ).GT.10.0 .OR.
     &    ABS( AIMAG( CREFIN ) ).GT.10.0 )
     &    CALL ERRMSG( 'MIEV0--XX or CREFIN outside tested range',
     &    .FALSE.)
      RETURN
      END SUBROUTINE CKINMI

      SUBROUTINE LPCOEF( NTRM, NMOM, IPOLZN, MOMDIM, CALCMO, NPQUAN, A,
     &                   B, PMOM )
c         Calculate Legendre polynomial expansion coefficients (also
c         called moments) for phase quantities ( Ref. 5 formulation )

c     INPUT:  NTRM                    Number terms in Mie series
c             NMOM, IPOLZN, MOMDIM    MIEV0 arguments
c             CALCMO                  Flags calculated from IPOLZN
c             NPQUAN                  Defined in MIEV0
c             A, B                    Mie series coefficients
c
c     OUTPUT: PMOM                   Legendre moments (MIEV0 argument)
c
c     Routines called :  ERRMSG, LPCO1T, LPCO2T
c
c     *** NOTES ***
c
c         (1)  Eqs. 2-5 are in error in Dave, Appl. Opt. 9,
c         1888 (1970).  Eq. 2 refers to M1, not M2;  eq. 3 refers to
c         M2, not M1.  In eqs. 4 and 5, the subscripts on the second
c         term in square brackets should be interchanged.
c
c         (2)  The general-case logic in this subroutine works correctly
c         in the two-term Mie series case, but subroutine LPCO2T
c         is called instead, for speed.
c
c         (3)  Subroutine  LPCO1T, to do the one-term case, is never
c         called within the context of MIEV0, but is included for
c         complete generality.
c
c         (4)  Some improvement in speed is obtainable by combining the
c         310- and 410-loops, if moments for both the third and fourth
c         phase quantities are desired, because the third phase quantity
c         is the real part of a complex series, while the fourth phase
c         quantity is the imaginary part of that very same series.  But
c         most users are not interested in the fourth phase quantity,
c         which is related to circular polarization, so the present
c         scheme is usually more efficient.
c
c
c           ** Definitions of local variables ***
c      AM(M)       Numerical coefficients  a-sub-m-super-l
c                     in Dave, Eqs. 1-15, as simplified in Ref. 5.
c      BI(I)       Numerical coefficients  b-sub-i-super-l
c                     in Dave, Eqs. 1-15, as simplified in Ref. 5.
c      BIDEL(I)    1/2 Bi(I) times factor capital-del in Dave
c      CM,DM()     Arrays C and D in Dave, Eqs. 16-17 (Mueller form),
c                     calculated using recurrence derived in Ref. 5
c      CS,DS()     Arrays C and D in Ref. 4, Eqs. A5-A6 (Sekera form),
c                     calculated using recurrence derived in Ref. 5
c      C,D()       Either CM,DM or CS,DS, depending on IPOLZN
c      EVENL       True for even-numbered moments;  false otherwise
c      IDEL        1 + little-del  in Dave
c      MAXTRM      Max. no. of terms in Mie series
c      MAXMOM      Max. no. of non-zero moments
c      NUMMOM      Number of non-zero moments
c      RECIP(K)    1 / K

      IMPLICIT  NONE

c     .. Parameters ..

      INTEGER     MAXTRM, MAXMOM, MXMOM2, MAXRCP
      PARAMETER ( MAXTRM=1001, MAXMOM = 2*MAXTRM, MXMOM2 = MAXMOM / 2,
     &            MAXRCP = 4*MAXTRM + 2 )
c     ..
c     .. Scalar Arguments ..

      INTEGER   IPOLZN, MOMDIM, NMOM, NPQUAN, NTRM
c     ..
c     .. Array Arguments ..

      LOGICAL     CALCMO( * )
      REAL(EB)    PMOM( 0:MOMDIM, * )
      COMPLEX(EB) A( * ), B( * )
c     ..
c     .. Local Scalars ..

      LOGICAL     EVENL, PASS1
      INTEGER     I, IDEL, IMAX, J, K, L, LD2, M, MMAX, NUMMOM
      REAL(EB)    SUM
c     ..
c     .. Local Arrays ..

      REAL(EB)    AM( 0:MAXTRM ), BI( 0:MXMOM2 ), BIDEL( 0:MXMOM2 ),
     &            RECIP( MAXRCP )
      COMPLEX(EB) C( MAXTRM ), CM( MAXTRM ), CS( MAXTRM ), D( MAXTRM ),
     &            DM( MAXTRM ), DS( MAXTRM )
c     ..
c     .. Equivalences ..

      EQUIVALENCE ( C, CM ), ( D, DM )
c     ..
      SAVE      PASS1, RECIP
      DATA      PASS1 / .TRUE. /

      IF( PASS1 ) THEN
         DO 10 K = 1, MAXRCP
            RECIP( K ) = 1.0 / K
   10    CONTINUE
         PASS1  = .FALSE.
      END IF

      DO 30 J = 1, MAX( 1, NPQUAN )
         DO 20 L = 0, NMOM
            PMOM( L, J ) = 0.0
   20    CONTINUE
   30 CONTINUE

      IF( NTRM.EQ.1 ) THEN
         CALL LPCO1T( NMOM, IPOLZN, MOMDIM, CALCMO, A, B, PMOM )
         RETURN
      ELSE IF( NTRM.EQ.2 ) THEN
         CALL LPCO2T( NMOM, IPOLZN, MOMDIM, CALCMO, A, B, PMOM )
         RETURN
      END IF

      IF( NTRM + 2.GT.MAXTRM )
     &    CALL ERRMSG('LPCoef--PARAMETER MaxTrm too small',.TRUE.)
c                                     ** Calculate Mueller C, D arrays
      CM( NTRM + 2 ) = ( 0., 0. )
      DM( NTRM + 2 ) = ( 0., 0. )
      CM( NTRM + 1 ) = ( 1. - RECIP( NTRM+1 ) ) * B( NTRM )
      DM( NTRM + 1 ) = ( 1. - RECIP( NTRM+1 ) ) * A( NTRM )
      CM( NTRM ) = ( RECIP( NTRM ) + RECIP( NTRM+1 ) ) * A( NTRM ) +
     &             ( 1. - RECIP( NTRM ) )*B( NTRM-1 )
      DM( NTRM ) = ( RECIP( NTRM ) + RECIP( NTRM+1 ) ) * B( NTRM ) +
     &             ( 1. - RECIP( NTRM ) )*A( NTRM-1 )
      DO 40 K = NTRM-1, 2, -1
         CM( K ) = CM( K+2 ) - ( 1. + RECIP(K+1) ) * B( K+1 )
     &                       + ( RECIP(K) + RECIP(K+1) ) * A( K )
     &                       + ( 1. - RECIP(K) ) * B( K-1 )
         DM( K ) = DM( K+2 ) - ( 1. + RECIP(K+1) ) * A( K+1 )
     &                       + ( RECIP(K) + RECIP(K+1) ) * B( K )
     &                       + ( 1. - RECIP(K) ) * A( K-1 )
   40 CONTINUE

      CM( 1 ) = CM( 3 ) + 1.5 * ( A( 1 ) - B( 2 ) )
      DM( 1 ) = DM( 3 ) + 1.5 * ( B( 1 ) - A( 2 ) )

      IF( IPOLZN.GE.0 ) THEN
         DO 50 K = 1, NTRM + 2
            C( K ) = ( 2*K - 1 ) * CM( K )
            D( K ) = ( 2*K - 1 ) * DM( K )
   50    CONTINUE

      ELSE
c                                    ** Compute Sekera C and D arrays
         CS( NTRM + 2 ) = ( 0., 0. )
         DS( NTRM + 2 ) = ( 0., 0. )
         CS( NTRM + 1 ) = ( 0., 0. )
         DS( NTRM + 1 ) = ( 0., 0. )

         DO 60 K = NTRM, 1, -1
            CS( K ) = CS( K+2 ) + ( 2*K + 1 ) * ( CM( K+1 ) - B( K ) )
            DS( K ) = DS( K+2 ) + ( 2*K + 1 ) * ( DM( K+1 ) - A( K ) )
   60    CONTINUE

         DO 70 K = 1, NTRM + 2
            C( K ) = ( 2*K - 1 ) * CS( K )
            D( K ) = ( 2*K - 1 ) * DS( K )
   70    CONTINUE

      END IF


      IF( IPOLZN.LT.0 ) NUMMOM = MIN( NMOM, 2*NTRM - 2 )
      IF( IPOLZN.GE.0 ) NUMMOM = MIN( NMOM, 2*NTRM )

      IF( NUMMOM.GT.MAXMOM )
     &    CALL ERRMSG('LPCoef--PARAMETER MaxTrm too small',.TRUE.)
c
c                          ** Loop over moments
      DO 240 L = 0, NUMMOM
         LD2 = L / 2
         EVENL  = MOD( L, 2 ).EQ.0
c                                    ** Calculate numerical coefficients
c                                    ** a-sub-m and b-sub-i in Dave
c                                    ** double-sums for moments
         IF( L.EQ.0 ) THEN
            IDEL = 1
            DO 80 M = 0, NTRM
               AM( M ) = 2.0 * RECIP( 2*M + 1 )
   80       CONTINUE
            BI( 0 ) = 1.0
         ELSE IF( EVENL ) THEN
            IDEL = 1
            DO 90 M = LD2, NTRM
               AM( M ) = ( 1. + RECIP( 2*M - L + 1 ) ) * AM( M )
   90       CONTINUE
            DO 100 I = 0, LD2 - 1
               BI( I ) = ( 1. - RECIP( L - 2*I ) ) * BI( I )
  100       CONTINUE
            BI( LD2 ) = ( 2. - RECIP( L ) ) * BI( LD2 - 1 )
         ELSE
            IDEL = 2
            DO 110 M = LD2, NTRM
               AM( M ) = ( 1. - RECIP( 2*M + L + 2 ) ) * AM( M )
  110       CONTINUE

            DO 120 I = 0, LD2
               BI( I ) = ( 1. - RECIP( L + 2*I + 1 ) ) * BI( I )
  120       CONTINUE
         END IF
c                                     ** Establish upper limits for sums
c                                     ** and incorporate factor capital-
c                                     ** del into b-sub-i
         MMAX = NTRM - IDEL
         IF( IPOLZN.GE.0 ) MMAX = MMAX + 1
         IMAX = MIN( LD2, MMAX - LD2 )
         IF( IMAX.LT.0 ) GO TO  250
         DO 130 I = 0, IMAX
            BIDEL( I ) = BI( I )
  130    CONTINUE
         IF( EVENL ) BIDEL( 0 ) = 0.5*BIDEL( 0 )
c                                    ** Perform double sums just for
c                                    ** phase quantities desired by user
         IF( IPOLZN.EQ.0 ) THEN
            DO 150 I = 0, IMAX
c                                           ** vectorizable loop
               SUM = 0.0
               DO 140 M = LD2, MMAX - I
                  SUM = SUM + AM( M ) *
     &                      ( REAL( C(M-I+1) * CONJG( C(M+I+IDEL) ) )
     &                      + REAL( D(M-I+1) * CONJG( D(M+I+IDEL) ) ) )
  140          CONTINUE
               PMOM( L, 1 ) = PMOM( L, 1 ) + BIDEL( I ) * SUM
  150       CONTINUE
            PMOM( L, 1 ) = 0.5*PMOM( L, 1 )
            GO TO  240
         END IF

         IF( CALCMO( 1 ) ) THEN
            DO 170 I = 0, IMAX
               SUM = 0.0
c                                           ** vectorizable loop
               DO 160 M = LD2, MMAX - I
                  SUM = SUM + AM( M ) *
     &                        REAL( C(M-I+1) * CONJG( C(M+I+IDEL) ) )
  160          CONTINUE

               PMOM( L, 1 ) = PMOM( L, 1 ) + BIDEL( I ) * SUM

  170       CONTINUE
         END IF

         IF( CALCMO( 2 ) ) THEN
            DO 190 I = 0, IMAX
               SUM = 0.0
c                                           ** vectorizable loop
               DO 180 M = LD2, MMAX - I
                  SUM = SUM + AM( M ) *
     &                        REAL( D(M-I+1) * CONJG( D(M+I+IDEL) ) )
  180          CONTINUE
               PMOM( L, 2 ) = PMOM( L, 2 ) + BIDEL( I ) * SUM
  190       CONTINUE
         END IF


         IF( CALCMO( 3 ) ) THEN
            DO 210 I = 0, IMAX
               SUM = 0.0
c                                           ** vectorizable loop
               DO 200 M = LD2, MMAX - I
                  SUM = SUM + AM( M ) *
     &                      ( REAL( C(M-I+1) * CONJG( D(M+I+IDEL) ) )
     &                      + REAL( C(M+I+IDEL) * CONJG( D(M-I+1) ) ) )
  200          CONTINUE
               PMOM( L, 3 ) = PMOM( L, 3 ) + BIDEL( I ) * SUM
  210       CONTINUE
            PMOM( L, 3 ) = 0.5*PMOM( L, 3 )
         END IF

         IF( CALCMO( 4 ) ) THEN
            DO 230 I = 0, IMAX
               SUM= 0.0
c                                           ** vectorizable loop
               DO 220 M = LD2, MMAX - I
                  SUM = SUM + AM( M ) *
     &                      ( AIMAG( C(M-I+1) * CONJG( D(M+I+IDEL) ) )
     &                      + AIMAG( C(M+I+IDEL) * CONJG( D(M-I+1) ) ) )
  220          CONTINUE
               PMOM( L, 4 ) = PMOM( L, 4 ) + BIDEL( I ) * SUM
  230       CONTINUE

            PMOM( L, 4 ) = - 0.5 * PMOM( L, 4 )
         END IF

  240 CONTINUE


  250 CONTINUE

      RETURN
      END SUBROUTINE LPCOEF

      SUBROUTINE LPCO1T( NMOM, IPOLZN, MOMDIM, CALCMO, A, B, PMOM )
c
c         Calculate Legendre polynomial expansion coefficients (also
c         called moments) for phase quantities in special case where
c         no. terms in Mie series = 1
c
c        INPUT:  NMOM, IPOLZN, MOMDIM     MIEV0 arguments
c                CALCMO                   Flags calculated from IPOLZN
c                A(1), B(1)               Mie series coefficients
c
c        OUTPUT: PMOM                     Legendre moments

c     .. Scalar Arguments ..

      INTEGER     IPOLZN, MOMDIM, NMOM
c     ..
c     .. Array Arguments ..

      LOGICAL     CALCMO( * )
      REAL(EB)    PMOM( 0:MOMDIM, * )
      COMPLEX(EB) A( * ), B( * )
c     ..
c     .. Local Scalars ..

      INTEGER     L, NUMMOM
      REAL(EB)    A1SQ, B1SQ
      COMPLEX(EB) A1B1C

      A1SQ   = SQ( A( 1 ) )
      B1SQ   = SQ( B( 1 ) )
      A1B1C  = A( 1 ) * CONJG( B( 1 ) )


      IF( IPOLZN.LT.0 ) THEN
         IF( CALCMO( 1 ) ) PMOM( 0, 1 ) = 2.25*B1SQ
         IF( CALCMO( 2 ) ) PMOM( 0, 2 ) = 2.25*A1SQ
         IF( CALCMO( 3 ) ) PMOM( 0, 3 ) = 2.25*REAL( A1B1C )
         IF( CALCMO( 4 ) ) PMOM( 0, 4 ) = 2.25*AIMAG( A1B1C )
      ELSE
         NUMMOM = MIN( NMOM, 2 )
c                             ** Loop over moments
         DO 10  L = 0, NUMMOM
            IF( IPOLZN.EQ.0 ) THEN
               IF( L.EQ.0 ) PMOM( L, 1 ) = 1.5*( A1SQ + B1SQ )
               IF( L.EQ.1 ) PMOM( L, 1 ) = 1.5*REAL( A1B1C )
               IF( L.EQ.2 ) PMOM( L, 1 ) = 0.15*( A1SQ + B1SQ )
               GO TO  10
            END IF

            IF( CALCMO( 1 ) ) THEN
               IF( L.EQ.0 ) PMOM( L, 1 ) = 2.25*( A1SQ + B1SQ / 3.)
               IF( L.EQ.1 ) PMOM( L, 1 ) = 1.5*REAL( A1B1C )
               IF( L.EQ.2 ) PMOM( L, 1 ) = 0.3*B1SQ
            END IF

            IF( CALCMO( 2 ) ) THEN
               IF( L.EQ.0 ) PMOM( L, 2 ) = 2.25*( B1SQ + A1SQ / 3. )
               IF( L.EQ.1 ) PMOM( L, 2 ) = 1.5*REAL( A1B1C )
               IF( L.EQ.2 ) PMOM( L, 2 ) = 0.3*A1SQ
            END IF

            IF( CALCMO( 3 ) ) THEN
               IF( L.EQ.0 ) PMOM( L, 3 ) = 3.0*REAL( A1B1C )
               IF( L.EQ.1 ) PMOM( L, 3 ) = 0.75*( A1SQ + B1SQ )
               IF( L.EQ.2 ) PMOM( L, 3 ) = 0.3*REAL( A1B1C )
            END IF

            IF( CALCMO( 4 ) ) THEN
               IF( L.EQ.0 ) PMOM( L, 4 ) = -1.5*AIMAG( A1B1C )
               IF( L.EQ.1 ) PMOM( L, 4 ) = 0.0
               IF( L.EQ.2 ) PMOM( L, 4 ) = 0.3*AIMAG( A1B1C )
            END IF

   10    CONTINUE
      END IF

      RETURN
      END SUBROUTINE LPCO1T

      SUBROUTINE LPCO2T( NMOM, IPOLZN, MOMDIM, CALCMO, A, B, PMOM )
c         Calculate Legendre polynomial expansion coefficients (also
c         called moments) for phase quantities in special case where
c         no. terms in Mie series = 2

c        INPUT:  NMOM, IPOLZN, MOMDIM     MIEV0 arguments
c                CALCMO                   Flags calculated from IPOLZN
c                A(1-2), B(1-2)           Mie series coefficients
c
c        OUTPUT: PMOM                     Legendre moments


c     .. Scalar Arguments ..

      INTEGER     IPOLZN, MOMDIM, NMOM
c     ..
c     .. Array Arguments ..

      LOGICAL     CALCMO( * )
      REAL(EB)    PMOM( 0:MOMDIM, * )
      COMPLEX(EB) A( * ), B( * )
c     ..
c     .. Local Scalars ..

      INTEGER     L, NUMMOM
      REAL(EB)    A2SQ, B2SQ, PM1, PM2
      COMPLEX(EB) A2C, B2C, CA, CAC, CAT, CB, CBC, CBT, CG, CH

      CA   = 3.*A( 1 ) - 5.*B( 2 )
      CAT  = 3.*B( 1 ) - 5.*A( 2 )
      CAC  = CONJG( CA )
      A2SQ = SQ( A( 2 ) )
      B2SQ = SQ( B( 2 ) )
      A2C  = CONJG( A( 2 ) )
      B2C  = CONJG( B( 2 ) )

      IF( IPOLZN.LT.0 ) THEN
c                                   ** Loop over Sekera moments
         NUMMOM = MIN( NMOM, 2 )
         DO 10 L = 0, NUMMOM
            IF( CALCMO( 1 ) ) THEN
               IF( L.EQ.0 ) PMOM( L, 1 ) = 0.25 * ( SQ( CAT )
     &                                      + (100./3.)* B2SQ )
               IF( L.EQ.1 ) PMOM( L, 1 ) = (5./3.)*REAL( CAT*B2C )
               IF( L.EQ.2 ) PMOM( L, 1 ) = (10./3.)*B2SQ
            END IF

            IF( CALCMO( 2 ) ) THEN
               IF( L.EQ.0 ) PMOM( L, 2 ) = 0.25 * ( SQ( CA )
     &                                      + (100./3.) * A2SQ )
               IF( L.EQ.1 ) PMOM( L, 2 ) = (5./3.)*REAL( CA*A2C )
               IF( L.EQ.2 ) PMOM( L, 2 ) = (10./3.)*A2SQ
            END IF

            IF( CALCMO( 3 ) ) THEN
               IF( L.EQ.0 ) PMOM( L, 3 ) = 0.25 * REAL( CAT * CAC
     &                                      + (100./3.) * B(2) * A2C )
               IF( L.EQ.1 ) PMOM( L, 3 ) = 5./6.*
     &                                     REAL( B(2)*CAC + CAT*A2C )
               IF( L.EQ.2 ) PMOM( L, 3 ) = 10./3.* REAL( B(2)*A2C )
            END IF

            IF( CALCMO( 4 ) ) THEN
               IF( L.EQ.0 ) PMOM( L, 4 ) = -0.25 * AIMAG( CAT * CAC
     &                                      + (100./3.)* B(2) * A2C )
               IF( L.EQ.1 ) PMOM( L, 4 ) = -5./ 6.*
     &                                     AIMAG( B(2)*CAC + CAT*A2C )
               IF( L.EQ.2 ) PMOM( L, 4 ) = -10./ 3.* AIMAG( B(2)*A2C )
            END IF

   10    CONTINUE

      ELSE

         CB  = 3.*B( 1 ) + 5.*A( 2 )
         CBT = 3.*A( 1 ) + 5.*B( 2 )
         CBC = CONJG( CB )
         CG  = ( CBC*CBT + 10.*( CAC*A( 2 ) + B2C*CAT ) ) / 3.
         CH  = 2.*( CBC*A( 2 ) + B2C*CBT )

c                               ** Loop over Mueller moments
         NUMMOM = MIN( NMOM, 4 )

         DO 20 L = 0, NUMMOM

            IF( IPOLZN.EQ.0 .OR. CALCMO( 1 ) ) THEN
               IF( L.EQ.0 ) PM1 = 0.25*SQ( CA ) + SQ( CB ) / 12.
     &                            + (5./3.)*REAL( CA*B2C ) + 5.*B2SQ
               IF( L.EQ.1 ) PM1 = REAL( CB * ( CAC / 6.+ B2C ) )
               IF( L.EQ.2 ) PM1 = SQ( CB ) / 30.+ (20./7.)*B2SQ
     &                            + (2./3.)*REAL( CA*B2C )
               IF( L.EQ.3 ) PM1 = (2./7.) * REAL( CB*B2C )
               IF( L.EQ.4 ) PM1 = (40./63.) * B2SQ
               IF( CALCMO( 1 ) ) PMOM( L, 1 ) = PM1
            END IF

            IF( IPOLZN.EQ.0 .OR. CALCMO( 2 ) ) THEN
               IF( L.EQ.0 ) PM2 = 0.25*SQ( CAT ) + SQ( CBT ) / 12.
     &                           + ( 5./ 3.) * REAL( CAT*A2C )
     &                           + 5.*A2SQ
               IF( L.EQ.1 ) PM2 = REAL( CBT *
     &                                 ( CONJG( CAT ) / 6.+ A2C ) )
               IF( L.EQ.2 ) PM2 = SQ( CBT ) / 30.
     &                            + ( 20./7.) * A2SQ
     &                            + ( 2./3.) * REAL( CAT*A2C )
               IF( L.EQ.3 ) PM2 = (2./7.) * REAL( CBT*A2C )
               IF( L.EQ.4 ) PM2 = (40./63.) * A2SQ
               IF( CALCMO( 2 ) ) PMOM( L, 2 ) = PM2
            END IF

            IF( IPOLZN.EQ.0 ) THEN
               PMOM( L, 1 ) = 0.5*( PM1 + PM2 )
               GO TO  20
            END IF

            IF( CALCMO( 3 ) ) THEN
               IF( L.EQ.0 ) PMOM( L, 3 ) = 0.25 * REAL( CAC*CAT + CG
     &                                         + 20.* B2C * A(2) )
               IF( L.EQ.1 ) PMOM( L, 3 ) = REAL( CAC*CBT + CBC*CAT
     &                                          + 3.*CH ) / 12.
               IF( L.EQ.2 ) PMOM( L, 3 ) = 0.1 * REAL( CG
     &                                      + (200./7.) * B2C * A(2) )
               IF( L.EQ.3 ) PMOM( L, 3 ) = REAL( CH ) / 14.
               IF( L.EQ.4 ) PMOM( L, 3 ) = 40./63.* REAL( B2C*A(2) )
            END IF

            IF( CALCMO( 4 ) ) THEN
               IF( L.EQ.0 ) PMOM( L, 4 ) = 0.25 * AIMAG( CAC*CAT + CG
     &                                      + 20.* B2C * A(2) )
               IF( L.EQ.1 ) PMOM( L, 4 ) = AIMAG( CAC*CBT + CBC*CAT
     &                                           + 3.*CH ) / 12.
               IF( L.EQ.2 ) PMOM( L, 4 ) = 0.1 * AIMAG( CG
     &                                     + (200./7.) * B2C * A(2) )
               IF( L.EQ.3 ) PMOM( L, 4 ) = AIMAG( CH ) / 14.
               IF( L.EQ.4 ) PMOM( L, 4 ) = 40./63.* AIMAG( B2C*A(2) )
            END IF

   20    CONTINUE

      END IF

      RETURN
      END SUBROUTINE LPCO2T

      SUBROUTINE BIGA( CIOR, XX, NTRM, NOABS, YESANG, RBIGA, CBIGA )

c        Calculate logarithmic derivatives of J-Bessel-function
c
c     Input :  CIOR, XX, NTRM, NOABS, YESANG  (defined in MIEV0)
c
c    Output :  RBIGA or CBIGA  (defined in MIEV0)
c
c    Routines called :  CONFRA
c
c
c    INTERNAL VARIABLES :
c
c       CONFRA     Value of Lentz continued fraction for CBIGA(NTRM),
c                     used to initialize downward recurrence
c
c       DOWN       = True, use down-recurrence.  False, do not.
c
c       F1,F2,F3   Arithmetic statement functions used in determining
c                     whether to use up-  or down-recurrence
c                     ( Ref. 2, Eqs. 6-8 )
c
c       MRE        Real refractive index
c       MIM        Imaginary refractive index
c
c       REZINV     1 / ( MRE * XX ); temporary variable for recurrence
c       ZINV       1 / ( CIOR * XX ); temporary variable for recurrence
c
c     .. Scalar Arguments ..

      LOGICAL     NOABS, YESANG
      INTEGER     NTRM
      REAL(EB)    XX
      COMPLEX(EB) CIOR
c     ..
c     .. Array Arguments ..
      REAL(EB)    RBIGA( * )
      COMPLEX(EB) CBIGA( * )

c     .. Local Scalars ..
      LOGICAL     DOWN
      INTEGER     N
      REAL(EB)    MIM, MRE, REZINV, RTMP
      COMPLEX(EB) CTMP, ZINV

c                                  ** Decide whether BigA can be
c                                  ** calculated by up-recurrence
      MRE = REAL( CIOR )
      MIM = ABS( AIMAG( CIOR ) )
      IF( MRE.LT.1.0 .OR. MRE.GT.10.0 .OR. MIM.GT.10.0 ) THEN
         DOWN = .TRUE.
      ELSE IF( YESANG ) THEN
         DOWN = .TRUE.
c                                                    ** Eq. R48
         IF( MIM*XX .LT. F2( MRE ) ) DOWN = .FALSE.
      ELSE
         DOWN = .TRUE.
c                                                    ** Eq. R48
         IF( MIM*XX .LT. F1( MRE ) ) DOWN = .FALSE.
      END IF

      ZINV   = 1.0 / ( CIOR*XX )
      REZINV = 1.0 / ( MRE*XX )


      IF( DOWN ) THEN
c                          ** Compute initial high-order BigA using
c                          ** Lentz method ( Ref. 1, pp. 17-20 )
         CTMP = CONFRA( NTRM, ZINV )
c                                   *** Downward recurrence for BigA
         IF( NOABS ) THEN
c                                        ** No-absorption case; Eq (R23)
            RBIGA( NTRM ) = REAL( CTMP )
            DO 10 N = NTRM, 2, -1
               RBIGA( N - 1 ) = ( N*REZINV ) -
     &                          1.0 / ( ( N*REZINV ) + RBIGA( N ) )
   10       CONTINUE
         ELSE
c                                         ** Absorptive case; Eq (R23)
            CBIGA( NTRM ) = CTMP
            DO 20 N = NTRM, 2, -1
               CBIGA( N-1 ) = (N*ZINV) - 1.0 / ( (N*ZINV) + CBIGA( N ) )
   20       CONTINUE
         END IF

      ELSE
c                            *** Upward recurrence for BigA
         IF( NOABS ) THEN
c                                  ** No-absorption case; Eq (R20,21)
            RTMP = SIN( MRE*XX )
            RBIGA( 1 ) = - REZINV + RTMP /
     &                   ( RTMP*REZINV - COS( MRE*XX ) )

            DO 30 N = 2, NTRM
               RBIGA( N ) = -( N*REZINV ) +
     &                      1.0 / ( ( N*REZINV ) - RBIGA( N - 1 ) )
   30       CONTINUE

         ELSE
c                                     ** Absorptive case; Eq (R20,22)
            CTMP = EXP( - (0.,2.)*CIOR*XX )
            CBIGA( 1 ) = - ZINV + (1.-CTMP) /
     &                          ( ZINV * (1.-CTMP) - (0.,1.)*(1.+CTMP) )
            DO 40 N = 2, NTRM
               CBIGA( N ) = - (N*ZINV) + 1.0 / ((N*ZINV) - CBIGA( N-1 ))
   40       CONTINUE

         END IF

      END IF

      CONTAINS

      REAL(EB) FUNCTION F1(MRE)
      REAL(EB), INTENT(IN) :: MRE
      F1 = -8.0 + MRE**2*( 26.22 +
     .            MRE*( -0.4474 + MRE**3*( 0.00204 - 0.000175*MRE ) ) )
      END FUNCTION F1

      REAL(EB) FUNCTION F2(MRE)  ! Eq. R47b
      REAL(EB), INTENT(IN) :: MRE
      F2 = 3.9 + MRE*( -10.8 + 13.78*MRE )
      END FUNCTION F2

      END SUBROUTINE BIGA

      COMPLEX(EB) FUNCTION CONFRA( N, ZINV )

c         Compute Bessel function ratio A-sub-N from its
c         continued fraction using Lentz method
c
c         ZINV = Reciprocal of argument of A
c
c
c    I N T E R N A L    V A R I A B L E S
c    ------------------------------------
c
c    CAK      Term in continued fraction expansion of A (Eq. R25)
c    CAPT     Factor used in Lentz iteration for A (Eq. R27)
c    CNUMER   Numerator   in capT  ( Eq. R28A )
c    CDENOM   Denominator in capT  ( Eq. R28B )
c    CDTD     Product of two successive denominators of capT factors
c                 ( Eq. R34C )
c    CNTN     Product of two successive numerators of capT factors
c                 ( Eq. R34B )
c    EPS1     Ill-conditioning criterion
c    EPS2     Convergence criterion
c    KK       Subscript k of cAk  ( Eq. R25B )
c    KOUNT    Iteration counter ( used to prevent infinite looping )
c    MAXIT    Max. allowed no. of iterations
c    MM       + 1  and - 1, alternately
c --------------------------------------------------------------------

c     .. Scalar Arguments ..

      INTEGER     N
      COMPLEX(EB) ZINV
c     ..
c     .. Local Scalars ..

      INTEGER     KK, KOUNT, MAXIT, MM
      REAL(EB)    EPS1, EPS2
      COMPLEX(EB) CAK, CAPT, CDENOM, CDTD, CNTN, CNUMER
c     
      DATA      EPS1 / 1.E-2_EB / , EPS2 / 1.E-8_EB /
      DATA      MAXIT / 10000 /
c                                 ** Eq. R25a
      CONFRA = ( N + 1 ) * ZINV
      MM     = - 1
      KK     = 2*N + 3
c                                 ** Eq. R25b, k=2
      CAK    = ( MM*KK ) * ZINV
      CDENOM = CAK
      CNUMER = CDENOM + 1.0 / CONFRA
      KOUNT  = 1

   10 CONTINUE
      KOUNT = KOUNT + 1

      IF( KOUNT.GT.MAXIT )
     &    CALL ERRMSG('ConFra--Iteration failed to converge',.TRUE.)

      MM  = - MM
      KK  = KK + 2
c                                 ** Eq. R25b
      CAK = ( MM*KK ) * ZINV
c                                          ** Eq. R32
      IF( ABS( CNUMER / CAK ).LE.EPS1 .OR.
     &    ABS( CDENOM / CAK ).LE.EPS1 ) THEN

c                                  ** Ill-conditioned case -- stride
c                                  ** two terms instead of one

c                                       ** Eq. R34
         CNTN   = CAK * CNUMER + 1.0
         CDTD   = CAK * CDENOM + 1.0
c                                           ** Eq. R33
         CONFRA = ( CNTN / CDTD ) * CONFRA

         MM  = - MM
         KK  = KK + 2
c                                 ** Eq. R25b
         CAK = ( MM*KK ) * ZINV
c                                      ** Eq. R35
         CNUMER = CAK + CNUMER / CNTN
         CDENOM = CAK + CDENOM / CDTD
         KOUNT  = KOUNT + 1
         GO TO  10

      ELSE
c                           *** Well-conditioned case

c                                  ** Eq. R27
         CAPT   = CNUMER / CDENOM
c                                  ** Eq. R26
         CONFRA = CAPT * CONFRA
c                                  ** Check for convergence; Eq. R31

         IF (      ABS( REAL (CAPT) - 1.0 ).GE.EPS2
     &        .OR. ABS( AIMAG(CAPT) )      .GE.EPS2 )  THEN
c                                        ** Eq. R30
            CNUMER = CAK + 1.0 / CNUMER
            CDENOM = CAK + 1.0 / CDENOM
            GO TO  10
         END IF
      END IF

      RETURN
      END FUNCTION CONFRA

      SUBROUTINE MIPRNT( PRNT, XX, PERFCT, CREFIN, NUMANG, XMU, QEXT,
     &                   QSCA, GQSC, NMOM, IPOLZN, MOMDIM, CALCMO, PMOM,
     &                   SFORW, SBACK, TFORW, TBACK, S1, S2 )

c         Print scattering quantities of a single particle

c     .. Scalar Arguments ..
      LOGICAL     PERFCT
      INTEGER     IPOLZN, MOMDIM, NMOM, NUMANG
      REAL(EB)    GQSC, QEXT, QSCA, XX
      COMPLEX(EB) CREFIN, SBACK, SFORW
c     ..
c     .. Array Arguments ..
      LOGICAL     CALCMO( * ), PRNT( * )
      REAL(EB)    PMOM( 0:MOMDIM, * ), XMU( * )
      COMPLEX(EB) S1( * ), S2( * ), TBACK( * ), TFORW( * )
c     ..
c     .. Local Scalars ..
      CHARACTER   FMAT*22
      INTEGER     I, J, M
      REAL(EB)    FNORM, I1, I2
c     ..
c     .. Intrinsic Functions ..
c     INTRINSIC AIMAG, CONJG, REAL
c     ..

      IF( PERFCT ) WRITE(LU0, '(''1'',10X,A,1P,E11.4)' )
     &    'Perfectly Conducting Case, size parameter =', XX

      IF( .NOT.PERFCT ) WRITE(LU0, '(''1'',10X,3(A,1P,E11.4))' )
     &    'Refractive Index:  Real ', REAL( CREFIN ), '  Imag ',
     &    AIMAG( CREFIN ), ',   Size Parameter =', XX


      IF( PRNT( 1 ) .AND. NUMANG.GT.0 ) THEN

         WRITE(LU0, '(/,A)' )
     &      '    cos(angle)  ------- S1 ---------  ------- S2 ---------'
     &      // '  --- S1*conjg(S2) ---   i1=S1**2   i2=S2**2  (i1+i2)/2'
     &      // '  DEG POLZN'

         DO 10 I = 1, NUMANG
            I1 = REAL( S1( I ) )**2 + AIMAG( S1( I ) )**2
            I2 = REAL( S2( I ) )**2 + AIMAG( S2( I ) )**2
            WRITE(LU0, '( I4, F10.6, 1P,10E11.3 )'   )
     &              I, XMU(I), S1(I), S2(I), S1(I)*CONJG(S2(I)),
     &              I1, I2, 0.5*(I1+I2), (I2-I1)/(I2+I1)
   10    CONTINUE
      END IF


      IF( PRNT( 2 ) ) THEN

         WRITE (LU0, '(/,A,9X,A,17X,A,17X,A,/,(0P,F7.2, 1P,6E12.3) )' )
     &           '  Angle', 'S-sub-1', 'T-sub-1', 'T-sub-2',
     &               0.0,     SFORW,    TFORW(1),  TFORW(2),
     &              180.,     SBACK,    TBACK(1),  TBACK(2)
         WRITE (LU0, '(/,4(A,1P,E11.4))' )
     &           ' Efficiency Factors,  extinction:', QEXT,
     &                              '   scattering:', QSCA,
     &                              '   absorption:', QEXT-QSCA,
     &                           '   rad. pressure:', QEXT-GQSC
         IF( NMOM.GT.0 ) THEN
            WRITE(LU0, '(/,A)' ) ' Normalized moments of :'
            IF( IPOLZN.EQ.0 ) WRITE(LU0, '(''+'',27X,A)' )
     &          'Phase Fcn'
            IF( IPOLZN.GT.0 ) WRITE(LU0, '(''+'',33X,A)' )
     &          'M1           M2          S21          D21'

            IF( IPOLZN.LT.0 ) WRITE(LU0, '(''+'',33X,A)' )
     &          'R1           R2           R3           R4'
            FNORM = 4./ ( XX**2 * QSCA )
            DO 30  M = 0, NMOM
               WRITE(LU0, '(A,I4)' ) '      Moment no.', M
               DO 20 J = 1, 4
                  IF( CALCMO( J ) ) THEN
                     WRITE( FMAT, '(A,I2,A)' )
     &                      '( ''+'', T', 24+(J-1)*13, ', 1P,E13.4 )'
                     WRITE(LU0, FMAT ) FNORM * PMOM( M, J )
                  END IF

   20          CONTINUE
   30       CONTINUE
         END IF
      END IF

      RETURN
      END SUBROUTINE MIPRNT

      SUBROUTINE SMALL1( XX, NUMANG, XMU, QEXT, QSCA, GQSC, SFORW,
     &                   SBACK, S1, S2, TFORW, TBACK, A, B )

c       Small-particle limit of Mie quantities in totally reflecting
c       limit ( Mie series truncated after 2 terms )
c
c        A,B       First two Mie coefficients, with numerator and
c                  denominator expanded in powers of XX ( a factor
c                  of XX**3 is missing but is restored before return
c                  to calling program )  ( Ref. 2, p. 1508 )

c     .. Parameters ..
      REAL(EB)  TWOTHR, FIVTHR, FIVNIN
      PARAMETER ( TWOTHR = 2./3., FIVTHR = 5./3., FIVNIN = 5./9. )
c     ..
c     .. Scalar Arguments ..
      INTEGER     NUMANG
      REAL(EB)    GQSC, QEXT, QSCA, XX
      COMPLEX(EB) SBACK, SFORW
c     ..
c     .. Array Arguments ..
      REAL(EB)    XMU( * )
      COMPLEX(EB) A(*), B( * ), S1( * ), S2( * ), TBACK( * ), TFORW( * )
c     ..
c     .. Local Scalars ..
      INTEGER     J
      REAL(EB)    RTMP

c                                                       ** Eq. R/A.5
      A( 1 ) = CMPLX( 0., TWOTHR*( 1. - 0.2*XX**2 ) ) /
     &         CMPLX( 1. - 0.5*XX**2, TWOTHR*XX**3 )
c                                                       ** Eq. R/A.6
      B( 1 ) = CMPLX( 0., - ( 1. - 0.1*XX**2 ) / 3.) /
     &         CMPLX( 1. + 0.5*XX**2, - XX**3 / 3.)
c                                                       ** Eq. R/A.7,8
      A( 2 ) = CMPLX( 0.,   XX**2 / 30.)
      B( 2 ) = CMPLX( 0., - XX**2 / 45.)
c                                                       ** Eq. R/A.9
      QSCA = 6.* XX**4 *( SQ( A(1) ) + SQ( B(1) ) +
     &           FIVTHR*( SQ( A(2) ) + SQ( B(2) ) ) )
      QEXT = QSCA
c                                                       ** Eq. R/A.10
      GQSC = 6.* XX**4 *REAL( A(1)*CONJG( A(2) + B(1) ) +
     &         ( B(1) + FIVNIN*A(2) )*CONJG( B(2) ) )

      RTMP   = 1.5 * XX**3
      SFORW  = RTMP*( A(1) + B(1) + FIVTHR*( A(2) + B(2) ) )
      SBACK  = RTMP*( A(1) - B(1) - FIVTHR*( A(2) - B(2) ) )
      TFORW( 1 ) = RTMP*( B(1) + FIVTHR*( 2.*B(2) - A(2) ) )
      TFORW( 2 ) = RTMP*( A(1) + FIVTHR*( 2.*A(2) - B(2) ) )
      TBACK( 1 ) = RTMP*( B(1) - FIVTHR*( 2.*B(2) + A(2) ) )
      TBACK( 2 ) = RTMP*( A(1) - FIVTHR*( 2.*A(2) + B(2) ) )

      DO 10 J = 1, NUMANG
c                                                    ** Eq. R/A.11,12
         S1( J ) = RTMP*( A(1) + B(1)*XMU( J ) +
     &                    FIVTHR*( A(2)*XMU( J ) + 
     &                             B(2)*( 2.*XMU( J )**2 - 1.) ) )
         S2( J ) = RTMP*( B(1) + A(1)*XMU( J ) +
     &                    FIVTHR*( B(2)*XMU( J ) + 
     &                             A(2)*( 2.*XMU( J )**2 - 1.) ) )
   10 CONTINUE
c                                     ** Recover actual Mie coefficients
      A( 1 ) = XX**3 * A(1)
      A( 2 ) = XX**3 * A(2)
      B( 1 ) = XX**3 * B(1)
      B( 2 ) = XX**3 * B(2)

      RETURN
      END SUBROUTINE SMALL1

      SUBROUTINE SMALL2( XX, CIOR, CALCQE, NUMANG, XMU, QEXT, QSCA,
     &                   GQSC, SFORW, SBACK, S1, S2, TFORW, TBACK,
     &                   A, B )

c       Small-particle limit of Mie quantities for general refractive
c       index ( Mie series truncated after 2 terms )
c
c        A,B       First two Mie coefficients, with numerator and
c                  denominator expanded in powers of XX ( a factor
c                  of XX**3 is missing but is restored before return
c                  to calling program )

c        CIORSQ    Square of refractive index

c     .. Parameters ..
      REAL(EB)    TWOTHR, FIVTHR
      PARAMETER   ( TWOTHR = 2./3., FIVTHR = 5./3.)
c     ..
c     .. Scalar Arguments ..
      LOGICAL     CALCQE
      INTEGER     NUMANG
      REAL(EB)    GQSC, QEXT, QSCA, XX
      COMPLEX(EB) CIOR, SBACK, SFORW
c     ..
c     .. Array Arguments ..
      REAL(EB)    XMU( * )
      COMPLEX(EB) A(*), B(*), S1(*), S2(*), TBACK(*), TFORW( * )
c     ..
c     .. Local Scalars ..
      INTEGER   J
      REAL(EB)  RTMP
      COMPLEX(EB)   CIORSQ, CTMP


      CIORSQ = CIOR**2
      CTMP   = CMPLX( 0., TWOTHR )*( CIORSQ - 1.0 )

c                                           ** Eq. R42a
      A( 1 ) = CTMP*( 1.- 0.1*XX**2 +
     &         ( CIORSQ / 350. + 1./280.)*XX**4 ) /
     &         ( CIORSQ + 2.+ ( 1.- 0.7*CIORSQ )*XX**2 -
     &         ( CIORSQ**2 / 175.- 0.275*CIORSQ + 0.25 )*XX**4 +
     &         XX**3 * CTMP * ( 1.- 0.1*XX**2 ) )

c                                           ** Eq. R42b
      B( 1 ) = ( XX**2 / 30. )*CTMP*( 1.+
     &         ( CIORSQ / 35. - 1./ 14.)*XX**2 ) /
     &         ( 1.- ( CIORSQ / 15. - 1./6.)*XX**2 )

c                                           ** Eq. R42c

      A( 2 ) = ( 0.1*XX**2 )*CTMP*( 1.- XX**2 / 14. ) /
     &         ( 2.*CIORSQ + 3.- ( CIORSQ / 7.- 0.5 ) * XX**2 )

c                                           ** Eq. R40a

      QSCA = (6.*XX**4) * ( SQ( A(1) ) + SQ( B(1) ) +
     &                     FIVTHR * SQ( A(2) ) )

c                                           ** Eq. R40b
      QEXT = QSCA
      IF( CALCQE ) QEXT = 6.*XX * REAL( A(1) + B(1) + FIVTHR*A(2) )

c                                           ** Eq. R40c

      GQSC = (6.*XX**4) * REAL( A(1)*CONJG( A(2) + B(1) ) )

      RTMP   = 1.5 * XX**3
      SFORW  = RTMP*( A(1) + B(1) + FIVTHR*A(2) )
      SBACK  = RTMP*( A(1) - B(1) - FIVTHR*A(2) )
      TFORW( 1 ) = RTMP*( B(1) - FIVTHR*A(2) )
      TFORW( 2 ) = RTMP*( A(1) + 2.*FIVTHR*A(2) )
      TBACK( 1 ) = TFORW(1)
      TBACK( 2 ) = RTMP*( A(1) - 2.*FIVTHR*A(2) )


      DO 10 J = 1, NUMANG
c                                      ** Eq. R40d,e

         S1( J ) = RTMP*( A(1) + ( B(1) + FIVTHR*A(2) )*XMU( J ) )
         S2( J ) = RTMP*( B(1) + A(1)*XMU( J ) +
     &                    FIVTHR*A(2)*( 2.*XMU( J )**2 - 1.) )
   10 CONTINUE

c                                     ** Recover actual Mie coefficients
      A( 1 ) = XX**3 * A(1)
      A( 2 ) = XX**3 * A(2)
      B( 1 ) = XX**3 * B(1)
      B( 2 ) = ( 0., 0.)

      RETURN
      END SUBROUTINE SMALL2

      SUBROUTINE TESTMI( COMPAR, XX, CREFIN, MIMCUT, PERFCT, ANYANG,
     &                   NMOM, IPOLZN, NUMANG, XMU, QEXT, QSCA, GQSC,
     &                   SFORW, SBACK, S1, S2, TFORW, TBACK, PMOM,
     &                   MOMDIM )

c         Set up to run test case when  COMPAR = False;  when  = True,
c         compare Mie code test case results with correct answers
c         and abort if even one result is inaccurate.

c         The test case is :  Mie size parameter = 10
c                             refractive index   = 1.5 - 0.1 i
c                             scattering angle = 140 degrees
c                             1 Sekera moment

c         Results for this case may be found among the test cases
c         at the end of reference (1).

c         *** NOTE *** When running on some computers, esp. in single
c         precision, the Accur criterion below may have to be relaxed.
c         However, if Accur must be set larger than 10**-3 for some
c         size parameters, your computer is probably not accurate
c         enough to do Mie computations for those size parameters.

c     Routines called :  ERRMSG, MIPRNT, TSTBAD

c     .. Scalar Arguments ..

      LOGICAL     ANYANG, COMPAR, PERFCT
      INTEGER     IPOLZN, MOMDIM, NMOM, NUMANG
      REAL(EB)    GQSC, MIMCUT, QEXT, QSCA, XX
      COMPLEX(EB) CREFIN, SBACK, SFORW
c     ..
c     .. Array Arguments ..

      REAL(EB)    PMOM( 0:MOMDIM, * ), XMU( * )
      COMPLEX(EB) S1( * ), S2( * ), TBACK( * ), TFORW( * )
c     ..
c     .. Local Scalars ..

      LOGICAL     ANYSAV, OK, PERSAV
      INTEGER     IPOSAV, M, N, NMOSAV, NUMSAV
      REAL(EB)    MIMSAV, TESTGQ, TESTQE, TESTQS,
     &            XMUSAV, XXSAV
      COMPLEX(EB) CRESAV, TESTS1, TESTS2, TESTSB, TESTSF
c     ..
c     .. Local Arrays ..

      LOGICAL     CALCMO( 4 ), PRNT( 2 )
      REAL(EB)    TESTPM( 0:1 )
      COMPLEX(EB) TESTTB( 2 ), TESTTF( 2 )
c
c     LOGICAL   WRONG
c     ..
      SAVE      XXSAV, CRESAV, MIMSAV, PERSAV, ANYSAV, NMOSAV, IPOSAV,
     &          NUMSAV, XMUSAV

      DATA      TESTQE / 2.459791_EB /,
     &          TESTQS / 1.235144_EB /,
     &          TESTGQ / 1.139235_EB /,
     &          TESTSF / ( 61.49476_EB, -3.177994_EB ) /,
     &          TESTSB / ( 1.493434_EB,  0.2963657_EB ) /,
     &          TESTS1 / ( -0.1548380_EB, -1.128972_EB ) /,
     &          TESTS2 / ( 0.05669755_EB, 0.5425681_EB ) /,
     &          TESTTF / ( 12.95238_EB, -136.6436_EB ),
     &                   ( 48.54238_EB, 133.4656_EB ) /,
     &          TESTTB / ( 41.88414_EB, -15.57833_EB ),
     &                   ( 43.37758_EB, -15.28196_EB ) /,
     &          TESTPM / 227.1975_EB, 183.6898_EB /

c     DATA      ACCUR / 1.E-4_EB /
c     ..
c     .. Statement Function definitions ..

c     WRONG( CALC, EXACT ) = ABS( ( CALC - EXACT ) / EXACT ).GT.ACCUR
c     ..


      IF( .NOT.COMPAR ) THEN
c                                   ** Save certain user input values
         XXSAV  = XX
         CRESAV = CREFIN
         MIMSAV = MIMCUT
         PERSAV = PERFCT
         ANYSAV = ANYANG
         NMOSAV = NMOM
         IPOSAV = IPOLZN
         NUMSAV = NUMANG
         XMUSAV = XMU( 1 )
c                                   ** Reset input values for test case
         XX     = 10.0
         CREFIN = ( 1.5, -0.1 )
         MIMCUT = 0.0
         PERFCT = .FALSE.
         ANYANG = .TRUE.
         NMOM   = 1
         IPOLZN = -1
         NUMANG = 1
         XMU( 1 ) = -0.7660444

      ELSE
c                                    ** Compare test case results with
c                                    ** correct answers and abort if bad
         OK = .TRUE.

         IF( WRONG( QEXT,TESTQE ) )
     &       OK = TSTBAD( 'QEXT', ABS( ( QEXT - TESTQE ) / TESTQE ) )

         IF( WRONG( QSCA,TESTQS ) )
     &       OK = TSTBAD( 'QSCA', ABS( ( QSCA - TESTQS ) / TESTQS ) )

         IF( WRONG( GQSC,TESTGQ ) )
     &       OK = TSTBAD( 'GQSC', ABS( ( GQSC - TESTGQ ) / TESTGQ ) )

         IF( WRONG( REAL( SFORW ),REAL( TESTSF ) ) .OR.
     &       WRONG( AIMAG( SFORW ),AIMAG( TESTSF ) ) )
     &       OK = TSTBAD( 'SFORW', ABS( ( SFORW - TESTSF ) / TESTSF ) )

         IF( WRONG( REAL( SBACK ),REAL( TESTSB ) ) .OR.
     &       WRONG( AIMAG( SBACK ),AIMAG( TESTSB ) ) )
     &       OK = TSTBAD( 'SBACK', ABS( ( SBACK - TESTSB ) / TESTSB ) )

         IF( WRONG( REAL( S1(1) ),REAL( TESTS1 ) ) .OR.
     &       WRONG( AIMAG( S1(1) ),AIMAG( TESTS1 ) ) )
     &       OK = TSTBAD( 'S1', ABS( ( S1(1) - TESTS1 ) / TESTS1 ) )

         IF( WRONG( REAL( S2(1) ),REAL( TESTS2 ) ) .OR.
     &       WRONG( AIMAG( S2(1) ),AIMAG( TESTS2 ) ) )
     &       OK = TSTBAD( 'S2', ABS( ( S2(1) - TESTS2 ) / TESTS2 ) )


         DO 10  N = 1, 2

            IF( WRONG( REAL( TFORW(N) ),REAL( TESTTF(N) ) ) .OR.
     &          WRONG( AIMAG( TFORW(N) ),
     &          AIMAG( TESTTF(N) ) ) ) OK = TSTBAD( 'TFORW',
     &          ABS( ( TFORW(N) - TESTTF(N) ) / TESTTF(N) ) )

            IF( WRONG( REAL( TBACK(N) ),REAL( TESTTB(N) ) ) .OR.
     &          WRONG( AIMAG( TBACK(N) ),
     &          AIMAG( TESTTB(N) ) ) ) OK = TSTBAD( 'TBACK',
     &          ABS( ( TBACK(N) - TESTTB(N) ) / TESTTB(N) ) )

   10    CONTINUE


         DO 20 M = 0, 1

            IF ( WRONG( PMOM(M,1), TESTPM(M) ) )
     &           OK =  TSTBAD( 'PMOM', ABS( (PMOM(M,1)-TESTPM(M)) /
     &                                      TESTPM(M) ) )

   20    CONTINUE


         IF( .NOT.OK ) THEN

            PRNT( 1 ) = .TRUE.
            PRNT( 2 ) = .TRUE.
            CALCMO( 1 ) = .TRUE.
            CALCMO( 2 ) = .FALSE.
            CALCMO( 3 ) = .FALSE.
            CALCMO( 4 ) = .FALSE.

            CALL MIPRNT( PRNT, XX, PERFCT, CREFIN, NUMANG, XMU, QEXT,
     &                   QSCA, GQSC, NMOM, IPOLZN, MOMDIM, CALCMO, PMOM,
     &                   SFORW, SBACK, TFORW, TBACK, S1, S2 )

            CALL ERRMSG( 'MIEV0 -- Self-test failed',.TRUE.)

         END IF
c                                       ** Restore user input values
         XX     = XXSAV
         CREFIN = CRESAV
         MIMCUT = MIMSAV
         PERFCT = PERSAV
         ANYANG = ANYSAV
         NMOM   = NMOSAV
         IPOLZN = IPOSAV
         NUMANG = NUMSAV
         XMU( 1 ) = XMUSAV

      END IF

      CONTAINS

      LOGICAL FUNCTION WRONG(CALC,EXACT)
      REAL(EB) ACCUR
      REAL(EB), INTENT(IN) :: CALC,EXACT
      DATA  ACCUR / 1.E-4_EB /
      WRONG = ABS( ( CALC - EXACT ) / EXACT ).GT.ACCUR
      END FUNCTION WRONG

      END SUBROUTINE TESTMI


      SUBROUTINE ErrMsg( MESSAG, FATAL )

c        Print out a warning or error message;  abort if error
c        after making symbolic dump (machine-specific)

c     .. Scalar Arguments ..

      CHARACTER MESSAG*(*)
      LOGICAL   FATAL
c     ..
c     .. Local Scalars ..

      LOGICAL   MSGLIM
      INTEGER   MAXMSG, NUMMSG
c     ..
c     .. External Subroutines ..

ccccc EXTERNAL  SYMDUMP
c     ..
      SAVE      MAXMSG, NUMMSG, MSGLIM
      DATA      NUMMSG / 0 /,  MAXMSG / 100 /,  MSGLIM /.FALSE./


      IF (FATAL) CALL SHUTDOWN(MESSAG)

      NUMMSG = NUMMSG + 1

      IF( MSGLIM ) RETURN

      IF( NUMMSG.LE.MAXMSG ) THEN

         WRITE(LU0, '(/,2A,/)' ) ' ****** WARNING *****  ', MESSAG

      ELSE

         WRITE(LU0, 9000 )
         MSGLIM = .True.
      END IF


      RETURN

 9000 FORMAT( / , / , ' ****** TOO MANY WARNING MESSAGES --  ',
     &      'They will no longer be printed *******', / , / )
      END SUBROUTINE ErrMsg

      LOGICAL FUNCTION WrtBad( VarNam )

c          Write names of erroneous variables and return 'TRUE'

c      INPUT :   VarNam = Name of erroneous variable to be written
c                         ( CHARACTER, any length )

c     .. Scalar Arguments ..

      CHARACTER VarNam*(*)
c     ..
c     .. Local Scalars ..

      INTEGER   MAXMSG, NUMMSG
c     ..
      SAVE      NUMMSG, MAXMSG
      DATA      NUMMSG / 0 /, MAXMSG / 50 /


      WrtBad = .TRUE.
      NUMMSG = NUMMSG + 1
      WRITE(LU0, '(3A)' ) ' ****  Input variable  ', VarNam,
     &                   '  in error  ****'

      IF( NUMMSG.EQ.MAXMSG )
     &    CALL ErrMsg( 'Too many input errors.  Aborting...',.TRUE.)

      RETURN
      END FUNCTION WrtBad

      LOGICAL FUNCTION WrtDim( DimNam, Minval )

c          Write name of too-small symbolic dimension and
c          the value it should be increased to;  return 'TRUE'

c      INPUT :  DimNam = Name of symbolic dimension which is too small
c                        ( CHARACTER, any length )
c               Minval = Value to which that dimension should be
c                        increased (at least)

c     .. Scalar Arguments ..

      CHARACTER DimNam*(*)
      INTEGER   Minval
c     ..

      WRITE(LU0, '(3A,I7)' ) ' ****  Symbolic dimension  ', DimNam,
     &                      '  should be increased to at least ', Minval
      WrtDim = .TRUE.
      RETURN
      END FUNCTION WrtDim

      LOGICAL FUNCTION TstBad( VarNam, RelErr )

c       Write name (VarNam) of variable failing self-test and its
c       percent error from the correct value;  return  'FALSE'.

c     .. Scalar Arguments ..

      CHARACTER VarNam*(*)
      REAL(EB)  RelErr

      TstBad = .FALSE.
      WRITE(LU0, '(/,3A,1P,E11.2,A)' ) ' *** Output variable ', VarNam,
     &   ' differed by ', 100.*RelErr,
     &   ' per cent from correct value.  Self-test failed.'
      RETURN
      END FUNCTION TstBad

      REAL(EB) FUNCTION SQ(CTMP)
      COMPLEX(EB), INTENT(IN) :: CTMP
      SQ = REAL( CTMP )**2 + AIMAG( CTMP )**2
      END FUNCTION SQ
 
      END MODULE MIEV
